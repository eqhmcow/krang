#!/usr/bin/perl
use warnings;
use strict;

=pod

=head1 NAME

krang_schedulectl

=head1 SYNOPSIS

   krang_schedulectl start

   krang_schedulectl stop

   krang_schedulectl restart

=head1 DESCRIPTION

This script controls the Krang Schedule Daemon.  Instead of calling this
script directly, call krang_ctl instead.

=cut

# how long to wait for stop on restart (in seconds)
use constant MAX_RESTART_WAIT => 10;
$|++;

use File::Spec::Functions qw(catdir catfile splitdir rel2abs);
use FindBin qw($RealBin);
use Config;

BEGIN {
    # Find a KRANG_ROOT based on path to bin
    my @dir = splitdir($RealBin);
    $ENV{KRANG_ROOT} ||= catdir(@dir[0 .. $#dir - 1]);

    # use $KRANG_ROOT/lib for modules
    my $lib    = catdir($ENV{KRANG_ROOT}, "lib");
    $ENV{PERL5LIB} = $ENV{PERL5LIB} ? "$ENV{PERL5LIB}:${lib}" : "${lib}";
    unshift @INC, $lib, "$lib/".$Config{archname};

    # load Krang::Conf (don't need to load Krang here because we won't
    # be slinging elements)
    eval { require Krang::Conf };
    die <<"END" if $@;
######################################################################

Cannot load Krang.

Error message:

$@

######################################################################
END
}

use Krang::Conf qw(KrangRoot);

# the krang_scheduled command
my $scheduled = rel2abs(catfile(KrangRoot, 'bin', 'krang_scheduled'));

# get status from the pid file
my $pid_file = catfile(KrangRoot, "tmp", "schedule_daemon.pid");
my $running = 0;
my $pid;
if (-e $pid_file) {
    $pid = `cat $pid_file`;
    chomp $pid;
    if ($pid and kill(0, $pid)) {
        $running = 1;
    }
}

# check for args
usage() unless @ARGV;

my $command = shift @ARGV;

if ($command eq 'start') {
    if ($running) {
        die "krang_schedulectl $command: krang_scheduled (pid $pid) already " .
          "running\n";
    }

    print "krang_schedulectl $command: starting krang_scheduled\n";
    unless (system($scheduled)) {
        print "krang_schedulectl $command: krang_scheduled started\n";
        exit;
    } else {
        die "krang_schedulectl $command: krang_scheduled could not be " .
          "started\n";
    }
}

if ($command eq 'stop') {
    unless ($running) {
        die "krang_schedulectl $command: krang_scheduled not running\n";
    }
    if (kill 15, $pid) {
        print "krang_schedulectl $command: krang_scheduled stopped\n";
        exit;
    } else {
        die "krang_schedulectl $command: krang_scheduled could not be " .
          "stopped\n";
    }
}

if ($command eq 'restart') {
    # stop
    if ($running) {
        if (kill 15, $pid) {
            print "krang_schedulectl $command: waiting for krang_scheduled " .
              "to stop";
        } else {
            die "krang_schedulectl $command: krang_scheduled could not be " .
              "stopped\n";
        }

        # wait for stop - check pid file for removal
        my $stopped = 0;
        for my $wait (0 .. MAX_RESTART_WAIT) {
            if (not -e $pid_file) {
                $stopped = 1;
                last;
            }
            print ".";
            sleep 1;
        }

        if ($stopped) {
            print "\nkrang_schedulectl $command: krang_scheduled stopped\n";
        } else {
            die "\nkrang_schedulectl $command: krang_scheduled not stopped " .
              "in time\n";
        }

    }

    # start
    print "krang_schedulectl $command: starting krang_scheduled\n";
    unless (system($scheduled)) {
        print "krang_schedulectl $command: krang_scheduled started\n";
        exit;
    } else {
        die "krang_schedulectl $command: krang_scheduled could not be " .
          "started\n";
    }
}

usage();

sub usage {
  print <<END;
usage: krang_schedulectl (start|stop|restart|debug)

  start      - start the schedule daemon
  stop       - stop the schedule daemon
  restart    - restart the schedule daemon if running

END

  exit;
}
