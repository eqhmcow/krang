#!/usr/bin/perl 
use warnings;
use strict;

=pod

=head1 NAME

krang_bric_eloader - Bricolage to Krang element transcriber

=head1 SYNOPSIS

  krang_bric_eloader --set Flex

=head1 DESCRIPTION

This script takes a Bricolage element tree and constructs a matching
Krang element set.  The element set is output as a directory
containing class files in the currently configured ElementDir.

=head1 OPTIONS

=over 4

=item --set set-name

The name of the element set to create.  You will be prompted to remove
an existing site if one exists by that name.

=item --bric-server http://server/

Bricolage server to get elements from, defaults to the
BRICOLAGE_SERVER environment variable or http://localhost/.

=item --bric-username name

Bricolage username, defaults to the BRICOLAGE_USERNAME environment
variable.

=item --bric-password pass

Bricolage password, defaults to the BRICOLAGE_USERNAME environment
variable.

=item --bric-soap /usr/local/bricolage/bin/bric_soap

Path to bric_soap script to use to make SOAP requests.  Defaults to
just 'bric_soap' which requires that bric_soap be in your path.

=item --timeout

Timeout for requests to Bric SOAP interface in seconds.  Defaults to
600, or 10 minutes.

=item --verbose

Find out what you want to know.  Set up to three times to get more.

=item --xml file

Load this XML file instead of requesting an element tree from the
Bricolage server.  Using this option, no requests are made to
Bricolage.

=back

=head1 TODO

=over

=item 

Add code to collapse related media and related story elements that
don't have any children into inline link elements instead of
containers with one child.

=back

=cut

use File::Spec::Functions qw(catdir catfile splitdir rel2abs);
use FindBin qw($RealBin);
use Config;

BEGIN {
    # Find a KRANG_ROOT based on path to bin
    my @dir = splitdir($RealBin);
    $ENV{KRANG_ROOT} ||= catdir(@dir[0 .. $#dir - 1]);

    # use $KRANG_ROOT/lib for modules
    my $lib    = catdir($ENV{KRANG_ROOT}, "lib");
    $ENV{PERL5LIB} = $ENV{PERL5LIB} ? "$ENV{PERL5LIB}:${lib}" : 
      "${lib}";
    unshift @INC, $lib, "$lib/".$Config{archname};

    # load Krang::Conf (don't need to load Krang here because we won't
    # be slinging elements)
    eval { require Krang::Conf };
    warn << "END" and exit(1) if $@;
######################################################################

Cannot load Krang.

Error message:

$@

######################################################################
END
}

use Krang::Conf qw(KrangRoot);
use Getopt::Long;
use Pod::Usage;
use Text::Wrap;
use IPC::Run qw(run);
use XML::Simple qw(XMLin);
        
my ($help, $man);
our $bric_username  = $ENV{BRICOLAGE_USERNAME};
our $bric_password  = $ENV{BRICOLAGE_PASSWORD};
our $bric_server    = $ENV{BRICOLAGE_SERVER} || 'http://localhost';
our $bric_soap      = 'bric_soap';
our $set;
our $timeout = 600;
our $verbose = 0;
our $xml_file;
pod2usage(2) unless
  GetOptions(help              => \$help,
             man               => \$man,
             "bric-username=s" => \$bric_username,
             "bric-password=s" => \$bric_password,
             "bric-server=s"   => \$bric_server,
             "bric-soap=s"     => \$bric_soap,
             "set=s"           => \$set,
             "timeout=s"       => \$timeout,
             "verbose+"        => \$verbose,
             "xml=s"           => \$xml_file,
            );
pod2usage(1)             if $help;
pod2usage(-verbose => 2) if $man;

# verify required args
unless (defined $set) {
    print "Missing --set option.\n";
    pod2usage(1);
}
unless (defined $bric_username) {
    print "Missing --bric-username option, and no BRICOLAGE_USERNAME environment variable set.\n";
    pod2usage(1);
}
unless (defined $bric_password) {
    print "Missing --bric-password option, and no BRICOLAGE_PASSWORD environment variable set.\n";
    pod2usage(1);
}

# make sure this set doesn't already exist
our $set_dir = catdir(KrangRoot, 'element_lib', $set);
if (-d $set_dir) {
    die"Element set '$set' already exists at '$set_dir'.\n".
        "Choose a new name or remove this set.\n";
}
mkdir($set_dir) or die $!;


# get it on
create_set();

# it's all over now, baby blue
exit(0);


# create an element set from a Bricolage element tree
sub create_set {
    my $elements = parse_elements();

    foreach my $name (keys %$elements) {
        create_class($name, $elements->{$name});
    }

    # create set.conf
    create_conf($elements);
}

# create a class module for a Bricolage container class
sub create_class {
    my ($ename, $data) = @_;
    
    # skip media classes, which aren't used in Krang
    return if $data->{type} eq 'Media';

    # process name for use as an identifier
    $ename = process_name($ename);    

    # compute module name
    my $module = "${set}::${ename}";

    print STDERR "Creating $module...\n" if $verbose;

    # collect list of subelement declarations in @sub
    my @sub;

    # related media or related stories need an extra field in Krang
    if ($data->{type} eq 'Related Media') {
        push(@sub, "    Krang::ElementClass::MediaLink->new(name => 'media', min => 1, max => 1, allow_delete => 0, reorderable => 0)");
    } elsif ($data->{type} eq 'Related Stories') {
        push(@sub, "    Krang::ElementClass::StoryLink->new(name => 'story',  min => 1, max => 1, allow_delete => 0, reorderable => 0)");
    }

    # process fields
    foreach my $f (@{$data->{fields}}) {
        my $name = process_name($f->{name});

        die "No type defined for $f->{name} of $ename!"
          unless defined $f->{type};

        # setup parameters common to all classes
        my $common  = "        name         => '$name',\n";
        $common .= "        display_name => '$f->{label}',\n"
          unless $f->{label} eq display_name($name);
        $common .= "        min          => 1,\n"
          if $f->{required};
        $common .= "        max          => 1,\n"
          unless $f->{repeatable};
        $common .= "        allow_delete => 0,\n"
          if $f->{required};
        $common .= "        default      => '$f->{default}',\n"
          if defined $f->{default};

        my $sub;
        if ($f->{type} eq 'textarea') {            
            $sub = "    Krang::ElementClass::Textarea->new(\n" . $common;
            $sub .=    "        rows         => $f->{rows},\n"
              if $f->{rows};
            $sub .=    "        cols         => $f->{cols},\n"
              if $f->{cols};
            $sub .= "    )";
        } elsif ($f->{type} eq 'text') {
            $sub = "    Krang::ElementClass::Text->new(\n" . $common;
            $sub .=    "        size         => $f->{size},\n"
              if $f->{size};
            $sub .=    "        maxlength    => $f->{max_size},\n"
              if $f->{max_size};
            $sub .= "    )";

        } elsif ($f->{type} eq 'radio' or $f->{type} eq 'select') {
            # break down options in to @values and %label
            my (@values, %labels);
            foreach my $row (split(/\n/, $f->{options})) {
                next unless $row;
                my ($value, $label) = split(/,/, $row);
                push(@values, $value);
                $labels{$value} = $label;
            }
            my $values = join(",", map { "'$_'" } @values);
            my $labels = join(",", map { "'$_' => '$labels{$_}'" } 
                              keys %labels);

            $sub = "    Krang::ElementClass::" . 
              (($f->{type} eq 'select') ? "PopupMenu" : "RadioGroup") . 
              "->new(\n" . $common .
              "        values      => [$values],\n" .
              "        labels      => {$labels},\n    )";

        } elsif ($f->{type} eq 'checkbox') {
            $sub = "    Krang::ElementClass::CheckBox->new(\n" . $common .
              "    )";
        } elsif ($f->{type} eq 'date') {
            $sub = "    Krang::ElementClass::Date->new(\n" . $common .
              "    )";                            
        } else { 
            die "Unknown field type '$f->{type}' named '$f->{name}' encountered while parsing '$ename'.\n";
        }

        push(@sub, $sub);
    }

    # add references to Bricolage sub-elements
    if ($data->{subelements}) {
        foreach my $sub_name (@{$data->{subelements}}) {
            push(@sub, "    '" . process_name($sub_name) . "'");
        }
    }


    # build list of subelements
    my $sub_elements = join(",\n\n", @sub);    

    my $base;
    if ($data->{type} eq 'Covers') {
        # base class for covers is Krang::ElementClass::Cover
        $base = 'Krang::ElementClass::Cover';
    } elsif ($data->{top_level}) {
        # others top-levels must be subclasses of TopLevel
        $base = 'Krang::ElementClass::TopLevel';
    } else {
        $base = 'Krang::ElementClass';
    }

    # open module for output
    open(MOD, ">", catfile($set_dir, "$ename.pm")) 
      or die "Unable to open $ename.pm for output: $!";
    
    # print module
    print MOD <<END;
package $module;
use strict;
use warnings;
use base '$base';

sub new {
    my \$pkg  = shift;
    my \%args = ( name      => '$ename',
END

print MOD <<END;
                 children  => [
$sub_elements
                ],
                \@_);
    return \$pkg->SUPER::new(\%args);
}

1;
END

   close MOD;
}

# create set.conf for the element set
sub create_conf {
    my $elements = shift;

    print STDERR "Creating set.conf...\n" if $verbose;
    
    # get list of top-level elements
    my @top_levels = grep { $elements->{$_}->{type} ne 'Media' and 
                            $elements->{$_}->{top_level} } keys %$elements;

    open(CONF, ">", catfile($set_dir, "set.conf"))
      or die "Unable to open set.conf: $!\n";

    print CONF "Version 1.0\n";
    print CONF "TopLevels ", 
      join(' ', map { process_name($_) } @top_levels), 
        "\n";

    close CONF;
}

# process name for use as an identifier
sub process_name {
    my $name = shift;
    $name = lc($name);
    $name =~ s/\s+/_/g;
    $name =~ s/-/_/g;
    $name =~ s/[^\w]/_/g;
    $name =~ s/_+/_/g;
    return $name;
}

# standard display_name processing
sub display_name {
    return join " ",
      map { ucfirst($_) } 
        split /_/, shift;
}

# parse the asset document and extract all useful data about elements.
# Returns a hash keyed by element name.
sub parse_elements {
    my $xml = get_xml();

    my $doc = XMLin($xml, 
                    keyattr    => [],
                    forcearray => ['subelement', 'field'],
                   );

    my %elements;
    foreach my $e (@{$doc->{element}}) {
        # extract meta-data
        $elements{$e->{name}} = {
                                 top_level => $e->{top_level},
                                 type      => $e->{type},
                                };

        # extract sub-elements
        $elements{$e->{name}}{subelements} = $e->{subelements}{subelement};

        # extract field data
        if ($e->{fields} and $e->{fields}{field}) {
            foreach my $field (@{$e->{fields}{field}}) {
                push(@{$elements{$e->{name}}{fields}}, 
                     {
                      name       => $field->{name},
                      label      => $field->{label},
                      max_size   => $field->{max_size},
                      size       => $field->{size},
                      repeatable => $field->{repeatable},
                      required   => $field->{required},
                      type       => $field->{type},
                      rows       => $field->{rows},
                      cols       => $field->{cols},
                      options    => $field->{options},
                      default    => $field->{default},
                     });
            }
        }
    }

    return \%elements;
}                      


# call bric_soap and get an asset document containing all Bricolage
# elements
sub get_xml {
    if ($xml_file) {
        open(XML, $xml_file) or die "Unable to open $xml_file: $!";
        my $xml = join('', <XML>);
        close XML;
        return $xml;
    } else {
        # get an XML doc containing all elements
        my $ids = bric_soap('element', 'list_ids');
        my @ids = split(/\n/, $ids);
        return bric_soap('element', 'export', @ids);
    }
}
    
# call bric_soap with the specified args, returns a single scalar
# containing the result
sub bric_soap {
    my ($module, $command, @args) = @_;

    my @command = ($bric_soap,
                   "--username" => $bric_username,
                   "--password" => $bric_password,
                   "--server"   => $bric_server,
                   "--timeout"  => $timeout,
                   (("--verbose") x $verbose),
                   $module, 
                   $command, 
                   @args,
                  );

    my $result;
    my $in;
    run(\@command, \$in, \$result, \*STDERR)
      or die "Error running bric_soap command: '" .
        join(' ', @command) . "'\n";
    
    return $result;
}
