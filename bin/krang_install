#!/usr/bin/perl -w
use warnings;
use strict;


# Path to pre-req binaries
use constant MYSQL_BIN      => '/usr/bin/mysql';
use constant MYSQLADMIN_BIN => '/usr/bin/mysqladmin';
use constant PERL_BIN       => '/usr/bin/perl';
use constant GROUPADD_BIN   => '/usr/sbin/groupadd';
use constant USERADD_BIN    => '/usr/sbin/useradd';
use constant USERMOD_BIN    => '/usr/sbin/usermod';
use constant COPY_BIN       => '/bin/cp';
use constant CHOWN_BIN      => '/bin/chown';
use constant CHMOD_BIN      => '/bin/chmod';
use constant XARGS_BIN      => '/usr/bin/xargs';
use constant FIND_BIN       => '/usr/bin/find';
use constant SH_BIN         => '/bin/sh';
use constant MAKE_BIN       => '/usr/bin/make';
use constant RM_BIN         => '/bin/rm';
use constant ECHO_BIN       => '/bin/echo';
use constant TAR_BIN        => '/bin/tar';
use constant RPM_BIN        => '/bin/rpm';
use constant IFCONFIG_BIN   => '/sbin/ifconfig';
use constant CAT_BIN        => '/bin/cat';
use constant CHKCONFIG_BIN  => '/sbin/chkconfig';
use constant LN_BIN         => '/bin/ln';

=head1 NAME

krang_install - install Krang from a dist file


=head1 SYNOPSIS

  $ krang_install


=head1 DESCRIPTION

This script will install Krang on a RedHat 7.3 (i686-linux) 
system from a dist file created by krang_makedist.



=head2 What C<krang_makedist> does

Following is a list of the tasks the installer script will perform.


=over 4

=item Check pre-requisites


=over 4

=item Must be running as root.

=item IP address must be configured on host.

=item InstanceElementSet must exist

=item Check for proper version of MySQL.


=over 4

=item Suggest "--do-mysql-install" flag if not installed.

=back

=item MySQLRootPassword must be valid for this box


=item Check for proper version of Perl.


=over 4

=item Suggest "--do-perl-install" flag if not installed.

=back


=item InstallPath must NOT exist.

=item Start-up (init.d) script must NOT exist.

=back



=item Create MySQL Krang database user (if it does not already exist).

=item Create Krang UNIX user and/or group


=over 4

=item Create with no password (unless user already exists).

=item Use C<useradd>, C<groupadd>, and C<usermod> to manage user account.

=back



=item Install Krang

=item Configure Krang and first instance.

=item Add Krang to init.d startup scripts.

=item Start Krang

=item Make test

=item Output settings and URL of Krang installation to console.



=back




=head1 OPTIONS

  --help                 - Show usage
  --man                  - Show full man page

=head2 Required parameters

  --HostName             - Host name used for CMS
  --IPAddress            - IP address used for HTTP and FTP
  --InstanceVirtualHost  - Host name of CMS instance virtual server
  --AdminPassword        - For CMS "admin" user
  --InstanceDBName       - Name of MySQL database
  --InstanceDBUser       - MySQL user used by CMS instance
  --InstanceDBPass       - MySQL user password used by CMS instance
  --InstanceElementSet   - Name of element set used by CMS instance


=head2 Optional parameters

  --MySQLRootPassword    - Password for the MySQL user "root"
  --InstallPath          - Directory for Krang install
  --KrangUser            - UNIX user for process ownership
  --KrangGroup           - UNIX group for process ownership
  --FTPPort              - Port on which FTP server should run
  --ApachePort           - Port on which CMS HTTP server should run
  --SMTPServer           - Address of SMTP mail server 
  --InstanceDisplayName  - Name of the Instance for UI display


=head1 SEE ALSO

Refer to F<docs/ops_install.pod>.

=cut



use File::Spec::Functions qw(catdir catfile splitdir rel2abs);
use FindBin qw($RealBin);
use Config;


# Set up KRANG_ROOT and PERL5LIB
BEGIN {
    # Find a KRANG_ROOT based on path to bin
    my @dir = splitdir($RealBin);
    $ENV{KRANG_ROOT} ||= catdir(@dir[0 .. $#dir - 1]);

    # use $KRANG_ROOT/lib for modules
    my $lib    = catdir($ENV{KRANG_ROOT}, "lib");
    $ENV{PERL5LIB} = $ENV{PERL5LIB} ? "$ENV{PERL5LIB}:${lib}" :
      "${lib}";
    unshift @INC, $lib, "$lib/".$Config{archname};

    # load Krang::Conf (don't need to load Krang here because we won't
    # be slinging elements)
}

use Krang;
use Getopt::Long;
use Pod::Usage;
use HTML::Template;


my @original_args = ();
my $uniqueness = time();
my ($help, $man, $do_mysql_install, $do_perl_install);
my @req_params = qw( HostName
                     IPAddress
                     InstanceVirtualHost 
                     AdminPassword 
                     InstanceDBName 
                     InstanceDBUser 
                     InstanceDBPass 
                     InstanceElementSet );

my @opt_params = qw( MySQLRootPassword 
                     InstallPath 
                     KrangUser 
                     KrangGroup 
                     FTPPort 
                     ApachePort 
                     SMTPServer 
                     InstanceDisplayName );

my %options = ( map { $_ => "" } @req_params, @opt_params);

do_install();
exit(0);


################################
####  MAKE INSTALL METHODS  ####
################################

sub do_install {
    setup_getopts();

    # Do installation
    check_prereqs();
    do_perl_install() if ($do_perl_install);
    do_mysql_install() if ($do_mysql_install);
    create_mysql_user();
    create_unix_user_group();
    install_krang();
    configure_krang();
    add_krang_init();
    start_krang();
    make_test();
    output_report();
}


sub check_prereqs {
    print "Checking prerequisites\n";

    # Must be running as root.
    exit_error("Must be run as root.") unless ($> eq "0");

    # IP address must be configured on host.
    my $ifconfig_bin = IFCONFIG_BIN;
    my $ifconfig = `$ifconfig_bin`;
    my @ip_addrs = ();
    foreach my $if_line (split(/\n/, $ifconfig)) {
        next unless ($if_line =~ /inet\ addr\:(\d+\.\d+\.\d+\.\d+)/);
        my $ip = $1;
        push(@ip_addrs, $ip);
    }
    my $IPAddress = $options{'IPAddress'};
    unless (grep {$_ eq $IPAddress} @ip_addrs) {
        exit_error("IPAddress '$IPAddress' not bound to machine");
    }

    # InstanceElementSet must exist
    my $InstanceElementSet = $options{'InstanceElementSet'};
    unless (-d $ENV{KRANG_ROOT}."/element_lib/".$InstanceElementSet) {
        exit_error("InstanceElementSet '$InstanceElementSet' does not exist");
    }

    my $perl_version = $Config{version};
    my $archname = $Config{archname};
    if ($do_perl_install) {
        if (($perl_version eq '5.6.1') and ($archname eq 'i686-linux')) {
            exit_error("Correct perl already installed!  Try again without --do-perl-install");
        }
    } else {
        unless (($perl_version eq '5.6.1') and ($archname eq 'i686-linux')) {
            exit_error("Wrong Perl version ($perl_version/$archname).  Try again with --do-perl-install");
        }
    }

    # InstallPath must NOT exist.
    my $InstallPath = $options{InstallPath};
    if (-e $InstallPath) {
        exit_error("InstallPath '$InstallPath' already exists.  Cannot continue.");
    }

    # Start-up (init.d) script must NOT exist.
    my $init_script = "/etc/init.d/krang-". $options{HostName} .".init";
    if (-l $init_script) {
        exit_error("Init script '$init_script' already exists.  Cannot continue.");
    }

    if ($do_mysql_install) {
        # Bail if version 4 is already installed
        my $mysql_bin = MYSQL_BIN;
        if (-f $mysql_bin) {
            my $mysql_version = `$mysql_bin -V`;
            if ($mysql_version =~ /Distrib\ 4\./) {
                exit_error("MySQL version 4.* already installed!  Try again without --do-mysql-install");
            }
        }
    } else {
        # Check for proper version of MySQL.
        #     Suggest ""--do-mysql-install"" flag if not
        #     installed.
        my $mysql_bin = MYSQL_BIN;
        unless (-f $mysql_bin) {
            exit_error("MySQL not installed.  Try again with --do-mysql-install");
        }

        my $mysql_version = `$mysql_bin -V`;
        unless ((-f $mysql_bin) and ($mysql_version =~ /Distrib\ 4\./)) {
            exit_error("MySQL version 4.* not installed.  Try again with --do-mysql-install");
        }

        # MySQLRootPassword must be valid, and MySQL should be running
        my $MySQLRootPassword = $options{'MySQLRootPassword'};
        my $test_mysql = ECHO_BIN ." 'select \"world\" as hello' | $mysql_bin -uroot";
        $test_mysql .= " -p$MySQLRootPassword" if (length($MySQLRootPassword));
        $test_mysql .= " 2>&1";
        my $mysql_test_output = `$test_mysql`;

        unless (($mysql_test_output =~ /hello/) and ($mysql_test_output =~ /world/)) {
            print STDERR "$mysql_test_output";
            if ($mysql_test_output =~ /ERROR 1045: Access denied/) {
                exit_error("MySQLRootPassword '$MySQLRootPassword' is not valid");
            } elsif ($mysql_test_output =~ /ERROR 2002: Can\'t connect/) {
                exit_error("Can't connect to MySQL.  Start MySQL and try again.");
            } else {
                exit_error("Unable to verify MySQLRootPassword.");
            }
        }

        # InstanceDBName should NOT exist in MySQL
        my $InstanceDBName = $options{InstanceDBName};
        my $db_exists_test = ECHO_BIN ." 'select 1' | $mysql_bin -uroot";
        $db_exists_test .= " -p$MySQLRootPassword" if (length($MySQLRootPassword));
        $db_exists_test .= " $InstanceDBName 2>&1";
        my $db_exists_test_output = `$db_exists_test`;

        unless ($db_exists_test_output =~ /ERROR 1049: Unknown database/) {
            exit_error("Database '$InstanceDBName' already exists.  Cannot continue.");
        }
    }
}


# Compile and install Perl, then re-exec w/o "--do-perl-install" flag
sub do_perl_install {
    my $uniqueness = time();
    my $build_dir = "/tmp/krang_perl_". $uniqueness;
    mkdir($build_dir) || die ($!);
    chdir($build_dir);

    print "Un-tarring Perl source\n";
    my $perl_untar = TAR_BIN ." -xzf ". $ENV{KRANG_ROOT} ."/install/Perl/perl-5.6.1.tar.gz";
    system($perl_untar) && die("Error un-tarring Perl source: $!");

    print "Building Perl from source\n";
    chdir("perl-5.6.1");
    my $rm_bin = RM_BIN;
    my $make_bin = MAKE_BIN;
    my $sh_bin = SH_BIN;
    my $perl_build = qq( $rm_bin -f config.sh Policy.sh \\
                         && $sh_bin Configure -Dbin=/usr/bin -Dprefix=/usr/local -des \\
                         && $make_bin \\
                         && $make_bin test \\
                         && $make_bin install );

    # Check for compile error
    system($perl_build) && die("There was a problem building Perl: $!");
 
    # Blow away build directory
    chdir($ENV{KRANG_ROOT});
    system(RM_BIN ." -rf $build_dir") && die("Error deleting build directory: $!");

    # Re-exec process w/o --do-perl-install and exit
    print "Perl install complete.  Re-running krang_install without --do-perl-install\n";
    my $install = $0 ." ". join(" ", (grep { $_ ne "--do-perl-install" } @original_args));
    print "$install\n";
    exec($install) || die($!);
}


sub do_mysql_install {
    # -Uvh from *.rpm files
    my $mysql_rpm_path = $ENV{KRANG_ROOT} ."/install/MySQL/";
    chdir($mysql_rpm_path);

    # Start MySQL
    print "Installing/upgrading MySQL 4\n";
    my $rpm_upgrade = RPM_BIN ." -Uvh *.rpm";
    if (system($rpm_upgrade)) {
        exit_error("There was a problem installing MySQL.  Unable to continue.");
    }

    # MySQLRootPassword must be valid, and MySQL should be running
    my $mysql_bin = MYSQL_BIN;
    my $MySQLRootPassword = $options{'MySQLRootPassword'};
    my $test_mysql = ECHO_BIN ." 'select \"world\" as hello' | $mysql_bin -uroot";
    $test_mysql .= " -p$MySQLRootPassword" if (length($MySQLRootPassword));
    $test_mysql .= " 2>&1";
    my $mysql_test_output = `$test_mysql`;

    unless (($mysql_test_output =~ /hello/) and ($mysql_test_output =~ /world/)) {
        print STDERR "$mysql_test_output";
        if ($mysql_test_output =~ /ERROR 1045: Access denied/) {
            exit_error("MySQLRootPassword '$MySQLRootPassword' is not valid");
        } elsif ($mysql_test_output =~ /ERROR 2002: Can\'t connect/) {
            exit_error("Can't connect to MySQL.  Start MySQL and try again.");
        } else {
            exit_error("Unable to verify MySQLRootPassword.");
        }
    }

    # Set MySQL to start on boot
    print "Set MySQL to start on boot\n";
    my $chkconfig = CHKCONFIG_BIN ." mysql on";
    system($chkconfig) && die ("Can't set MySQL to start on boot: $!");

    # All done
    print "MySQL installed.\n";
}


# Create mysql instance user, if necessary
sub create_mysql_user {
    # MySQLRootPassword must be valid, and MySQL should be running
    my $mysql_bin = MYSQL_BIN;
    my $MySQLRootPassword = $options{'MySQLRootPassword'};
    my $InstanceDBName = $options{'InstanceDBName'};
    my $InstanceDBUser = $options{'InstanceDBUser'};
    my $InstanceDBPass = $options{'InstanceDBPass'};

    my $grant = "grant all on $InstanceDBName\.* to $InstanceDBUser\@localhost";
    $grant .= " identified by '$InstanceDBPass'" if ($InstanceDBPass);

    my $mysql_grant = ECHO_BIN ." \"$grant\" | $mysql_bin -uroot";
    $mysql_grant .= " -p$MySQLRootPassword" if (length($MySQLRootPassword));

    print "Granting MySQL access to user '$InstanceDBUser' for database '$InstanceDBName'\n";
    system($mysql_grant) && exit_error("Can't grant DB access to $InstanceDBUser for $InstanceDBName.");
    print "  MySQL access granted.\n";
}


sub create_unix_user_group {
    my $KrangUser = $options{'KrangUser'};
    my $KrangGroup = $options{'KrangGroup'};
    my $InstallPath = $options{InstallPath};

    # Create user, if necessary
    print "Creating UNIX user ('$KrangUser')\n";
    my ($uname,$upasswd,$uid,$ugid,$uquota,$ucomment,$ugcos,$udir,$ushell,$uexpire) = getpwnam($KrangUser);
    unless (defined($uid)) {
        my $useradd = USERADD_BIN;
        $useradd .= " -d $InstallPath -M $KrangUser";
        system($useradd) && die("Can't add user: $!");

        # Update user data
        ($uname,$upasswd,$uid,$ugid,$uquota,$ucomment,$ugcos,$udir,$ushell,$uexpire) = getpwnam($KrangUser);
        print "  User created (uid $uid).\n";
    } else {
        print "  User already exists (uid $uid).\n";
    }

    # Create group, if necessary
    print "Creating UNIX group ('$KrangGroup')\n";
    my ($gname,$gpasswd,$gid,$gmembers) = getgrnam($KrangGroup);
    unless (defined($gid)) {
        my $groupadd = GROUPADD_BIN;
        $groupadd .= " $KrangGroup";
        system($groupadd) && die("Can't add group: $!");

        # Update group data for later
        ($gname,$gpasswd,$gid,$gmembers) = getgrnam($KrangGroup);
        print "  Group created (gid $gid).\n";
    } else {
        print "  Group already exists (gid $gid).\n";
    }

    # Add user to group, if user not already a member
    print "Adding user $KrangUser to group $KrangGroup\n";
    my @group_members = ( split(/\s+/, $gmembers) );
    my $user_is_group_member = ( grep { $_ eq $KrangUser } @group_members );
    unless (($ugid eq $gid) or $user_is_group_member) {
        my $usermod = USERMOD_BIN;
        $usermod .= " -G $KrangGroup $KrangUser";
        system($usermod) && die("Can't add user $KrangUser to group $KrangGroup: $!");
        print "  User added to group.\n";
    } else {
        print "  User already in group.\n";
    }
}


sub install_krang {
    my $InstallPath = $options{InstallPath};
    mkdir($InstallPath) || die($!);

    print "Installing Krang files into '$InstallPath'\n";

    chdir($ENV{KRANG_ROOT});
    my $copy = COPY_BIN ." -r * $InstallPath\/";
    system($copy) && die("Can't copy: $!");

    print "  Fixing ownership\n";
    my $KrangUser = $options{KrangUser};
    my $KrangGroup = $options{KrangGroup};
    my $chown = CHOWN_BIN ." -R $KrangUser\.$KrangGroup $InstallPath";
    system($chown) && die("Can't update ownership: $!");

    # For commands
    my $chmod;

    print "  Setting group write permissions\n";
    $chmod = CHMOD_BIN ." -R g+w $InstallPath";
    system($chmod) && die("Can't set group write permissions: $!");

    print "  Fixing directory read permissions\n";
    $chmod = FIND_BIN ." $InstallPath -type d | ". XARGS_BIN ." ". CHMOD_BIN ." +rx";
    system($chmod) && die("Can't fix directory read permissions: $!");

    print "  Fixing file read permissions\n";
    $chmod = FIND_BIN ." $InstallPath -type f | ". XARGS_BIN ." ". CHMOD_BIN ." +r";
    system($chmod) && die("Can't fix file read permissions: $!");

    print "  Setting execute bits on scripts\n";

    # Set all *.pl files
    $chmod = FIND_BIN ." $InstallPath -type f -name '*.pl' | ". XARGS_BIN ." ". CHMOD_BIN ." +x";
    system($chmod) && die("Can't set execite bits: $!");

    # Set all *.cgi files
    $chmod = FIND_BIN ." $InstallPath -type f -name '*.cgi' | ". XARGS_BIN ." ". CHMOD_BIN ." +x";
    system($chmod) && die("Can't set execite bits: $!");

    # Set all files in krang/bin/*
    $chmod = CHMOD_BIN ." +x $InstallPath/bin/*";
    system($chmod) && die("Can't set execite bits: $!");

    print "  Krang files installed.\n";
}


sub configure_krang {
    print "Configuring Krang installation\n";

    my $InstallPath = $options{InstallPath};
    chdir($InstallPath);

    # Make custom krang.conf
    print "Creating krang.conf from specification\n";
    my $t = HTML::Template->new(filename => $ENV{KRANG_ROOT} ."/conf/krang.conf.tmpl");
    foreach my $param (keys(%options)) {
        # Filter out params which are not in HTML::Template file 'krang.conf.tmpl'
        unless ( grep { $param eq $_ } qw/AdminPassword MySQLRootPassword InstallPath/ ) {
            $t->param($param => $options{$param});
        }
    }
    my $output_conf = $InstallPath ."/conf/krang.conf";
    open(OUTPUT, ">$output_conf") || die("Can't open '$output_conf' for writing: $!");
    print OUTPUT $t->output();
    close(OUTPUT);
    print "  Conf written to '$output_conf'.\n";

    # Create DB
    my $MySQLRootPassword = $options{'MySQLRootPassword'};
    my $InstanceDBName = $options{'InstanceDBName'};
    my $createdb = MYSQLADMIN_BIN ." -uroot";
    $createdb .= " -p$MySQLRootPassword" if (length($MySQLRootPassword));
    $createdb .= " create $InstanceDBName";
    print "Creating MySQL database '$InstanceDBName'\n";
    system($createdb) && die("Error creating database $InstanceDBName: $!");

    # Load SQL files
    my $InstanceDBUser = $options{'InstanceDBUser'};
    my $InstanceDBPass = $options{'InstanceDBPass'};
    my $sql_files_path = "$InstallPath\/sql/*.sql";
    print "  Creating schema from SQL files in '$sql_files_path'\n";
    my $loadsql = CAT_BIN ." $sql_files_path | ";
    $loadsql .= MYSQL_BIN ." -u$InstanceDBUser -p$InstanceDBPass $InstanceDBName";
    system($loadsql) && die("Error loading SQL: $!");

    # Customize DB (Admin password)
    my $AdminPassword = $options{AdminPassword};
    print "  Changing 'admin' CMS login password to '$AdminPassword'\n";
    my $update_pw_perl = qq(
                            my (\$user) = Krang::User->find(login=>"admin");
                            \$user->password("$AdminPassword");
                            \$user->save();
                           );
    my $update_admin_pw = "KRANG_ROOT='$InstallPath' PERL5LIB='$InstallPath/lib' ";
    $update_admin_pw .= PERL_BIN ." -MKrang::Script -MKrang::User -e '$update_pw_perl'";
    system($update_admin_pw) && die("Error changing admin password: $!");
}


sub add_krang_init {
    my $init_script = "krang-". $options{HostName} .".init";
    print "Installing Krang init.d script '$init_script'\n";

    chdir("/etc/init.d");
    my $InstallPath =  $options{InstallPath};
    my $link_init = LN_BIN ." -s $InstallPath\/bin/krang_ctl $init_script";
    system($link_init) && die ("Can't link init script: $!");

    print "Setting $init_script to start on boot\n";
    my $chkconfig = CHKCONFIG_BIN ." --add $init_script";
    system($chkconfig) && die("Can't chkconfig --add $init_script: $!");

    $chkconfig = CHKCONFIG_BIN ." $init_script on";
    system($chkconfig) && die("Can't chkconfig $init_script on: $!");
}


sub start_krang {
    my $init_script = "krang-". $options{HostName} .".init";
    print "Starting Krang via init.d script '$init_script'\n";
    my $start = "KRANG_ROOT='' PERL5LIB='' /etc/init.d/$init_script start";
    system($start) && die("Can't start Krang: $!");
}


sub make_test {}


sub output_report {
    # Debug
    use Data::Dumper;
    print Dumper(\%options);
}





###########################
####  PRIVATE METHODS  ####
###########################

sub exit_error {
    my $cmd = $0;
    $cmd =~ s/.*\/(.+)$/$1/;

    my $message = shift;
    print STDERR "\nError: $cmd:  $message\n\n";
    exit(1);
}


sub setup_getopts {
    # Copy the original args for re-invoking later
    @original_args = @ARGV;

    pod2usage(2) unless
        GetOptions( 'help'      => \$help,
                    'man'       => \$man,
                    'do-mysql-install' => \$do_mysql_install,
                    'do-perl-install' => \$do_perl_install,
                    (map { $_."=s" => \$options{$_} } @req_params, @opt_params) );

    pod2usage(1)             if $help;
    pod2usage(-verbose => 2) if $man;

    # Enforce required params
    my $error_output = "";
    foreach my $p (@req_params) {
        next if (length($options{$p}));
        $error_output .= "Missing --". $p ."\n";
    }
    if ($error_output) {
        print "Error:\n\n$error_output\n";
        pod2usage(1);
    }

    # Set opt defaults
    set_param_defaults();
}


sub set_param_defaults {
    my %defaults = (
                    MySQLRootPassword => '',
                    InstallPath => '/usr/local/krang',
                    KrangUser => 'krang',
                    KrangGroup => 'krang',
                    FTPPort => '21',
                    ApachePort => '80',
                    SMTPServer => '127.0.0.1',
                    );

    # Set up defaults if value is not otherwise set
    while (my ($k, $dv) = each(%defaults)) {
        # Skip if value already defined
        next if (length($options{$k}));

        # Set default
        $options{$k} = $dv;
    }

    # Default instancedisplayname => $instancevirtualhost
    my $idn = "InstanceDisplayName";
    unless (length($options{$idn})) {
        $options{$idn} = $options{'InstanceVirtualHost'};
    }
}
