#!/usr/bin/perl -w
use warnings;
use strict;
use IO::Socket;

# Path to pre-req binaries
use constant MYSQL_BIN      => '/usr/bin/mysql';
use constant MYSQLADMIN_BIN => '/usr/bin/mysqladmin';
use constant PERL_BIN       => '/usr/bin/perl';
use constant GROUPADD_BIN   => '/usr/sbin/groupadd';
use constant USERADD_BIN    => '/usr/sbin/useradd';
use constant USERMOD_BIN    => '/usr/sbin/usermod';
use constant COPY_BIN       => '/bin/cp';
use constant CHOWN_BIN      => '/bin/chown';
use constant CHMOD_BIN      => '/bin/chmod';
use constant XARGS_BIN      => '/usr/bin/xargs';
use constant FIND_BIN       => '/usr/bin/find';
use constant SH_BIN         => '/bin/sh';
use constant MAKE_BIN       => '/usr/bin/make';
use constant RM_BIN         => '/bin/rm';
use constant ECHO_BIN       => '/bin/echo';
use constant TAR_BIN        => '/bin/tar';
use constant RPM_BIN        => '/bin/rpm';
use constant IFCONFIG_BIN   => '/sbin/ifconfig';
use constant CAT_BIN        => '/bin/cat';
use constant CHKCONFIG_BIN  => '/sbin/chkconfig';
use constant LN_BIN         => '/bin/ln';

$|++;

=head1 NAME

krang_install - install Krang from a dist file


=head1 SYNOPSIS

  $ krang_install


=head1 DESCRIPTION

This script will install Krang on a RedHat 7.3 or Redhat 9
(i686-linux) system from a dist file created by krang_makedist.

It can also install Krang from a backup file created by krang_backup.
For more on this topic, see C<docs/ops_backup.pod>.


=head2 What C<krang_install> does

Following is a list of the tasks the installer script will perform.


=over 4

=item Check pre-requisites


=over 4

=item Must be running as root.

=item IP address must be configured on host.

=item InstanceElementSet must exist

=item Check for proper version of MySQL.


=over 4

=item Suggest "--do-mysql-install" flag if not installed.

=back

=item MySQLRootPassword must be valid for this box


=item Check for proper version of Perl.


=over 4

=item Suggest "--do-perl-install" flag if not installed.

=back


=item InstallPath must NOT exist.

=item Start-up (init.d) script must NOT exist.

=back



=item Create Krang UNIX user and/or group


=over 4

=item Create with no password (unless user already exists).

=item Use C<useradd>, C<groupadd>, and C<usermod> to manage user account.

=back



=item Install Krang

=item Configure Krang and first instance.

=item Add Krang to init.d startup scripts.

=item Start Krang

=item Make test

=item Output settings and URL of Krang installation to console.



=back




=head1 OPTIONS

  --help                 - Show usage
  --man                  - Show full man page

=head2 Required parameters

  --HostName             - Host name used for CMS
  --IPAddress            - IP address used for HTTP and FTP
  --AdminPassword        - For CMS "admin" user
  --DBUser               - MySQL user used by CMS
  --DBPass               - MySQL user password used by CMS
  --InstanceHostName     - Host name of CMS instance virtual server
  --InstanceDBName       - Name of MySQL database
  --InstanceElementSet   - Name of element set used by CMS instance

=head2 Optional parameters

  --FTPHostName          - Host name for FTP server, defaults to HostName.
  --MySQLRootPassword    - Password for the MySQL user "root"
  --InstallPath          - Directory for Krang install
  --KrangUser            - UNIX user for process ownership
  --KrangGroup           - UNIX group for process ownership
  --FTPPort              - Port on which FTP server should run, defaults 
                            to 21 if available, else 2121
  --ApachePort           - Port on which CMS HTTP server should run
  --SMTPServer           - Address of SMTP mail server 
  --InstanceDisplayName  - Name of the Instance for UI display
  --FromBackup           - the name of a backup file to use as source for 
                           the install.

=head2 Installation flags

  --do-perl-install      - Install Perl 5.6.1, i686-linux (if not already installed)
  --do-mysql-install     - Install MySQL 4 (if not already installed)
  --run-tests            - run Krang "make test" (default is to not run them)


=head1 SEE ALSO

Refer to F<docs/ops_install.pod>.

=cut



use File::Spec::Functions qw(catdir catfile splitdir rel2abs);
use FindBin qw($RealBin);
use Config;


# Set up KRANG_ROOT and PERL5LIB
BEGIN {
    # Find a KRANG_ROOT based on path to bin
    my @dir = splitdir($RealBin);
    $ENV{KRANG_ROOT} ||= catdir(@dir[0 .. $#dir - 1]);

    # use $KRANG_ROOT/lib for modules
    my $lib    = catdir($ENV{KRANG_ROOT}, "lib");
    $ENV{PERL5LIB} = $ENV{PERL5LIB} ? "$ENV{PERL5LIB}:${lib}" :
      "${lib}";
    unshift @INC, $lib, "$lib/".$Config{archname};
}

use Krang;
use Getopt::Long;
use Pod::Usage;
use HTML::Template;
use Term::Prompt qw(prompt);
use File::Temp qw(tempdir);
use Config::ApacheFormat;

my @original_args = ();
my $uniqueness = time();
my ($help, $man, $do_mysql_install, $do_perl_install, $run_tests);
my @req_params = qw( HostName
                     IPAddress
                     InstanceHostName
                     AdminPassword 
                     InstanceDBName 
                     DBUser 
                     DBPass
                     InstanceElementSet );

my @opt_params = qw( FromBackup
                     MySQLRootPassword 
                     InstallPath 
                     KrangUser 
                     KrangGroup 
                     FTPPort 
                     ApachePort 
                     SMTPServer 
                     FTPHostName
                     InstanceDisplayName );

my %options = ( map { $_ => undef } @req_params, @opt_params);

do_install();
exit(0);


################################
####  MAKE INSTALL METHODS  ####
################################

sub do_install {
    setup_getopts();

    # unpack backup, which contributes to options
    unpack_backup() if $options{FromBackup};

    # enforce requirements
    enforce_requirements();
    
    # Do installation
    check_prereqs();
    do_perl_install() if ($do_perl_install);
    do_mysql_install() if ($do_mysql_install);

    # working here - must create all users spec'd in backup conf
    create_mysql_user();
    create_unix_user_group();
    install_krang();
    configure_krang();
    add_krang_init();
    start_krang();
    make_test() if ($run_tests);
    output_report();
}

# open up the backup file, if one is specified, and load unspecified
# values from the config
sub unpack_backup {
    our $BACKUP_DIR;
    our $BACKUP_CONF;
    our @BACKUP_INSTANCES;

    # open up the backup
    my $kba = $options{'FromBackup'};
    exit_error("FromBackup file '$kba' should end in .kba or .kba.gz")
      unless $kba =~ /\.kba\.gz$/ or $kba =~ /\.kba$/;
    exit_error("FromBackup file '$kba' does not exist.")
      unless -e $kba;
    $kba = rel2abs($kba);

    # make temp directory for backup files
    $BACKUP_DIR = tempdir(CLEANUP => 1,
                          DIR     => catdir($ENV{KRANG_ROOT}, 'tmp'));

    print "Unpacking backup file '$kba'.\n";
    my $cmd = TAR_BIN . " -x" . ($kba =~ /gz$/ ? 'z' : '') . "f $kba -C $BACKUP_DIR";
    system($cmd) && die("Error un-tarring file '$kba' to '$BACKUP_DIR'.\n");
    exit_error("FromBackup file '$kba' is not a valid Krang backup - missing conf/krang.conf.")
      unless -e catfile($BACKUP_DIR, 'conf', 'krang.conf');

    # make sure the versions match
    my $this_version = _get_version("$ENV{KRANG_ROOT}/lib/Krang.pm");
    my $backup_version = _get_version("$BACKUP_DIR/lib/Krang.pm");
    exit_error("Backup file '$kba' was made with version '$backup_version' of Krang!  This is version '$this_version'.")
      unless $this_version == $backup_version;
    
    # load configuration file from backup to get defaults
    print "Loading backup configuration.\n";
    $BACKUP_CONF = Config::ApacheFormat->new();
    $BACKUP_CONF->read(catfile($BACKUP_DIR, 'conf', 'krang.conf'));    
    
    # use the values from the first instance
    my @blocks = $BACKUP_CONF->get('Instance');
    my $conf = $BACKUP_CONF->block($blocks[0]);

    # load option defaults from conf    
    $options{HostName}           ||= $conf->get('HostName');
    $options{IPAddress}          ||= $conf->get('ApacheAddr');
    $options{AdminPassword}      ||= '*** RESTORED FROM BACKUP ***';
    $options{DBUser}             ||= $conf->get('DBUser');
    $options{DBPass}             ||= $conf->get('DBPass');
    $options{InstanceElementSet} ||= $conf->get('InstanceElementSet');
    $options{InstanceDBName}     ||= $conf->get('InstanceDBName');
    $options{InstanceHostName}   ||= $conf->get('InstanceHostName');
    $options{KrangUser}          ||= $conf->get('KrangUser');
    $options{KrangGroup}         ||= $conf->get('KrangGroup');
    $options{FTPPort}            ||= $conf->get('FTPPort');
    $options{FTPHostName}        ||= $conf->get('FTPHostName');
    $options{ApachePort}         ||= $conf->get('ApachePort');
    $options{SMTPServer}         ||= $conf->get('SMTPServer');
    $options{InstanceDisplayName}||= $conf->get('InstanceDisplayName');

    # load extra instance data into @BACKUP_INSTANCES
    if (@blocks > 1) {
        foreach my $block_name (@blocks[1..$#blocks]) {
            $conf = $BACKUP_CONF->block($block_name);
            push(@BACKUP_INSTANCES, 
                 { InstanceElementSet => $conf->get('InstanceElementSet'),
                   InstanceDBName     => $conf->get('InstanceDBName'),
                   InstanceHostName   => $conf->get('InstanceHostName'),
                 });
        }
    }

    # set KrangRoot to backup directory so backup will flow from there
    $ENV{KRANG_ROOT} = $BACKUP_DIR;
}

# extract a version number from Krang.pm
sub _get_version {
    `perl -e 'require qq{$_[0]}; print \$Krang::VERSION'`;
}

sub check_prereqs {
    print "Checking prerequisites\n";

    # Must be running as root.
    exit_error("Must be run as root.") unless ($> eq "0");

    # IP address must be configured on host.
    my $ifconfig_bin = IFCONFIG_BIN;
    my $ifconfig = `$ifconfig_bin`;
    my @ip_addrs = ();
    foreach my $if_line (split(/\n/, $ifconfig)) {
        next unless ($if_line =~ /inet\ addr\:(\d+\.\d+\.\d+\.\d+)/);
        my $ip = $1;
        push(@ip_addrs, $ip);
    }
    my $IPAddress = $options{'IPAddress'};
    unless (grep {$_ eq $IPAddress} @ip_addrs) {
        exit_error("IPAddress '$IPAddress' not bound to machine");
    }

    # InstanceElementSet must exist
    my $InstanceElementSet = $options{'InstanceElementSet'};
    unless (-d $ENV{KRANG_ROOT}."/element_lib/".$InstanceElementSet) {
        exit_error("InstanceElementSet '$InstanceElementSet' does not exist");
    }

    my $perl_version = $Config{version};
    my $archname = $Config{archname};
    if ($do_perl_install) {
        if (($perl_version eq '5.6.1') and ($archname eq 'i686-linux')) {
            exit_error("Correct perl already installed!  Try again without --do-perl-install");
        }
    } else {
        unless (($perl_version eq '5.6.1') and ($archname eq 'i686-linux')) {
            exit_error("Incorrect Perl version (Found $perl_version/$archname, expecting 5.6.1/i686-linux).  Try again with --do-perl-install");
        }
    }

    # InstallPath must NOT exist.
    my $InstallPath = $options{InstallPath};
    if (-e $InstallPath) {
        if (-e catfile($InstallPath,'bin','krang_uninstall')) {
             exit_error("Will not proceed due to existing krang install.") unless prompt("y", "InstallPath '$InstallPath' already exists and seems to contain an existing Krang instance.\nThis program must totally and permanently remove this krang installation in order to proceed.\n\nIs this what you really want to do?", "y/n", "n");
             {
                 local $ENV{KRANG_ROOT} = $InstallPath;
                 system(catfile($InstallPath,'bin','krang_uninstall').' --no_prompt --verbose');
             }
         } else { 
             exit_error("InstallPath '$InstallPath' already exists and does not appear to belong to an existing krang instance.  Cannot continue.");
         }
    }

    # Start-up (init.d) script must NOT exist.
    my $init_script = "/etc/init.d/krang-". $options{HostName} .".init";
    if (-l $init_script) {
        exit_error("Init script '$init_script' already exists.  Cannot continue.");
    }

    if ($do_mysql_install) {
        # Bail if version 4 is already installed
        my $mysql_bin = MYSQL_BIN;
        if (-f $mysql_bin) {
            my $mysql_version = `$mysql_bin -V`;
            if ($mysql_version =~ /Distrib\ 4\./) {
                exit_error("MySQL version 4.* already installed!  Try again without --do-mysql-install");
            }
        }
    } else {
        # Check for proper version of MySQL.
        #     Suggest ""--do-mysql-install"" flag if not
        #     installed.
        my $mysql_bin = MYSQL_BIN;
        unless (-f $mysql_bin) {
            exit_error("MySQL not installed.  Try again with --do-mysql-install");
        }

        my $mysql_version = `$mysql_bin -V`;
        unless ((-f $mysql_bin) and ($mysql_version =~ /Distrib\ 4\./)) {
            exit_error("MySQL version 4.* not installed.  Try again with --do-mysql-install");
        }

        # MySQLRootPassword must be valid, and MySQL should be running
        my $MySQLRootPassword = $options{'MySQLRootPassword'};
        my $test_mysql = ECHO_BIN ." 'select \"world\" as hello' | $mysql_bin -uroot";
        $test_mysql .= " -p$MySQLRootPassword" if (length($MySQLRootPassword));
        $test_mysql .= " 2>&1";
        my $mysql_test_output = `$test_mysql`;

        unless (($mysql_test_output =~ /hello/) and ($mysql_test_output =~ /world/)) {
            print STDERR "$mysql_test_output";
            if ($mysql_test_output =~ /ERROR 1045: Access denied/) {
                exit_error("MySQLRootPassword '$MySQLRootPassword' is not valid");
            } elsif ($mysql_test_output =~ /ERROR 2002: Can\'t connect/) {
                exit_error("Can't connect to MySQL.  Start MySQL and try again.");
            } else {
                exit_error("Unable to verify MySQLRootPassword.");
            }
        }

        # InstanceDBName should NOT exist in MySQL
        my $InstanceDBName = $options{InstanceDBName};
        my $db_exists_test = ECHO_BIN ." 'select 1' | $mysql_bin -uroot";
        $db_exists_test .= " -p$MySQLRootPassword" if (length($MySQLRootPassword));
        $db_exists_test .= " $InstanceDBName 2>&1";
        my $db_exists_test_output = `$db_exists_test`;

        unless ($db_exists_test_output =~ /ERROR 1049: Unknown database/) {
            exit_error("Database '$InstanceDBName' already exists.  Cannot continue.");
        }
    }
}


# Compile and install Perl, then re-exec w/o "--do-perl-install" flag
sub do_perl_install {
    my $uniqueness = time();
    my $build_dir = "/tmp/krang_perl_". $uniqueness;
    mkdir($build_dir) || die ($!);
    chdir($build_dir);

    print "Un-tarring Perl source\n";
    my $perl_untar = TAR_BIN ." -xzf ". $ENV{KRANG_ROOT} ."/install/Perl/perl-5.6.1.tar.gz";
    system($perl_untar) && die("Error un-tarring Perl source: $!");

    print "Building Perl from source\n";
    chdir("perl-5.6.1");
    my $rm_bin = RM_BIN;
    my $make_bin = MAKE_BIN;
    my $sh_bin = SH_BIN;
    my $perl_build = qq( $rm_bin -f config.sh Policy.sh \\
                         && $sh_bin Configure -Dbin=/usr/bin -Dprefix=/usr/local -des \\
                         && $make_bin \\
                         && $make_bin install );

    # Check for compile error
    system($perl_build) && die("There was a problem building Perl.  Cannot continue");
 
    # Blow away build directory
    chdir($ENV{KRANG_ROOT});
    system(RM_BIN ." -rf $build_dir") && die("Error deleting build directory: $!");

    # Re-exec process w/o --do-perl-install and exit
    print "Perl install complete.  Re-running krang_install without --do-perl-install\n";
    my $install = $0 ." ". join(" ", (grep { $_ ne "--do-perl-install" } @original_args));
    print "$install\n";
    exec($install) || die($!);
}


sub do_mysql_install {
    # -Uvh from *.rpm files
    my $mysql_rpm_path = $ENV{KRANG_ROOT} ."/install/MySQL/";
    chdir($mysql_rpm_path);

    # Start MySQL
    print "Installing/upgrading MySQL 4\n";
    my $rpm_upgrade = RPM_BIN ." -Uvh *.rpm";
    if (system($rpm_upgrade)) {
        exit_error("There was a problem installing MySQL.  Unable to continue.");
    }

    # MySQLRootPassword must be valid, and MySQL should be running
    my $mysql_bin = MYSQL_BIN;
    my $MySQLRootPassword = $options{'MySQLRootPassword'};
    my $test_mysql = ECHO_BIN ." 'select \"world\" as hello' | $mysql_bin -uroot";
    $test_mysql .= " -p$MySQLRootPassword" if (length($MySQLRootPassword));
    $test_mysql .= " 2>&1";
    my $mysql_test_output = `$test_mysql`;

    unless (($mysql_test_output =~ /hello/) and ($mysql_test_output =~ /world/)) {
        print STDERR "$mysql_test_output";
        if ($mysql_test_output =~ /ERROR 1045: Access denied/) {
            exit_error("MySQLRootPassword '$MySQLRootPassword' is not valid");
        } elsif ($mysql_test_output =~ /ERROR 2002: Can\'t connect/) {
            exit_error("Can't connect to MySQL.  Start MySQL and try again.");
        } else {
            exit_error("Unable to verify MySQLRootPassword.");
        }
    }

    # Set MySQL to start on boot
    print "Set MySQL to start on boot\n";
    my $chkconfig = CHKCONFIG_BIN ." mysql on";
    system($chkconfig) && die ("Can't set MySQL to start on boot: $!");

    # All done
    print "MySQL installed.\n";
}


sub create_mysql_user {
    # MySQLRootPassword must be valid, and MySQL should be running
    my $mysql_bin = MYSQL_BIN;
    my $MySQLRootPassword = $options{'MySQLRootPassword'};
    my $InstanceDBName = $options{'InstanceDBName'};
    my $DBUser = $options{'DBUser'};
    my $DBPass = $options{'DBPass'};

    my $grant = "grant all on $InstanceDBName\.* to $DBUser\@localhost";
    $grant .= " identified by '$DBPass'" if ($DBPass);

    my $mysql_grant = ECHO_BIN ." \"$grant\" | $mysql_bin -uroot";
    $mysql_grant .= " -p$MySQLRootPassword" if (length($MySQLRootPassword));

    print "Granting MySQL access to user '$DBUser' for database '$InstanceDBName'\n";
    system($mysql_grant) && exit_error("Can't grant DB access to $DBUser for $InstanceDBName.");
    print "  MySQL access granted.\n";

    # handles any backup instances
    our @BACKUP_INSTANCES;
    foreach my $instance (@BACKUP_INSTANCES) {
        my $InstanceDBName = $instance->{'InstanceDBName'};

        $grant = "grant all on $InstanceDBName\.* to $DBUser\@localhost";
        $grant .= " identified by '$DBPass'" if ($DBPass);
        
        my $mysql_grant = ECHO_BIN ." \"$grant\" | $mysql_bin -uroot";
        $mysql_grant .= " -p$MySQLRootPassword" if (length($MySQLRootPassword));
        print "Granting MySQL access to user '$DBUser' for database '$InstanceDBName'\n";
        system($mysql_grant) && exit_error("Can't grant DB access to $DBUser for $InstanceDBName.");
        print "  MySQL access granted.\n";
        
    }
}


sub create_unix_user_group {
    my $KrangUser = $options{'KrangUser'};
    my $KrangGroup = $options{'KrangGroup'};
    my $InstallPath = $options{InstallPath};

    # Create user, if necessary
    print "Creating UNIX user ('$KrangUser')\n";
    my ($uname,$upasswd,$uid,$ugid,$uquota,$ucomment,$ugcos,$udir,$ushell,$uexpire) = getpwnam($KrangUser);
    unless (defined($uid)) {
        my $useradd = USERADD_BIN;
        $useradd .= " -d $InstallPath -M $KrangUser";
        system($useradd) && die("Can't add user: $!");

        # Update user data
        ($uname,$upasswd,$uid,$ugid,$uquota,$ucomment,$ugcos,$udir,$ushell,$uexpire) = getpwnam($KrangUser);
        print "  User created (uid $uid).\n";
    } else {
        print "  User already exists (uid $uid).\n";
    }

    # Create group, if necessary
    print "Creating UNIX group ('$KrangGroup')\n";
    my ($gname,$gpasswd,$gid,$gmembers) = getgrnam($KrangGroup);
    unless (defined($gid)) {
        my $groupadd = GROUPADD_BIN;
        $groupadd .= " $KrangGroup";
        system($groupadd) && die("Can't add group: $!");

        # Update group data for later
        ($gname,$gpasswd,$gid,$gmembers) = getgrnam($KrangGroup);
        print "  Group created (gid $gid).\n";
    } else {
        print "  Group already exists (gid $gid).\n";
    }

    # Add user to group, if user not already a member
    print "Adding user $KrangUser to group $KrangGroup\n";
    my @group_members = ( split(/\s+/, $gmembers) );
    my $user_is_group_member = ( grep { $_ eq $KrangUser } @group_members );
    unless (($ugid eq $gid) or $user_is_group_member) {
        my $usermod = USERMOD_BIN;
        $usermod .= " -G $KrangGroup $KrangUser";
        system($usermod) && die("Can't add user $KrangUser to group $KrangGroup: $!");
        print "  User added to group.\n";
    } else {
        print "  User already in group.\n";
    }
}

sub install_krang {
    my $InstallPath = $options{InstallPath};
    mkdir($InstallPath) || die($!);

    print "Installing Krang files into '$InstallPath'\n";

    chdir($ENV{KRANG_ROOT});
    my $copy = COPY_BIN ." -r * $InstallPath\/";
    system($copy) && die("Can't copy: $!");

    # remove scripts that won't do anything useful in an installed
    # system
    system("rm $InstallPath/bin/krang_install $InstallPath/bin/krang_makedist $InstallPath/bin/krang_upgrade");

    print "  Fixing ownership\n";
    my $KrangUser = $options{KrangUser};
    my $KrangGroup = $options{KrangGroup};
    my $chown = CHOWN_BIN ." -R $KrangUser\.$KrangGroup $InstallPath";
    system($chown) && die("Can't update ownership: $!");

    # For commands
    my $chmod;

    print "  Setting group write permissions\n";
    $chmod = CHMOD_BIN ." -R g+w $InstallPath";
    system($chmod) && die("Can't set group write permissions: $!");

    print "  Fixing directory read permissions\n";
    $chmod = FIND_BIN ." $InstallPath -type d | ". XARGS_BIN ." ". CHMOD_BIN ." +rx";
    system($chmod) && die("Can't fix directory read permissions: $!");

    print "  Fixing file read permissions\n";
    $chmod = FIND_BIN ." $InstallPath -type f | ". XARGS_BIN ." ". CHMOD_BIN ." +r";
    system($chmod) && die("Can't fix file read permissions: $!");

    print "  Setting execute bits on scripts\n";

    # Set all *.pl files
    $chmod = FIND_BIN ." $InstallPath -type f -name '*.pl' | ". XARGS_BIN ." ". CHMOD_BIN ." +x";
    system($chmod) && die("Can't set execite bits: $!");

    # Set all *.cgi files
    $chmod = FIND_BIN ." $InstallPath -type f -name '*.cgi' | ". XARGS_BIN ." ". CHMOD_BIN ." +x";
    system($chmod) && die("Can't set execite bits: $!");

    # Set all files in krang/bin/*
    $chmod = CHMOD_BIN ." +x $InstallPath/bin/*";
    system($chmod) && die("Can't set execite bits: $!");

    print "  Krang files installed.\n";
}


sub configure_krang {
    print "Configuring Krang installation\n";

    my $InstallPath = $options{InstallPath};
    chdir($InstallPath);


    if ($options{FromBackup}) {
        print "Updating backup krang.conf\n";

        # processing existing krang.conf, replacing IPAddress and
        # HostName parameters needed to migrate a backup to a new machine
        open(CONF, "<", "conf/krang.conf") 
          or die "Unable to open conf/krang.conf : $!";
        my @conf = <CONF>;
        close(CONF);

        open(CONF, ">", "conf/krang.conf") 
          or die "Unable to open conf/krang.conf : $!";
        foreach my $line (@conf) {
            if ($line =~ /^\s*ApacheAddr\s/i) {
                print CONF "ApacheAddr $options{IPAddress}\n";
            } elsif ($line =~ /^\s*FTPAddress\s/i) {
                print CONF "FTPAddress $options{IPAddress}\n";
            } elsif ($line =~ /^\s*HostName\s/i) {
                print CONF "HostName $options{HostName}\n";
            } elsif ($line =~ /^\s*FTPHostName\s/i) {
                print CONF "FTPHostName $options{FTPHostName}\n";
            } else {
                print CONF $line;
            }
        }
        close CONF;
        
        print "  Conf written to '$InstallPath/conf/krang.conf'.\n";

        # load database SQL
        opendir(BACKUP, catdir($ENV{KRANG_ROOT}, 'data', 'backup'))
          or die "Unable to open data/backup: $!";
        my @sql = grep { /\.sql$/ } readdir(BACKUP);
        closedir(BACKUP);
                
        foreach my $sql (@sql) {
            print "Creating MySQL database from backup source '$sql'.\n";
            my $file = catfile($ENV{KRANG_ROOT}, 'data', 'backup', $sql);
            my $cmd = "cat $file | mysql -uroot ";
            $cmd .= " -p$options{'MySQLRootPassword'}" 
              if length $options{'MySQLRootPassword'};
            system($cmd);
        }

    } else {
    
        # Make custom krang.conf
        print "Creating krang.conf from specification\n";
        my $t = HTML::Template->new(filename => $ENV{KRANG_ROOT} ."/conf/krang.conf.tmpl");
        foreach my $param (keys(%options)) {
            # Filter out params which are not in HTML::Template file 'krang.conf.tmpl'
            unless ( grep { $param eq $_ } qw/AdminPassword MySQLRootPassword InstallPath FromBackup/ ) {
                $t->param($param => $options{$param});
            }
        }
        my $output_conf = $InstallPath ."/conf/krang.conf";
        open(OUTPUT, ">$output_conf") || die("Can't open '$output_conf' for writing: $!");
        print OUTPUT $t->output();
        close(OUTPUT);
        print "  Conf written to '$output_conf'.\n";

        # Create DB
        print "Creating MySQL database and loading schema\n";
        my $MySQLRootPassword = $options{'MySQLRootPassword'};
        my $createdb = "KRANG_ROOT='' PERL5LIB='' $InstallPath/bin/krang_createdb";
        $createdb .= " --password $MySQLRootPassword" if (length($MySQLRootPassword));
        system($createdb) && die("Error calling krang_createdb.  Unable to continue");
        
        # Customize DB (Admin password)
        my $AdminPassword = $options{AdminPassword};
        print "  Changing 'admin' CMS login password to '$AdminPassword'\n";
        my $update_pw_perl = qq(
                            my (\$user) = Krang::User->find(login=>"admin");
                            \$user->password("$AdminPassword");
                            \$user->save();
                           );
        my $update_admin_pw = "KRANG_ROOT='$InstallPath' PERL5LIB='$InstallPath/lib' ";
        $update_admin_pw .= PERL_BIN ." -MKrang::Script -MKrang::User -e '$update_pw_perl'";
        system($update_admin_pw) && die("Error changing admin password: $!");
    }
}


sub add_krang_init {
    my $init_script = "krang-". $options{HostName} .".init";
    print "Installing Krang init.d script '$init_script'\n";

    chdir("/etc/init.d");
    my $InstallPath =  $options{InstallPath};
    my $link_init = LN_BIN ." -s $InstallPath\/bin/krang_ctl $init_script";
    system($link_init) && die ("Can't link init script: $!");

    print "Setting $init_script to start on boot\n";
    my $chkconfig = CHKCONFIG_BIN ." --add $init_script";
    system($chkconfig) && die("Can't chkconfig --add $init_script: $!");

    $chkconfig = CHKCONFIG_BIN ." $init_script on";
    system($chkconfig) && die("Can't chkconfig $init_script on: $!");
}


sub start_krang {
    my $init_script = "krang-". $options{HostName} .".init";
    print "Starting Krang via init.d script '$init_script'\n";
    my $start = "KRANG_ROOT='' PERL5LIB='' /etc/init.d/$init_script start";
    system($start) && die("Can't start Krang: $!");
}


sub make_test {
    print "Running Krang tests...\n";

    my $AdminPassword = $options{AdminPassword};

    my $InstallPath =  $options{InstallPath};
    chdir($InstallPath);

    my $make_bin = MAKE_BIN;
    my $make_test = "KRANG_ROOT='' PERL5LIB='' KRANG_PASSWORD='$AdminPassword' $make_bin test";
    system($make_test) && die("Error running tests: $!");
}


sub output_report {
    my $init_script = "/etc/init.d/krang-". $options{HostName} .".init";
    my $krang_conf = $options{InstallPath} ."/conf/krang.conf";

    print <<EOREPORT;


#####                                                         #####
###                                                             ###
##                  KRANG INSTALLATION COMPLETE                  ##
###                                                             ###
#####                                                         #####


   Installed at        :  $options{InstallPath}
   Startup init script :  $init_script
   Krang conf file     :  $krang_conf

   Running on $options{IPAddress} --
     http://$options{HostName}:$options{ApachePort}/
     ftp://$options{HostName}:$options{FTPPort}/

   CMS admin user password:  "$options{AdminPassword}"


EOREPORT
}





###########################
####  PRIVATE METHODS  ####
###########################

sub exit_error {
    my $cmd = $0;
    $cmd =~ s/.*\/(.+)$/$1/;

    my $message = shift;
    print STDERR "\nError: $cmd:  $message\n\n";
    exit(1);
}


sub setup_getopts {
    # Copy the original args for re-invoking later
    @original_args = @ARGV;

    pod2usage(2) unless
        GetOptions( 'help'      => \$help,
                    'man'       => \$man,
                    'do-mysql-install' => \$do_mysql_install,
                    'do-perl-install' => \$do_perl_install,
                    'run-tests' => \$run_tests,
                    (map { $_."=s" => \$options{$_} } @req_params, @opt_params) );

    pod2usage(1)             if $help;
    pod2usage(-verbose => 2) if $man;

}

sub enforce_requirements {
    # Enforce required params
    my $error_output = "";
    foreach my $p (@req_params) {
        next if defined($options{$p});
        $error_output .= "Missing --". $p ."\n";
    }
    if ($error_output) {
        print "Error:\n\n$error_output\n";
        pod2usage(1);
    }

    # Set opt defaults
    set_param_defaults();
}


sub set_param_defaults {
    my %defaults = (
                    MySQLRootPassword => '',
                    InstallPath => '/usr/local/krang',
                    KrangUser => 'krang',
                    KrangGroup => 'krang',
                    FTPPort => '21',
                    FTPHostName => $options{'HostName'},
                    ApachePort => '80',
                    SMTPServer => '127.0.0.1',
                    );

    # Set up defaults if value is not otherwise set
    while (my ($k, $dv) = each(%defaults)) {
        # Skip if value already defined
        next if (defined $options{$k});

        if ($k eq 'FTPPort') {
            # attempt to connect to port 21. else default to 2121
            my $remote;
            $remote = IO::Socket::INET->new(
                        Proto    => "tcp",
                        PeerAddr => $options{'IPAddress'},
                        PeerPort => "ftp(21)",
                    ) || '';
            close $remote if $remote;

            $dv = 2121 if (not $remote);
        }

        # Set default
        $options{$k} = $dv;
    }

    # Default instancedisplayname => $instancevirtualhost
    my $idn = "InstanceDisplayName";
    unless (length($options{$idn})) {
        $options{$idn} = $options{'InstanceHostName'};
    }
}
