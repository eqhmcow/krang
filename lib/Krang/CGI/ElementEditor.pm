package Krang::CGI::ElementEditor;
use strict;
use warnings;

=head1 NAME

Krang::CGI::ElementEditor - element editor CGI class

=head1 SYNOPSIS

  http://krang/instance_name/element_editor

=head1 DESCRIPTION

Example element editor for Krang.

=head1 INTERFACE

None.

=cut

use Krang::ElementLibrary;
use Krang::Element;
use Krang::DB qw(dbh);
use Carp qw(croak);

use base 'Krang::CGI';

sub setup {
    my $self = shift;
    $self->start_mode('choose_top_level');
    $self->run_modes(choose_top_level => \&choose_top_level,
                     create  => \&create,
                     edit    => \&edit,
                     add     => \&add,
                     save    => \&save,
                     save_and_jump => \&save_and_jump,
                     save_and_stay => \&save_and_stay,
                     delete  => \&delete,
                     reorder => \&reorder,
                    );
}

# show the top_level chooser
sub choose_top_level {
    my $self = shift;
    my $query = $self->query();
    my $dbh = dbh();
    my $template = $self->load_tmpl("element_editor_choose.tmpl",
                                    associate => $query);

    # whip up top level picker
    my @values = Krang::ElementLibrary->top_levels;
    my %labels = map { ($_, Krang::ElementLibrary->top_level(name => $_)
                                                  ->display_name) } 
                   @values;
    $template->param(top_level_select => 
                     $query->popup_menu(-name   => "top_level",
                                        -values => \@values,
                                        -labels => \%labels));

    # show a list of existing elements
    my $result = $dbh->selectall_arrayref('SELECT root_id, class FROM element WHERE parent_id IS NULL ORDER BY root_id');
    my @element_loop;
    foreach my $row (@$result) {
        push(@element_loop, { element_id => $row->[0],
                              name       => $row->[1] });
    }
    $template->param(element_loop => \@element_loop);


    return $template->output();
}

# create a new top-level element
sub create {
    my $self      = shift;
    my $query     = $self->query();
    my $top_level = $query->param("top_level") 
      or croak("Missing top_level param!");

    # create a new instance and save it
    my $element = Krang::Element->new(class => $top_level);
    $element->save();

    # setup ids and toss to edit
    $query->param(path => '');
    $query->param(root_id => $element->element_id);
    return $self->edit;
}

# add sub-elements
sub add {
    my $self = shift;
    my $query = $self->query();

    # gather params
    my $path    = $query->param('path');
    my $root_id = $query->param('root_id');
    my $child   = $query->param('child');

    # find our element
    my $root   = Krang::Element->find(element_id => $root_id);
    my $element = _find_element($root, $path);

    # add the child element and save the element tree
    $element->add_child(class => $child);
    $root->save();

    # toss to edit
    return $self->edit();
}

# finds an element given the root and a path, optionally building @crumbs loop
sub _find_element {
    my ($element, $path, $crumbs) = @_;
    push(@$crumbs, { path => '',
                     name => $element->display_name })
      if $crumbs;

    # no path means the element is the root
    return $element unless defined $path;

    # otherwise, split up the path and locate the elements
    my @path = split(',', $path);
    my ($index, @path_back);
    while(@path) {
        $index = shift(@path);
        $element = $element->children()->[$index];
        if ($crumbs) {
            push @path_back, $index;
            push(@$crumbs, { path => join(',',@path_back),
                             name => $element->display_name });
        }
    } 

    return $element;
}

# show the edit screen
sub edit {
    my $self = shift;
    my $query = $self->query();
    my $template = $self->load_tmpl("element_editor_edit.tmpl",
                                    associate => $query,
                                    loop_context_vars => 1);

    my $path = $query->param('path');
    my $root_id = $query->param('root_id');

    my $root = Krang::Element->find(element_id => $root_id);
    my @crumbs;
    my $element = _find_element($root, $path, \@crumbs);
    $template->param(crumbs => \@crumbs);

    # can I get back from here?
    $template->param(return_path => @crumbs > 1 ? $crumbs[-2]{path} : "");

    # load invalid list, generated by save()
    my %invalid;
    %invalid = map { ($_ => 1) } (split(',', $query->param('invalid')))
      if $query->param('invalid');

    my @child_loop;
    my $index = 0;
    my $order;
    my @children = $element->children;
    
    # figure out list of slots that are reorderable
    my @avail_ord = grep { $children[$_-1]->reorderable } (1 .. @children);
        
    foreach my $child (@children) {        
        push(@child_loop, {
                           form         => $child->input_form(query => $query,
                                                              order => $index),
                           name         => $child->display_name(),
                           ($child->reorderable ? 
                            (order_select =>
                             $query->popup_menu(-name => "order_$index",
                                                -values => \@avail_ord,
                                                -default => $index + 1)) : ()),
                           is_container => $child->is_container,
                           index        => $index,
                           reorderable  => $child->reorderable,
                           allow_delete => $child->allow_delete,
                           invalid       => $invalid{$index},
                          });
        $index++;
    }
    $template->param(child_loop => \@child_loop);

    # whip up top level picker
    my @available =  $element->available_child_classes();
    my @values = map { $_->name } @available;
    my %labels = map { ($_->name, $_->display_name) } @available;
    $template->param(child_select => 
                     $query->popup_menu(-name   => "child",
                                        -values => \@values,
                                        -labels => \%labels));


    return $template->output();    
}

sub save_and_stay {
    my $self = shift;
    return $self->save(stay => 1);
}

sub save_and_jump {
    my $self = shift;
    my $query = $self->query();
    return $self->save(jump_to => $query->param("jump_to"));
}

sub save {
    my $self = shift;
    my %arg = @_;
    my $query = $self->query();
    my $template = $self->load_tmpl("element_editor_edit.tmpl",
                                    associate => $query,
                                    loop_context_vars => 1);

    my $path = $query->param('path');
    my $root_id = $query->param('root_id');

    my $root = Krang::Element->find(element_id => $root_id);    
    my $element = _find_element($root, $path);

    # validate data
    my @msgs;
    my $clean = 1;
    my $index = 0;
    my @invalid;
    foreach my $child ($element->children()) {
        my ($valid, $msg) = $child->validate(query => $query, order => $index);
        if (not $valid) {
            push @msgs, "* $msg";
            push @invalid, $index;
            $clean = 0;
        }
        $index++;
    }

    # toss back to edit with an error message if not clean
    if (not $clean) {
        my %seen;
        $query->param(alert => join('<br>', grep { ++$seen{$_} == 1 } @msgs));
        $query->param(invalid => join(',', @invalid));
        return $self->edit();
    }

    # save data
    $index = 0;
    foreach my $child ($element->children()) {
        $child->load_query_data(query => $query, order => $index);
        $index++;
    }

    # save element tree
    $root->save();
    $query->param(alert => $element->display_name() . " saved.");

    # save and stay?
    return $self->edit() if exists $arg{stay};

    # save and jump?
    if (exists $arg{jump_to}) {
        $query->param(path => $arg{jump_to});
        return $self->edit();
    }
                      

    # go up a level
    if (defined $path and length $path) {
        my @path = split(',', $path);
        pop @path;
        $path = join(',', @path);
        $query->param(path => $path);
        return $self->edit();
    } else {
        return $self->choose_top_level();
    }
}

# reorder sub-elements
sub reorder {
    my $self = shift;
    my $query = $self->query();
    my $template = $self->load_tmpl("element_editor_edit.tmpl",
                                    associate => $query,
                                    loop_context_vars => 1);

    my $path = $query->param('path');
    my $root_id = $query->param('root_id');

    my $root = Krang::Element->find(element_id => $root_id);    
    my $element = _find_element($root, $path);

    # compute new list of children
    my @new_children;
    my @old_children = $element->children();
    my @msgs;
    for my $index (0 .. @old_children - 1) {
        if ($query->param("order_$index")) {
            my $requested_index = $query->param("order_$index");
            # deal with collisions
            while(defined $new_children[$requested_index]) {
                $requested_index++;
            }
            $new_children[$requested_index] = $old_children[$index];
            $query->delete("order_$index");
        } else {
            push @new_children, $old_children[$index];            
        }
    }
    # compress empty space
    @new_children = grep { defined $_ } @new_children;

    # save list
    $element->children(@new_children);
    $root->save();

    # toss to edit
    return $self->edit();    
}

# delete sub-elements
sub delete {
    my $self = shift;
    my $query = $self->query();
    my $template = $self->load_tmpl("element_editor_edit.tmpl",
                                    associate => $query,
                                    loop_context_vars => 1);

    my $path = $query->param('path');
    my $root_id = $query->param('root_id');

    my $root = Krang::Element->find(element_id => $root_id);    
    my $element = _find_element($root, $path);

    # compute new list of children
    my @new_children;
    my @old_children = $element->children();
    my @msgs;
    for my $index (0 .. @old_children - 1) {
        if ($query->param("remove_$index")) {
            push @msgs, "Removed " . $old_children[$index]->display_name;
            $query->delete("remove_$index");
        } else {
            push @new_children, $old_children[$index];            
        }
    }
    # save list
    $element->children(@new_children);
    $root->save();

    # generate alert and toss to save
    @msgs = ('No elements marked for deletion!') unless @msgs;
    $query->param(alert => join('<br>', @msgs));
    return $self->edit();
}


1;
