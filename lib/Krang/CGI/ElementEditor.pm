package Krang::CGI::ElementEditor;
use strict;
use warnings;

=head1 NAME

Krang::CGI::ElementEditor - element editor CGI base class

=head1 SYNOPSIS

  http://krang/instance_name/element_editor

=head1 DESCRIPTION

Element editor CGI for Krang.  This module is a super-class upon which
element editing CGIs (story and category editors) may be built.  It
supplies some full run-modes as well as some helper functions which
the child classes will use to implement their run-modes.

=head1 INTERFACE

=head2 Provided Run Modes

This module implements the following run modes:

=over

=item add

Called when the user clicks the "Add Element" button in the element
editor.  Returns to the 'edit' mode when complete without modifying
'path'.

=item delete_children

Called to delete sub-elements.  Returns to the 'edit' mode when
complete without modifying 'path'.

=item reorder

Called to reorder sub-elements.  Returns to the 'edit' mode when
complete without modifying 'path'.

=item delete_element

Called to delete an element.  This should called when the user clicks
the delete button, except on the root screen where delete refers to
the containing object.

=cut

use Krang::ElementLibrary;
use Krang::Element;
use Krang::DB qw(dbh);
use Carp qw(croak);
# use Krang::Session qw(%session);
use Krang::Log qw(debug assert affirm ASSERT);
use Krang::Message qw(add_message get_messages);
use base 'Krang::CGI';

sub setup {
    my $self = shift;
    $self->start_mode('fake');
    $self->mode_param('rm');
    $self->run_modes(
                     fake             => sub { "OK" },
                     add              => 'add',
                     delete_children  => sub { shift->revise('delete') },
                     reorder          => sub { shift->revise('reorder') },
                     delete_element   => 'delete_element',
                    );
}

sub is_root {
    my $self    = shift;
    my $query   = $self->query;
    my $rm      = $query->param('rm');
    my $path    = $query->param('path') || '/';
    my $jump_to = $query->param('jump_to');

    return 1 if $path eq '/' and $rm !~ /^save/;
    return 1 if $rm eq 'save' and $path eq '/';
    return 1 if $rm eq 'save_and_stay' and $path eq '/';
    return 1 if $rm eq 'save_and_jump' and $jump_to eq '/';
    return 0;
}

# show the edit screen
sub element_edit {
    my ($self, %args) = @_;
    my $query = $self->query();
    my $template = $args{template};
    my $path    = $query->param('path') || '/';
    my $root_id = $query->param('root_id');

    # find the root element, loading from the session or the DB
    my $root = $self->_get_element;
    croak("Unable to load element from session.") 
      unless defined $root;

    # find the element being edited using path
    my $element = _find_element($root, $path);

    # crumbs let the user jump up the tree
    my $pointer = $element;
    my @crumbs;
    do {
        unshift(@crumbs, { name => $pointer->display_name,
                           path => $pointer->xpath });
        $pointer = $pointer->parent;
    } while ($pointer);
    $template->param(crumbs => \@crumbs) unless @crumbs == 1;

    # load invalid list, generated by save()
    my %invalid;
    %invalid = map { ($_ => 1) } (split(',', $query->param('invalid')))
      if defined $query->param('invalid');

    my @child_loop;
    my $index = 0;
    my $order;
    my @children = $element->children;
    
    # figure out list of slots that are reorderable
    my @avail_ord = grep { $children[$_-1]->reorderable } (1 .. @children);
        
    foreach my $child (@children) {        
        push(@child_loop, {
                           form         => $child->input_form(
                                                query   => $query,
                                                order   => $index,
                                                invalid => $invalid{$index},
                                                             ),
                           name         => $child->display_name(),
                           path         => $child->xpath(),
                           (order_select =>
                             $child->reorderable ? 
                             $query->popup_menu(-name => "order_$index",
                                                -values => \@avail_ord,
                                                -default => $index + 1,
                                                -override => 1) : 
                             ($index + 1) .  
                             $query->hidden(-name     => "order_$index",
                                            -default  => $index + 1,
                                            -override => 1)),
                           is_container => $child->is_container,
                           index        => $index,
                           allow_delete => $child->allow_delete,
                           required     => $child->required,
                           invalid      => $invalid{$index},
                          });
        $index++;
    }
    $template->param(child_loop => \@child_loop);

    # whip up top level picker
    my @available =  $element->available_child_classes();
    my @values = map { $_->name } @available;
    my %labels = map { ($_->name, $_->display_name) } @available;
    $template->param(child_select => 
                     $query->popup_menu(-name   => "child",
                                        -values => \@values,
                                        -labels => \%labels));
}


sub element_view {
    my ($self, %args) = @_;
    my $query    = $self->query();
    my $template = $args{template};
    my $root     = $args{element}; 
    my $path    = $query->param('path') || '/';

    # find the element being edited using path
    my $element = _find_element($root, $path);

    # crumbs let the user jump up the tree
    my $pointer = $element;
    my @crumbs;
    do {
        unshift(@crumbs, { name => $pointer->display_name,
                           path => $pointer->xpath,
                         });
        $pointer = $pointer->parent;
    } while ($pointer);
    $template->param(crumbs => \@crumbs) unless @crumbs == 1;

    my @child_loop;
    my @children = $element->children;
    
    # figure out list of slots that are reorderable
    foreach my $child (@children) {        
        push(@child_loop, {
                           data         => $child->view_data(),
                           name         => $child->display_name(),
                           path         => $child->xpath(),
                           is_container => $child->is_container,
                          });
    }
    $template->param(child_loop => \@child_loop,
                     parent_path => ($element->parent ?
                                     $element->parent->xpath : 0),
                    );
    
}

# add sub-elements
sub add {
    my $self = shift;
    my $query = $self->query();

    # gather params
    my $path    = $query->param('path') || '/';
    my $child   = $query->param('child');

    # find our element
    my $root    = $self->_get_element;
    my $element = _find_element($root, $path);

    # add the child element and save the element tree
    my $kid = $element->add_child(class => $child);

    # start editing the new element if it has children
    # $query->param(path => $kid->xpath()) if $kid->is_container;
    
    add_message('added_element', child  => $kid->display_name(),
                                 parent => $element->display_name());

    # toss to edit
    return $self->edit();
}

# finds an element given the root and a path, optionally building @crumbs loop
sub _find_element {
    my ($root, $path, $crumbs) = @_;

    my ($element) = $root->match($path);
    croak("Unable to find element for path '$path'.")
      unless $element;

    return $element;
}

sub element_save {
    my $self = shift;
    my %arg = @_;
    my $query = $self->query();

    my $path    = $query->param('path') || '/';
    my $root_id = $query->param('root_id');

    my $root = $self->_get_element;
    my $element = _find_element($root, $path);

    # validate data
    my @msgs;
    my $clean = 1;
    my $index = 0;
    my @invalid;
    foreach my $child ($element->children()) {
        my ($valid, $msg) = $child->validate(query => $query);
        if (not $valid) {
            add_message('invalid_element_data', msg => $msg);
            push @invalid, $index;
            $clean = 0;
        }
        $index++;
    }

    # toss back to edit with an error message if not clean
    if (not $clean) {
        my %seen;
        $query->param(invalid => join(',', @invalid));
        return 0;
    }

    # save data
    $index = 0;
    foreach my $child ($element->children()) {
        $child->load_query_data(query => $query);
        $index++;
    }

    # save element tree to DB
    # $root->save();
    add_message('saved_element', name => $element->display_name())
      if $element->parent();
    

    # save and stay?
    return 1 if exists $arg{stay};

    # save and jump?
    if (exists $arg{jump_to}) {
        $query->param(path => $arg{jump_to});
        return 1;
    }

    # go up a level
    if ($element->parent()) {
        $query->param(path => $element->parent->xpath);
    }

    return 1;
}

# revise sub-element list, reordering or deleting as requested.  This
# is combined because the complex parameter reordering has to be done
# in either case.
sub revise {
    my ($self, $op) = @_;
    my $query = $self->query();

    my $path = $query->param('path') || '/';
    my $root = $self->_get_element;
    my $element = _find_element($root, $path);

    # get list of existing children and their query parameters
    my @old = $element->children();
    my @old_names =  map { [ $_->param_names ] } @old;

    # compute new list of children and rearrange query data
    my (@new, @old_to_new, @msgs);
    if ($op eq 'reorder') {
        for (0 .. $#old) {
            $new[$query->param("order_$_") - 1] = $old[$_];
            $old_to_new[$_] = $query->param("order_$_") - 1;
        }
    } elsif ($op eq 'delete') {
        for (0 .. $#old) {
            if ($query->param("remove_$_")) {
                add_message("deleted_element", name => $old[$_]->display_name);
            } else {
                push(@new, $old[$_]);
                $old_to_new[$_] = $#new;
            }
        }
    } else {
        croak("Unknown op: '$op'");
    }

    # the javascript should ensure all order_$n fields are present and
    # non-overlapping
    assert(@old == @new)                      if ASSERT and $op eq 'reorder';
    assert(not(grep { not defined $_ } @new)) if ASSERT;

    # effect the change in the element tree
    $element->children(@new);

    # get a list of new param names
    my @new_names =  map { [ $_->param_names ] } @new;

    # fix up query data assignments, which depend on ordering
    my (%params, @old_params, @new_params);
    for my $index (0 .. $#old) {
        next unless defined $old_to_new[$index];
        @old_params = @{$old_names[$index]};
        @new_params = @{$new_names[$old_to_new[$index]]};
        foreach my $p (0 .. $#old_params) {
            $params{$new_params[$p]} = [$query->param($old_params[$p])];
        }
    }
    $query->param($_ => @{$params{$_}}) for keys %params;

    # deletions get a message listing deleted elements
    if ($op eq 'delete') {
        my %msg = get_messages(keys => 1);
        add_message('no_elements_deleted') unless $msg{deleted_element};

    } else {
        add_message('reordered_elements');
    }

    return $self->edit();
}

# delete this element
sub delete_element {
    my $self  = shift;
    my $query = $self->query();

    my $path = $query->param('path') || '/';
    my $root_id = $query->param('root_id');

    my $root = $self->_get_element;
    my $element = _find_element($root, $path);

    my $parent = $element->parent();
    if (not $parent) {
        # this is the root, delete it from the DB if it has an ID
        $element->delete()
          if $element->element_id;
        return $self->choose_top_level();
    }

    # remove this element from parent    
    $parent->children(grep { $_ != $element } $parent->children());
    
    $query->param(path => $parent->xpath());
    add_message('deleted_element', name => $element->display_name);
    return $self->edit();
}

1;

=back
