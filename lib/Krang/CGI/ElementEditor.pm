package Krang::CGI::ElementEditor;
use strict;
use warnings;

=head1 NAME

Krang::CGI::ElementEditor - element editor CGI class

=head1 SYNOPSIS

  http://krang/instance_name/element_editor

=head1 DESCRIPTION

Element editor CGI for Krang.  This CGI is embedded in the Story and
Category editors.  It allows users to edit the contents of the element
tree attached to the story or category.

=head1 INTERFACE

None.

=cut

use Krang::ElementLibrary;
use Krang::Element;
use Krang::DB qw(dbh);
use Carp qw(croak);
use Krang::Session qw(%session);
use Krang::Log qw(debug assert affirm ASSERT);

use base 'Krang::CGI';

sub setup {
    my $self = shift;
    $self->start_mode('choose_top_level');
    $self->mode_param('e_rm');
    $self->run_modes(choose_top_level => \&choose_top_level,
                     create           => \&create,
                     edit             => \&edit,
                     add              => \&add,
                     save             => \&save,
                     save_and_jump    => \&save_and_jump,
                     save_and_stay    => \&save_and_stay,
                     delete_children  => sub { shift->revise('delete') },
                     reorder          => sub { shift->revise('reorder') },
                     delete           => \&delete,
                    );
}

# show the top_level chooser (this won't be used in the final version
# of the editor, but it's need to allow it to be tested independently)
sub choose_top_level {
    my $self = shift;
    my $query = $self->query();
    my $dbh = dbh();
    my $template = $self->load_tmpl("element_editor_choose.tmpl",
                                    associate => $query);

    # whip up top level picker
    my @values = Krang::ElementLibrary->top_levels;
    my %labels = map { ($_, Krang::ElementLibrary->top_level(name => $_)
                                                  ->display_name) } 
                   @values;
    $template->param(top_level_select => 
                     $query->popup_menu(-name   => "top_level",
                                        -values => \@values,
                                        -labels => \%labels));

    # show a list of existing elements
    my $result = $dbh->selectall_arrayref('SELECT root_id, class FROM element WHERE parent_id IS NULL ORDER BY root_id');
    my @element_loop;
    foreach my $row (@$result) {
        push(@element_loop, { element_id => $row->[0],
                              name       => $row->[1] });
    }
    $template->param(element_loop => \@element_loop);


    return $template->output();
}

# create a new top-level element
sub create {
    my $self      = shift;
    my $query     = $self->query();
    my $top_level = $query->param("top_level") 
      or croak("Missing top_level param!");

    # create a new instance and save it in the session
    my $element = Krang::Element->new(class => $top_level);
    $session{element} = $element;

    # setup ids and toss to edit
    $query->param(path => '/');
    $query->param(root_id => undef);
    return $self->edit;
}


# show the edit screen
sub edit {
    my $self = shift;
    my $query = $self->query();
    my $template = $self->load_tmpl("element_editor_edit.tmpl",
                                    associate => $query,
                                    loop_context_vars => 1);
    
    my $path    = $query->param('path') || '/';
    my $root_id = $query->param('root_id');

    # find the root element, loading from the session or the DB
    my $root;
    if ($root_id) {
        $session{element} = 
          $root = Krang::Element->find(element_id => $root_id);        

        croak("Unable to load element from DB by id '$root_id'")
          unless defined $root;
        $query->param(root_id => undef);
    } else {
        $root = $session{element};
        croak("Unable to load element from session.") 
          unless defined $root;
    }

    # find the element being edited using path
    my $element = _find_element($root, $path);

    # crumbs let the user jump up the tree
    my $pointer = $element;
    my @crumbs;
    do {
        unshift(@crumbs, { name => $pointer->display_name,
                           path => $pointer->xpath });
        $pointer = $pointer->parent;
    } while ($pointer);
    $template->param(crumbs => \@crumbs) unless @crumbs == 1;

    # load invalid list, generated by save()
    my %invalid;
    %invalid = map { ($_ => 1) } (split(',', $query->param('invalid')))
      if defined $query->param('invalid');

    my @child_loop;
    my $index = 0;
    my $order;
    my @children = $element->children;
    
    # figure out list of slots that are reorderable
    my @avail_ord = grep { $children[$_-1]->reorderable } (1 .. @children);
        
    foreach my $child (@children) {        
        push(@child_loop, {
                           form         => $child->input_form(
                                                query   => $query,
                                                order   => $index,
                                                invalid => $invalid{$index},
                                                             ),
                           name         => $child->display_name(),
                           path         => $child->xpath(),
                           (order_select =>
                             $child->reorderable ? 
                             $query->popup_menu(-name => "order_$index",
                                                -values => \@avail_ord,
                                                -default => $index + 1,
                                                -override => 1) : 
                             ($index + 1) .  
                             $query->hidden(-name     => "order_$index",
                                            -default  => $index + 1,
                                            -override => 1)),
                           is_container => $child->is_container,
                           index        => $index,
                           allow_delete => $child->allow_delete,
                           required     => $child->required,
                           invalid      => $invalid{$index},
                          });
        $index++;
    }
    $template->param(child_loop => \@child_loop);

    # whip up top level picker
    my @available =  $element->available_child_classes();
    my @values = map { $_->name } @available;
    my %labels = map { ($_->name, $_->display_name) } @available;
    $template->param(child_select => 
                     $query->popup_menu(-name   => "child",
                                        -values => \@values,
                                        -labels => \%labels));


    return $template->output();    
}


# add sub-elements
sub add {
    my $self = shift;
    my $query = $self->query();

    # gather params
    my $path    = $query->param('path') || '/';
    my $child   = $query->param('child');

    # find our element
    my $root    = $session{element};
    my $element = _find_element($root, $path);

    # add the child element and save the element tree
    my $kid = $element->add_child(class => $child);

    # start editing the new element if it has children
    $query->param(path => $kid->xpath()) if $kid->is_container;
    
    $query->param(alert => "Added " . $kid->display_name() . " to " . 
                           $element->display_name() . ".");

    # toss to edit
    return $self->edit();
}

# finds an element given the root and a path, optionally building @crumbs loop
sub _find_element {
    my ($root, $path, $crumbs) = @_;

    my ($element) = $root->match($path);
    croak("Unable to find element for path '$path'.")
      unless $element;

    return $element;
}

sub save_and_stay {
    my $self = shift;
    return $self->save(stay => 1);
}

sub save_and_jump {
    my $self = shift;
    my $query = $self->query();
    return $self->save(jump_to => $query->param("jump_to"));
}

sub save {
    my $self = shift;
    my %arg = @_;
    my $query = $self->query();

    my $path    = $query->param('path') || '/';
    my $root_id = $query->param('root_id');

    my $root = $session{element};
    my $element = _find_element($root, $path);

    # validate data
    my @msgs;
    my $clean = 1;
    my $index = 0;
    my @invalid;
    foreach my $child ($element->children()) {
        my ($valid, $msg) = $child->validate(query => $query);
        if (not $valid) {
            push @msgs, "* $msg";
            push @invalid, $index;
            $clean = 0;
        }
        $index++;
    }

    # toss back to edit with an error message if not clean
    if (not $clean) {
        my %seen;
        $query->param(alert => join('<br>', grep { ++$seen{$_} == 1 } @msgs));
        $query->param(invalid => join(',', @invalid));
        return $self->edit();
    }

    # save data
    $index = 0;
    foreach my $child ($element->children()) {
        $child->load_query_data(query => $query);
        $index++;
    }

    # save element tree to DB
    $root->save();
    $query->param(alert => $element->display_name() . " saved.")
      unless $query->param('alert');
    
    # save and stay?
    return $self->edit() if exists $arg{stay};

    # save and jump?
    if (exists $arg{jump_to}) {
        $query->param(path => $arg{jump_to});
        return $self->edit();
    }

    # go up a level
    if ($element->parent()) {
        $query->param(path => $element->parent->xpath);
        return $self->edit();
    } else {
        return $self->choose_top_level();
    }
}

# revise sub-element list, reordering or deleting as requested.  This
# is combined because the complex parameter reordering has to be done
# in either case.
sub revise {
    my ($self, $op) = @_;
    my $query = $self->query();

    my $path = $query->param('path') || '/';
    my $root = $session{element};
    my $element = _find_element($root, $path);

    # get list of existing children and their query parameters
    my @old = $element->children();
    my @old_names =  map { [ $_->param_names ] } @old;

    # compute new list of children and rearrange query data
    my (@new, @old_to_new, @msgs);
    if ($op eq 'reorder') {
        for (0 .. $#old) {
            $new[$query->param("order_$_") - 1] = $old[$_];
            $old_to_new[$_] = $query->param("order_$_") - 1;
        }
    } elsif ($op eq 'delete') {
        for (0 .. $#old) {
            if ($query->param("remove_$_")) {
                push @msgs, "Removed " . $old[$_]->display_name;
            } else {
                push(@new, $old[$_]);
                $old_to_new[$_] = $#new;
            }
        }
    } else {
        croak("Unknown op: '$op'");
    }

    # the javascript should ensure all order_$n fields are present and
    # non-overlapping
    assert(@old == @new)                      if ASSERT and $op eq 'reorder';
    assert(not(grep { not defined $_ } @new)) if ASSERT;

    # effect the change in the element tree
    $element->children(@new);

    # get a list of new param names
    my @new_names =  map { [ $_->param_names ] } @new;

    # fix up query data assignments, which depend on ordering
    my (%params, @old_params, @new_params);
    for my $index (0 .. $#old) {
        next unless defined $old_to_new[$index];
        @old_params = @{$old_names[$index]};
        @new_params = @{$new_names[$old_to_new[$index]]};
        foreach my $p (0 .. $#old_params) {
            $params{$new_params[$p]} = [$query->param($old_params[$p])];
        }
    }
    $query->param($_ => @{$params{$_}}) for keys %params;

    # deletions get a message listing deleted elements
    if ($op eq 'delete') {
        @msgs = ('No elements marked for deletion!') unless @msgs;
        $query->param(alert => join('<br>', @msgs));
    } else {
        $query->param(alert => 'Reordered elements.');
    }

    return $self->edit();
}

# delete this element
sub delete {
    my $self  = shift;
    my $query = $self->query();

    my $path = $query->param('path') || '/';
    my $root_id = $query->param('root_id');

    my $root = $session{element};
    my $element = _find_element($root, $path);

    my $parent = $element->parent();
    if (not $parent) {
        # this is the root, delete it from the DB if it has an ID
        $element->delete()
          if $element->element_id;
        return $self->choose_top_level();
    }

    # remove this element from parent    
    $parent->children(grep { $_ != $element } $parent->children());
    
    $query->param(path => $parent->xpath());
    $query->param(alert => 'Removed ' . $element->display_name . ' from ' .
                           $parent->display_name());
    return $self->edit();
}

1;
