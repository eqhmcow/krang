#!/usr/bin/perl 
use warnings;
use strict;

=pod

=head1 NAME

krang_offline

=head1 SYNOPSIS

   krang_offline start

   krang_offline stop

=head1 DESCRIPTION

This script controls the Apache server that acts as an offline page
for Krang. The usage of the script is the same as F<bin/krang_apachectl>
script but only "start" and "stop".

Usage information can be obtained by running the script with no arguments.

=head2 FOR DEVELOPERS

=cut

# how long to wait for stop on restart (in seconds)
use constant MAX_RESTART_WAIT => 10;
# location of ApacheRoot, relative to $KRANG_ROOT
use constant APACHE_ROOT => 'apache/';
# location of ApacheBin, relative to ApacheRoot
use constant APACHE_BIN => 'bin/httpd';

$|++;

use File::Spec::Functions qw(catdir catfile splitdir rel2abs canonpath);
use FindBin qw($RealBin);
use Config;

BEGIN {

    # Find a KRANG_ROOT based on path to bin
    my @dir = splitdir(canonpath($RealBin));
    $ENV{KRANG_ROOT} ||= catdir(@dir[0 .. $#dir - 1]);

    # use $KRANG_ROOT/lib for modules
    my $lib = catdir($ENV{KRANG_ROOT}, "lib");
    $ENV{PERL5LIB} =
      $ENV{PERL5LIB}
      ? "$ENV{PERL5LIB}:${lib}"
      : "${lib}";
    unshift @INC, $lib, "$lib/" . $Config{archname};

    # load Krang::Conf (don't need to load Krang here because we won't
    # be slinging elements)
    eval { require Krang::Conf };
    warn << "END" and exit(1) if $@;
######################################################################

Cannot load Krang.

Error message:

$@

######################################################################
END
}

use Krang::ClassFactory qw(pkg);
use Krang::ClassLoader Conf => qw(KrangRoot InstanceHostName Skin KrangUser KrangGroup EnableSSL
  InstanceApacheAddr InstanceApachePort InstanceSSLCertificateFile
  InstanceSSLCertificateKeyFile InstanceSSLCertificateChainFile
  InstanceSSLCACertificateFile InstanceSSLCARevocationFile InstanceSSLPort
);
use Krang::ClassLoader 'File';

# SSL directives
my @ssl_directives = qw(
  SSLApachePort
  SSLPassPhraseDialog
  SSLRandomSeedStartup
  SSLRandomSeedConnect
  SSLSessionCacheTimeout
  SSLProtocol
  SSLCipherSuite
  SSLVerifyClient
  SSLVerifyDepth
  SSLLogLevel
);

# the httpd command
my $apache_bin = rel2abs(catfile(KrangRoot, APACHE_ROOT, APACHE_BIN));
my $httpd = $apache_bin . ' -f ' . rel2abs(catfile(KrangRoot, "tmp", "httpd_offline.conf"));

# get status from the pid file
my $online_pid_file = catfile(KrangRoot, "tmp", "httpd.pid");
my $offline_pid = _is_pid_running(catfile(KrangRoot, "tmp", "httpd_offline.pid"));
my $online_pid = _is_pid_running($online_pid_file);

sub _is_pid_running {
    my $pid_file = shift;
    my $running = 0;
    my $pid;
    if (-e $pid_file) {
        $pid = `cat $pid_file`;
        chomp $pid;
        if ($pid and kill(0, $pid)) {
            $running = 1;
        }
    }
    return $running ? $pid : undef;
}

# check for args
usage() unless @ARGV;

my $command = shift @ARGV;

if ($command eq 'start') {
    die "krang_offline start: offline httpd (pid $offline_pid) already running\n" if $offline_pid;

    if ($online_pid) {

        # wait for stop - check pid file for removal
        my $stopped = 0;
        for my $wait (0 .. MAX_RESTART_WAIT) {
            if (not -e $online_pid_file) {
                $stopped = 1;
                last;
            }
            print ".";
            sleep 1;
        }

        if (!$stopped) {
            die "krang_offline start: httpd (pid $online_pid) already running.\n"
              . "Waited "
              . MAX_RESTART_WAIT
              . " seconds, but krang_apachectl is still running.\n";
        }
    }

    # start
    start();
}

if ($command eq 'stop') {
    die "krang_offline stop: httpd not running\n" unless $offline_pid;

    if (kill 15, $offline_pid) {
        print "krang_offline stop: httpd stopped\n";
        exit;
    } else {
        die "krang_offline stop: httpd could not be stopped\n";
    }
}


usage();

sub usage {
    print <<END;
usage: krang_offline (start|stop|restart|debug)

start      - start httpd
stop       - stop httpd

END
    exit;
}

sub start {
    setup_logs();
    write_conf();
    apply_skin();
    make_offline_pages();

    print "krang_offline $command: starting httpd\n";
    unless (system($httpd)) {
        print "krang_offline $command: httpd started";
        print " (SSL enabled)" if EnableSSL;
        print "\n";
        exit;
    } else {
        die "krang_offline $command: httpd could not be started\n";
    }
}

sub make_offline_pages {
    require HTML::Template;
    # find template file, looking addons first then in the root
    my $file = pkg('File')->find("templates/offline.tmpl");

    foreach my $instance (pkg('Conf')->instances) {
        pkg('Conf')->instance($instance);
        my $template = HTML::Template->new(
            filename          => $file,
            global_vars       => 1,
            die_on_bad_params => 0,
        );
        my %params = (
            InstanceName        => $instance,
            InstanceDisplayName => scalar pkg('Conf')->get('InstanceDisplayName'),
            CustomCSS           => scalar pkg('Conf')->get('CustomCSS'),
        );
        $template->param(%params);
        my $out_file = catfile(KrangRoot, 'htdocs', 'offline', "$instance.html");
        open(my $OUT, '>', $out_file) or die "Could not open file $out_file for output: $!";
        print $OUT $template->output;
        close($OUT);
    }
}

sub write_conf {
    require HTML::Template;

    # find template file, looking addons first then in the root
    my $file = pkg('File')->find("conf/httpd_offline.conf.tmpl");

    # create the httpd.conf by processing it as a template, using conf
    # directives as params
    my $template = HTML::Template->new(
        filename          => $file,
        global_vars       => 1,
        die_on_bad_params => 0,
    );

    my $apache_root = rel2abs(catdir(KrangRoot, APACHE_ROOT));
    $template->param(
        ApacheRoot => $apache_root,
        (
            map { ($_, scalar pkg('Conf')->get($_)) } (
                qw(KrangUser KrangGroup
                  ApacheAddr ApachePort
                  HostName
                  RewriteLogLevel
                  )
            )
        ),
        KrangRoot => rel2abs(pkg('Conf')->get("KrangRoot"))
    );

    # SSL
    if (pkg('Conf')->EnableSSL) {
        my %tmpl_params = (EnableSSL => 1);
        foreach my $dir (@ssl_directives) {
            $tmpl_params{$dir} = pkg('Conf')->get($dir) || undef;
        }

        my $verify_client = pkg('Conf')->SSLVerifyClient;

        # we need to verify the client cert unless it's not set or set to 'none'
        if ($verify_client && $verify_client ne 'none') {
            $tmpl_params{SSL_VERIFY_CLIENT} = 1;
        }
        $template->param(%tmpl_params);
    }

    # setup the instance loop
    my @loop;
    foreach my $instance (pkg('Conf')->instances()) {
        pkg('Conf')->instance($instance);
        push(
            @loop,
            {
                InstanceName                    => $instance,
                InstanceHostName                => InstanceHostName(),
                InstanceApacheAddr              => scalar InstanceApacheAddr(),
                InstanceApachePort              => scalar InstanceApachePort(),
                InstanceSSLCertificateFile      => scalar InstanceSSLCertificateFile(),
                InstanceSSLCertificateKeyFile   => scalar InstanceSSLCertificateKeyFile(),
                InstanceSSLCertificateChainFile => scalar InstanceSSLCertificateChainFile(),
                InstanceSSLCACertificateFile    => scalar InstanceSSLCACertificateFile(),
                InstanceSSLCARevocationFile     => scalar InstanceSSLCARevocationFile(),
                InstanceSSLPort                 => scalar InstanceSSLPort(),
            }
        );
    }
    $template->param(InstanceLoop => \@loop);

    # write out the config
    open(CONF, '>' . catfile(KrangRoot, "tmp", "httpd_offline.conf"))
      or die "Unable to open " . catfile(KrangRoot, "tmp", "httpd.conf") . ": $!";
    print CONF $template->output();
    close CONF;
}

# setup the configured skin
sub apply_skin {
    print "Loading configured skin: " . Skin . "\n";
    system(catfile(KrangRoot, 'bin', 'krang_load_skin'), Skin);
}

# make sure logs get created with the right ownership when running as root
sub setup_logs {

    # only worry if we're root
    return if $< != 0 or $> != 0;

    foreach my $log (qw(offline_access_log offline_error_log)) {
        my $file = catfile(KrangRoot, 'logs', $log);
        next if -e $file;

        # create the file and chown it to KrangUser:KrangGroup
        system("touch", $file);
        system("chown", KrangUser . ":" . KrangGroup, $file);
    }
}

