#!/usr/bin/perl 
use warnings;
use strict;

=pod

=head1 NAME

krang_export - export Krang data sets (.kds files)

=head1 SYNOPSIS

Export everything in the system into F<export.kds>:

  $ krang_export --everything

Export just templates and their dependencies into F<export.kds>:

  $ krang_export --templates

Export just a single story (ID: 10) and all it's dependecies to a file
called F<cool_stories.kds>:

  $ krang_export --story_id 10 --output cool_stories.kds

For more options see the OPTIONS section below.

=head1 DESCRIPTION

This script creates a Krang Data Set (.kds) file containing Krang
objects.  This file can then be used with krang_import to load data
into another system.

=head1 OPTIONS

=over 4

=item --output filename.kds

Choose the name of the output file.  Defaults to 'export.kds'.

=item --compress

Turn on kds compression.  If you set this your filename must end in
.kds.gz.

=item --overwrite

Allow --output to overwrite files.  Normally if --output exists the
command fails.

=item --everything

Select all available objects for export.  This includes stories,
media, templates, categories, sites, contribs, users and groups.

=item --stories

=item --media

=item --templates

=item --contribs

=item --categories

=item --sites

=item --users

=item --groups

=item --alerts

=item --list_items

These select all available objects, and their dependencies, for
export.  May not be combined with --everything.

=item --story_id 10

=item --media_id 10 

=item --template_id 10 

=item --contrib_id 10 

=item --category_id 10 

=item --site_id 10

=item --user_id 10

=item --group_id 10

=item --alert_id 10

=item --list_item_id 10

These select a single object by ID, and its dependecies.  May be
repeated multiple times to select multiple objects.

=item --verbose

Prints a running dialog of what's happening.  Repeat (--verbose
--verbose) and you'll be treated to a directory listing of the created
.kds at the end.

=back

=cut

use File::Spec::Functions qw(catdir catfile splitdir rel2abs);
use FindBin qw($RealBin);
use Config;

BEGIN {
    # Find a KRANG_ROOT based on path to bin
    my @dir = splitdir($RealBin);
    $ENV{KRANG_ROOT} ||= catdir(@dir[0 .. $#dir - 1]);

    # use $KRANG_ROOT/lib for modules
    my $lib    = catdir($ENV{KRANG_ROOT}, "lib");
    $ENV{PERL5LIB} = $ENV{PERL5LIB} ? "$ENV{PERL5LIB}:${lib}" : 
      "${lib}";
    unshift @INC, $lib, "$lib/".$Config{archname};

    # load Krang::Conf (don't need to load Krang here because we won't
    # be slinging elements)
    eval { require Krang::Conf };
    warn << "END" and exit(1) if $@;
######################################################################

Cannot load Krang.

Error message:

$@

######################################################################
END
}

use Getopt::Long;
use Pod::Usage;
use Krang::DataSet;

# process args and open the output file before dropping privs
our ($help, $man, $compress, $overwrite, $output, $verbose, 
     %all, %id, $file, $set);
BEGIN { 
    eval {
        $output = 'export.kds';
        $verbose = 0;
        %all = map { ($_, 0) } qw(stories media templates contribs categories 
                                  sites users groups alerts list_items );
        %id  = map { ($_, [])} qw(story_id media_id template_id contrib_id 
                                  category_id site_id user_id group_id 
                                  alert_id list_item_id );

        pod2usage(2) unless
          GetOptions(help       => \$help,
                     man        => \$man,
                     
                     'verbose+' => \$verbose,
                     'compress' => \$compress,
                     'overwrite'=> \$overwrite,
                     
                     'output=s' => \$output,
                     
                     everything => sub { $all{$_} = 1 for keys %all },
                     
                     (map { ($_,    \$all{$_}) } keys %all),
                     (map { ("$_=i", $id{$_})  } keys %id),
                     
                    );
        pod2usage(1)             if $help;
        pod2usage(-verbose => 2) if $man;
        pod2usage("Unrecognized options to krang_export: '" . 
                  join(' ', @ARGV) . "'\n")
          if @ARGV;
        
        # figure out target filename
        $file = $output;
        
        # validate filename
        die "Output filename must end in .kds\n"
          if not $compress and $file !~ /\.kds$/;
        die "Output filename must end in .kds.gz\n"
          if $compress and $file !~ /\.kds.gz$/;
        die "File '$file' exists!  ".
          "Use --overwrite if you want to replace it.\n"
            if -e $file and not $overwrite;
        
        # open up an output filehandle before using Krang::Script and switching
        # privs
        open(OUTPUT, '>', $file) 
          or die "Unable to open '$file' for output: $!\n";
    };

    # output errors without the BEGIN compilation failed message
    if ($@) { 
        warn $@;
        exit(1);
    }
}

use Krang::Script;
use Krang::Story;
use Krang::Media;
use Krang::Template;
use Krang::Contrib;
use Krang::Category;
use Krang::Site;
use Krang::User;
use Krang::ListGroup;
use Krang::List;
use Krang::ListItem;
use Krang::Conf qw(KrangRoot);
use File::Temp qw(tempfile);

# open up the data set
$set = Krang::DataSet->new($verbose ? 
                           (add_callback => \&add_callback) : ());

# keep a count of things added
my $added = 0;

# add all objects for a type?
foreach my $type (grep { $all{$_} } keys %all) {
    $type =~ /ies$/ ? $type =~ s/ies$/y/ : $type =~ /es$/ ? $type =~ s/s$// : $type =~ s/s$//;
    my $class = "Krang::" . ucfirst($type);
    $class = "Krang::ListItem" if ($type eq 'list_item');

    my $id_meth = $type . "_id";
    
    # loop through all objects, 10 at a time
    my $count = $class->find(count => 1);
    for(my $x = 0; $x < $count; $x += 10) {
        my @objects = $class->find(limit => 10, offset => $x);
        for my $object (@objects) {
            $set->add(object => $object);
            $added++;
        }
    }
}

# add by id?
foreach my $id_meth (grep { @{$id{$_}} } keys %id) {
    my $type = $id_meth;
    $type =~ s/_id$//;
    my $class = "Krang::" . ucfirst($type);
    $class = "Krang::ListItem" if ($type eq 'list_item');

    foreach my $id (@{$id{$id_meth}}) {
        my ($object) = $class->find($id_meth => $id);
        die "Unable to find $type $id in database!\n" unless $object;
        $set->add(object => $object);
        $added++;
    }
}

# did we add anything?
die "Nothing selected for export!  Did you mean to use --everything?\n"
  unless $added;


print STDERR "Packing $file...\n" if $verbose;

# write file to a temp location and copy down the OUTPUT pipe.  This
# is necessary if $file can't be written to by KrangUser
my (undef, $temp) = tempfile(DIR    => catdir(KrangRoot, 'tmp'),
                             SUFFIX => '.kds' . ($compress ? '.gz' : ''), 
                            );
$set->write(path => $temp, compress => $compress);

# do a buffered copy from TEMP to OUTPUT
open(TEMP, '<', $temp) or die "Unable to open '$temp': $!\n";
my $buffer = "";
while(read(TEMP, $buffer, 10240)) {
    print OUTPUT $buffer;
}
close TEMP;
close OUTPUT;
unlink $temp or die $!;

print "Export completed.  Output is in $file.\n";

# extra verbose, print a tar directory
system("tar " . ($compress ? 'z' : '') . "tvf $file")
  if $verbose > 1;

exit(0);

sub add_callback {
    my $object = $_[1];
    my $class = ref $object;
    my ($type) = $class =~ /^Krang::(.*)$/;
    my $id_meth = lc($type) . "_id";
    $id_meth = 'list_item_id' if ($id_meth eq 'listitem_id');
    $id_meth = 'list_group_id' if ($id_meth eq 'listgroup_id');

    print STDERR "Adding $type " . $object->$id_meth . " to $file...\n";
}
