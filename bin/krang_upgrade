#!/usr/bin/perl -w
use warnings;
use strict;


# Location of MYSQL init, as per RPM install
use constant MYSQL_INIT => '/etc/init.d/mysql';


# Path to pre-req binaries
use constant MYSQL_BIN      => '/usr/bin/mysql';
use constant GROUPADD_BIN   => '/usr/sbin/groupadd';
use constant USERADD_BIN    => '/usr/sbin/useradd';
use constant USERMOD_BIN    => '/usr/sbin/usermod';
use constant COPY_BIN       => '/bin/cp';
use constant CHOWN_BIN      => '/bin/chown';
use constant CHMOD_BIN      => '/bin/chmod';
use constant XARGS_BIN      => '/usr/bin/xargs';
use constant FIND_BIN       => '/usr/bin/find';
use constant SH_BIN         => '/bin/sh';
use constant MAKE_BIN       => '/usr/bin/make';
use constant RM_BIN         => '/bin/rm';
use constant ECHO_BIN       => '/bin/echo';
use constant TAR_BIN        => '/bin/tar';
use constant RPM_BIN        => '/bin/rpm';
use constant IFCONFIG_BIN   => '/sbin/ifconfig';
use constant CAT_BIN        => '/bin/cat';
use constant CHKCONFIG_BIN  => '/sbin/chkconfig';
use constant LN_BIN         => '/bin/ln';

use constant MYSQLADMIN_BIN => '/usr/bin/mysqladmin';
use constant PERL_BIN       => '/usr/bin/perl';
use constant DU_BIN         => '/usr/bin/du';
use constant DF_BIN         => '/bin/df';
use constant CP_BIN         => '/bin/cp';


=head1 NAME

krang_upgrade - upgrade Krang from a dist file


=head1 SYNOPSIS

  $ krang_upgrade


=head1 DESCRIPTION

This script will upgrade Krang on a RedHat 7.3 (i686-linux) 
system from a dist file created by krang_makedist.



=head2 What C<krang_upgrade> does

Following is a list of the tasks the upgrade script will perform.


=over 4

=item Check pre-requisites

=over 4

=item Validate path to KRANG_ROOT.

=item Verify that no backup KRANG_ROOT exists.

=item Verify that no backup MySQL instance databases exist

=item Locate and parse existing krang.conf file.

=item Verify sufficient disk space

=over 4

=item Required space = KRANG_ROOT + Instance MySQL folders

=back

=item Verify that Krang has been shut down.

=item MySQLRootPassword must be valid, and MySQL should be running


=back



=item Rename existing KRANG_ROOT to KRANG_ROOT + '.backup'.

=item Copy existing Krang MySQL database folders to folder + '.backup'.

=item Install new Krang system to KRANG_ROOT.

=item Copy krang.conf, data/* from backup to new KRANG_ROOT.

=item Apply upgrade scripts.

=over 4

=item E.g., "KRANG_ROOT/upgrade/V1_2.pm"

=item Run class methods C<per_installation()> and C<per_instance()>

=back

=item Update db_version for each instance

=item Clear out sessions from database.

=item Start Krang, and 'make test' on new system.

=over 4

=item If failure, recommend C<krang_upgrade --rollback>

=back


=item Output results of upgrade to console.

=over 4

=item Show rollback directory paths for KRANG_ROOT and database

=back

=back




=head2 What C<krang_upgrade --rollback> does

The following tasks will roll back an upgrade to the previously installed state.

=over 4

=item Replace KRANG_ROOT with KRANG_ROOT + '.backup'

=item Replace Krang MySQL database folder with MySQL database folder + '.backup'

=item Re-start Krang


=back



=head1 OPTIONS

  --help                 - Show usage
  --man                  - Show full man page

=head2 Optional parameters

  --KrangRoot            - Directory where Krang is installed (KRANG_ROOT)
  --MySQLRootPassword    - Password for the MySQL user "root"
  --AdminPassword        - CMS "admin" user password -- needed for tests


=head2 Upgrade flags

  --no-krang-test        - Skip Krang "make test"
  --rollback             - Revert to last backup


=head1 SEE ALSO

Refer to F<docs/ops_upgrade.pod>.

=cut



use File::Spec::Functions qw(catdir catfile splitdir rel2abs);
use FindBin qw($RealBin);
use Config;


# Set up KRANG_ROOT and PERL5LIB
BEGIN {
    # Find a KRANG_ROOT based on path to bin
    my @dir = splitdir($RealBin);
    $ENV{KRANG_ROOT} ||= catdir(@dir[0 .. $#dir - 1]);

    # use $KRANG_ROOT/lib for modules
    my $lib    = catdir($ENV{KRANG_ROOT}, "lib");
    $ENV{PERL5LIB} = $ENV{PERL5LIB} ? "$ENV{PERL5LIB}:${lib}" :
      "${lib}";
    unshift @INC, $lib, "$lib/".$Config{archname};
}

use Krang;
use Getopt::Long;
use Pod::Usage;
use Config::ApacheFormat;


my @original_args = ();
my $uniqueness = time();
my %instance_dbs = ();
my $mysql_datadir;
my $OLD_CONF;


my ($help, $man, $no_krang_test, $rollback);

my @opt_params = qw( KrangRoot MySQLRootPassword AdminPassword );

my %options = ( map { $_ => "" } @opt_params);

do_upgrade();
exit(0);


################################
####  MAKE UPGRADE METHODS  ####
################################

sub do_upgrade {
    setup_getopts();

    # Check all pre-requisites for upgrade or rollback
    check_prereqs();

    if ($rollback) {
        do_rollback();
    } else {
        # Do upgrade
        make_backups();
        install_new_krang();
        copy_data();
        apply_upgrades();
        update_db_version();
        clear_sessions();
    }

    start_krang();
    make_test() unless ($no_krang_test);
    output_report();
}


sub check_prereqs {
    print "Checking prerequisites\n";

    # Must be running as root.
    exit_error("Must be run as root.") unless ($> eq "0");

    # Can't test unless we have AdminPassword
    unless ($no_krang_test || $options{AdminPassword}) {
        exit_error("Must specify AdminPassword, or disable Krang tests (via --no-krang-test).  Cannot continue.");
    }

    # Validate path to KRANG_ROOT.
    my $KrangRoot = $options{KrangRoot};
    unless (-e $KrangRoot) {
        exit_error("KrangRoot '$KrangRoot' does not exists.  Cannot continue.");
    }

    # Does krang.conf exist at that location?
    my $krang_conf = $KrangRoot ."/conf/krang.conf";
    unless (-r $krang_conf) {
        exit_error("'$krang_conf' does not exists.  Cannot continue.");
    }

    # LOAD OLD KRANG_CONF
    # Start by getting old conf valid directives
    my $get_directives_perl = qq( print join("\\t", \@Krang::Conf::VALID_DIRECTIVES). "\\n"; );
    my $get_directives_cmd = "KRANK_CONF_NOCHECK=1 KRANG_CONF=$krang_conf ". PERL_BIN;
    $get_directives_cmd .= " -MKrang::Conf -e '$get_directives_perl' && echo \"Success $uniqueness\"";

    my $get_directives_output = `$get_directives_cmd`;

    unless ($get_directives_output =~ /Success\ $uniqueness/) {
        print STDERR $get_directives_output;
        exit_error("Error getting valid directives.  Cannot continue.");
    }

    # Trim off the last line
    my ($get_directives_output_line1) = split(/\n/, $get_directives_output);

    my @old_valid_directives = ();
    foreach my $dir (split(/\t/, $get_directives_output_line1)) {
        push(@old_valid_directives, $dir);
    }


    eval {
        $OLD_CONF = Config::ApacheFormat->new( valid_directives => \@old_valid_directives,
                                               valid_blocks => ['instance'] );
        $OLD_CONF->read($krang_conf);
    };
    exit_error("Unable to read config file '$krang_conf'.  Error was: $@")
      if $@;
    exit_error("Unable to read config file '$krang_conf'.")
      unless $OLD_CONF;

    # Verify that this Krang has been shut down.
    # get status from the pid file
    my $pid_file = catfile($KrangRoot, "tmp", "httpd.pid");
    my $running = 0;
    my $pid;
    if (-e $pid_file) {
        $pid = `cat $pid_file`;
        chomp $pid;
        if ($pid and kill(0, $pid)) {
            $running = 1;
        }
    }
    exit_error ("Krang is still running.  You must shut down Krang before upgrading.")
      if ($running);

    # MySQLRootPassword must be valid, and MySQL should be running
    my $mysql_bin = MYSQL_BIN;
    my $MySQLRootPassword = $options{'MySQLRootPassword'};
    my $test_mysql = ECHO_BIN ." 'select \"world\" as hello' | $mysql_bin -uroot";
    $test_mysql .= " -p$MySQLRootPassword" if (length($MySQLRootPassword));
    $test_mysql .= " 2>&1";
    my $mysql_test_output = `$test_mysql`;

    unless (($mysql_test_output =~ /hello/) and ($mysql_test_output =~ /world/)) {
        print STDERR "$mysql_test_output";
        if ($mysql_test_output =~ /ERROR 1045: Access denied/) {
            exit_error("MySQLRootPassword '$MySQLRootPassword' is not valid");
        } elsif ($mysql_test_output =~ /ERROR 2002: Can\'t connect/) {
            exit_error("Can't connect to MySQL.  Start MySQL and try again.");
        } else {
            exit_error("Unable to verify MySQLRootPassword.");
        }
    }

    # Get MySQL datadir
    my $mysql_datadir_cmd = MYSQLADMIN_BIN ." -uroot";
    $mysql_datadir_cmd .= " -p". $MySQLRootPassword if (length($MySQLRootPassword));
    $mysql_datadir_cmd .= " variables";
    my $mysql_datadir_output = `$mysql_datadir_cmd`;
    unless ($mysql_datadir_output =~ /\s+datadir\s+\|\s+(\S+)\s+/) {
        exit_error("Can't get datadir from MySQL.  Cannot continue.");
    }
    $mysql_datadir = $1;
    print "  MySQL data directory: '$mysql_datadir'\n";

    #
    # Check pre-reqs differently for upgrades and rollbacks
    #
    if ($rollback) {

        # Verify that backup KRANG_ROOT exists.
        my $krang_root_backup = $KrangRoot .".backup";
        exit_error("$krang_root_backup does not exist.  Cannot continue.")
          unless (-e $krang_root_backup);

        # Verify that backup exists for instance databases.  Parse out instances and databases for later.
        foreach my $instpair ($OLD_CONF->get("instance")) {
            my $instance = $instpair->[1];
            my $conf_block = $OLD_CONF->block(instance => $instance);
            my $db = $conf_block->get("InstanceDBName");
            $instance_dbs{$instance} = $db;

            my $mysql_instance_datadir_backup = $mysql_datadir . $db .".backup";
            exit_error("$mysql_instance_datadir_backup does not exist.  Cannot continue.")
              unless (-e $mysql_instance_datadir_backup);
        }

        # No Instances?
        exit_error("No instances found.  Unable to continue.") unless (keys(%instance_dbs));

        print "  Found instances: ". 
          join(", ", (map { "$_ (". $instance_dbs{$_} .")" } sort(keys(%instance_dbs)))) ."\n";
    
    } else {

        # Verify that no backup KRANG_ROOT exists.
        my $krang_root_backup = $KrangRoot .".backup";
        exit_error("$krang_root_backup already exists.  You must remove this before you perform an upgrade.")
          if (-e $krang_root_backup);

        # Verify that no .backup exists for instance databases.  Parse out instances and databases for later.
        foreach my $instpair ($OLD_CONF->get("instance")) {
            my $instance = $instpair->[1];
            my $conf_block = $OLD_CONF->block(instance => $instance);
            my $db = $conf_block->get("InstanceDBName");
            $instance_dbs{$instance} = $db;

            my $mysql_instance_datadir_backup = $mysql_datadir . $db .".backup";
            exit_error("$mysql_instance_datadir_backup already exists.  You must remove this before you perform an upgrade.")
              if (-e $mysql_instance_datadir_backup);
        }

        # No Instances?
        exit_error("No instances found.  Unable to continue.") unless (keys(%instance_dbs));

        print "  Found instances: ". 
          join(", ", (map { "$_ (". $instance_dbs{$_} .")" } sort(keys(%instance_dbs)))) ."\n";
    
        # Calculate necessary disk space
        my @curr_krang_paths = ( $KrangRoot, (map { $mysql_datadir . $_ } values(%instance_dbs)) );
        my %path_info = ();
        my %disk_avail = ();
        foreach my $path (@curr_krang_paths) {
            my $get_du = DU_BIN ." -sk $path";
            my $du = `$get_du`;
            exit_error ("Can't get disk usage for $path:  $du")
              unless ($du =~ /^(\d+)\s+$path/);
            $path_info{$path}->{du} = $1;

            my $get_df = DF_BIN ." -k $path";
            my $df = `$get_df`;
            $df = (split/\n/, $df)[-1];
            my (@df_data) = split(/\s+/, $df);

            exit_error ("Can't get df for $path:  $df")
              unless (@df_data);

            $path_info{$path}->{partition} = $df_data[5];
            $disk_avail{$df_data[5]} = $df_data[3] unless (exists($disk_avail{$df_data[5]}));
        }

        # Verify sufficient disk space: KRANG_ROOT + Instance MySQL folders
        foreach my $path (@curr_krang_paths) {
            my $req_kbytes = $path_info{$path}->{du};
            my $partition = $path_info{$path}->{partition};

            # Subtract space on partition
            $disk_avail{$partition} -= $req_kbytes;
        }

        my $insufficient_disk_space = 0;
        while (my ($partition, $avail) = each(%disk_avail)) {
            # Require 100 megs of headroom on every partition
            next if ($avail > 100000);

            my $need_additional = abs($avail - 100000);
            print "  Insufficient space on partition '$partition'.  Need additional $need_additional kb.\n";
            $insufficient_disk_space++;
        }
        exit_error ("Not enough disk space for upgrade.  Unable to continue.") if ($insufficient_disk_space);
    }

    ## End of prereq check
}


sub make_backups {
    print "Making backups\n";

    ## Rename KRANG_ROOT to *.backup
    #
    my $KrangRoot = $options{KrangRoot};
    print "  Moving KrangRoot to ". $KrangRoot .".backup\n";
    rename($KrangRoot, $KrangRoot.".backup") || die($!);

    ## Copy MySQL directories to *.backup
    #
    # Shutdown MySQL
    print "  Shutting down MySQL\n";
    my $mysql_init = MYSQL_INIT ." stop";
    system($mysql_init) && die("Error shutting down MySQL");

    # Delay for MySQL shutdown
    sleep(2);

    # Iterate through instances, making .backup files
    foreach my $db (values(%instance_dbs)) {
        my $db_path = $mysql_datadir . $db;
        my $db_backup = $db_path . ".backup";

        print "  Copying $db_path to $db_backup\n";
        my $cp_cmd = CP_BIN ." -a $db_path $db_backup";
        system($cp_cmd) && die("$cp_cmd\nError copying $db_path: $!");
    }

    # Re-start MySQL
    print "  Restarting MySQL\n";
    $mysql_init = MYSQL_INIT ." start";
    system($mysql_init) && die("Error starting MySQL");

    # Delay for MySQL startup
    sleep(2);
}


sub do_rollback {
    print "Restoring from backups\n";

    ## Rename KRANG_ROOT to *.backup
    #
    my $KrangRoot = $options{KrangRoot};
    my $KrangRootBackup = $KrangRoot .".backup";
    print "  Deleting $KrangRoot";
    my $rm_cmd = RM_BIN ." -rf $KrangRoot";
    system($rm_cmd) && die("Can't delete $KrangRoot: $!");

    print "  Moving $KrangRootBackup to $KrangRoot\n";
    rename($KrangRootBackup, $KrangRoot) || die($!);

    ## Copy MySQL directories to *.backup
    #
    # Shutdown MySQL
    print "  Shutting down MySQL\n";
    my $mysql_init = MYSQL_INIT ." stop";
    system($mysql_init) && die("Error shutting down MySQL");

    # Delay for MySQL shutdown
    sleep(2);

    # Iterate through instances, making .backup files
    foreach my $db (values(%instance_dbs)) {
        my $db_path = $mysql_datadir . $db;
        my $db_backup = $db_path . ".backup";

        print "  Deleting $db_path";
        my $rm_cmd = RM_BIN ." -rf $db_path";
        system($rm_cmd) && die("Can't delete $db_path: $!");

        print "  Moving $db_backup to $db_path\n";
        rename($db_backup, $db_path) || die($!);
    }

    # Re-start MySQL
    print "  Restarting MySQL\n";
    $mysql_init = MYSQL_INIT ." start";
    system($mysql_init) && die("Error starting MySQL");

    # Delay for MySQL startup
    sleep(2);
}


sub install_new_krang {
    my $new_krang = $ENV{KRANG_ROOT};
    my $InstallPath = $options{KrangRoot};
    mkdir($InstallPath) || die($!);

    print "Installing new Krang files into '$InstallPath'\n";

    chdir($ENV{KRANG_ROOT});
    my $copy = COPY_BIN ." -r * $InstallPath\/";
    system($copy) && die("Can't copy: $!");

    print "  Fixing ownership\n";
    my $KrangUser = $OLD_CONF->get("KrangUser");
    my $KrangGroup = $OLD_CONF->get("KrangGroup");
    my $chown = CHOWN_BIN ." -R $KrangUser\.$KrangGroup $InstallPath";
    system($chown) && die("Can't update ownership: $!");

    # For commands
    my $chmod;

    print "  Setting group write permissions\n";
    $chmod = CHMOD_BIN ." -R g+w $InstallPath";
    system($chmod) && die("Can't set group write permissions: $!");

    print "  Fixing directory read permissions\n";
    $chmod = FIND_BIN ." $InstallPath -type d | ". XARGS_BIN ." ". CHMOD_BIN ." +rx";
    system($chmod) && die("Can't fix directory read permissions: $!");

    print "  Fixing file read permissions\n";
    $chmod = FIND_BIN ." $InstallPath -type f | ". XARGS_BIN ." ". CHMOD_BIN ." +r";
    system($chmod) && die("Can't fix file read permissions: $!");

    print "  Setting execute bits on scripts\n";

    # Set all *.pl files
    $chmod = FIND_BIN ." $InstallPath -type f -name '*.pl' | ". XARGS_BIN ." ". CHMOD_BIN ." +x";
    system($chmod) && die("Can't set execite bits: $!");

    # Set all *.cgi files
    $chmod = FIND_BIN ." $InstallPath -type f -name '*.cgi' | ". XARGS_BIN ." ". CHMOD_BIN ." +x";
    system($chmod) && die("Can't set execite bits: $!");

    # Set all files in krang/bin/*
    $chmod = CHMOD_BIN ." +x $InstallPath/bin/*";
    system($chmod) && die("Can't set execite bits: $!");

    print "  Krang files installed.\n";
}


# Copy krang.conf, data/* from backup to new KRANG_ROOT.
sub copy_data {
    print "Copying settings and data from old installation\n";

    my $KrangPath    = $options{KrangRoot};
    my $OldKrangPath = $KrangPath .".backup";

    # Copy krang.conf
    my $old_conf = $OldKrangPath ."/conf/krang.conf";
    my $new_conf = $KrangPath    ."/conf/krang.conf";
    print "  Copying $old_conf to $new_conf\n";
    my $conf_cp_cmd = CP_BIN ." -af $old_conf $new_conf";
    system($conf_cp_cmd) && die("Error copying krang.conf: $!");

    # Copy data/*
    my $old_data = $OldKrangPath ."/data";
    my $new_data = $KrangPath;
    print "  Copying $old_data to $new_data\n";
    my $data_cp_cmd = CP_BIN ." -af $old_data $new_data";
    system($data_cp_cmd) && die("Error copying data/ directory: $!");
}


# Run through upgrade module per_installation() and per_instance() methods.
sub apply_upgrades {
    print "Applying upgrades\n";

    my $KrangRoot = $options{KrangRoot};

    my $old_krang_version = get_krang_version($KrangRoot .".backup");
    my $new_krang_version = get_krang_version($KrangRoot);
    print "  Upgrading v$old_krang_version to v$new_krang_version\n";

    # Find upgrade modules
    my $upmod_path = $KrangRoot ."/upgrade/";
    print "  Upgrade path: $upmod_path\n";
    opendir(DIR, $upmod_path) || die ("Unable to open upgrade directory '$upmod_path': $!");
    my @upmodules = (grep {
        (-f $upmod_path.$_) && (/^V(\d+)\_(\d+)\.pm$/) && ( "$1.$2" > $old_krang_version )
      } readdir(DIR));
    closedir(DIR);

    print "  Found ".scalar(@upmodules)." applicable upgrade modules.\n";
    print "    ". join("\n    ", @upmodules) ."\n" if (@upmodules);

    # Run upgrade modules
    my $perl5lib = $KrangRoot ."/upgrade:" . $KrangRoot ."/lib";
    foreach my $module (@upmodules) {
        # Get package name by trimming off ".pm"
        my $package = $module;
        $package =~ s/\.pm$//;

        my $upgrade_cmd = "KRANG_ROOT=$KrangRoot PERL5LIB=$perl5lib ". PERL_BIN;
        $upgrade_cmd .= " -M$package -e 'my \$ug = $package->new(); \$ug->upgrade()'";
        system($upgrade_cmd) && die("Error using upgrade module '$module'");
    }
    
}


sub update_db_version {
    my $KrangRoot = $options{KrangRoot};
    my $new_krang_version = get_krang_version($KrangRoot);
    print "Updating db_version to $new_krang_version\n";

    # Iterate through instances, making .backup files
    while (my ($instance, $db) = each(%instance_dbs)) {
        print "  Updating $instance ($db)\n";
        my $mysql_bin = MYSQL_BIN;
        my $MySQLRootPassword = $options{'MySQLRootPassword'};
        my $update_db_version_cmd = "$mysql_bin -uroot";
        $update_db_version_cmd .= " -p$MySQLRootPassword" if (length($MySQLRootPassword));
        $update_db_version_cmd .= " -e 'update db_version set db_version=$new_krang_version' $db";
        system($update_db_version_cmd) && exit_error("Error updating db_version");
    }
}


sub clear_sessions {}


sub start_krang {
    my $HostName   = $OLD_CONF->get("HostName");
    my $init_script = "krang-". $HostName .".init";
    print "Starting Krang via init.d script '$init_script'\n";
    my $start = "KRANG_ROOT='' PERL5LIB='' /etc/init.d/$init_script start";
    system($start) && die("Can't start Krang: $!");
}


sub make_test {
    print "Running Krang tests...\n";

    my $AdminPassword = $options{AdminPassword};

    my $InstallPath = $options{KrangRoot};
    chdir($InstallPath);

    my $make_bin = MAKE_BIN;
    my $make_test = "KRANG_ROOT='' PERL5LIB='' KRANG_PASSWORD='$AdminPassword' $make_bin test";
    system($make_test) && die("Error running tests: $!");
}


sub output_report {
    my $KrangRoot = $options{KrangRoot};

    my $HostName   = $OLD_CONF->get("HostName");
    my $IPAddress  = $OLD_CONF->get("ApacheAddr");
    my $ApachePort = $OLD_CONF->get("ApachePort");
    my $FTPPort    = $OLD_CONF->get("FTPPort");

    my $init_script = "/etc/init.d/krang-". $HostName .".init";
    my $krang_conf = $KrangRoot ."/conf/krang.conf";

    my $AdminPassword = $options{AdminPassword};

    my $report_title = ($rollback) ? "KRANG ROLLBACK COMPLETE" : "KRANG UPGRADE COMPLETE " ;

    print <<EOREPORT;


#####                                                    #####
###                                                        ###
##                  $report_title                 ##
###                                                        ###
#####                                                    #####


   Krang root path     :  $KrangRoot
   Startup init script :  $init_script
   Krang conf file     :  $krang_conf

   Running on $IPAddress --
     http://$HostName:$ApachePort/
     ftp://$HostName:$FTPPort/

EOREPORT

    # Print the admin password if we know it
    if ($AdminPassword) {
        print "   CMS admin user password:  \"AdminPassword\"\n\n\n";
    } 

}





###########################
####  PRIVATE METHODS  ####
###########################

sub exit_error {
    my $cmd = $0;
    $cmd =~ s/.*\/(.+)$/$1/;

    my $message = shift;
    print STDERR "\nError: $cmd:  $message\n\n";
    exit(1);
}


sub setup_getopts {
    # Copy the original args for re-invoking later
    @original_args = @ARGV;

    pod2usage(2) unless
        GetOptions( 'help'          => \$help,
                    'man'           => \$man,
                    'no-krang-test' => \$no_krang_test,
                    'rollback'      => \$rollback,
                    (map { $_."=s"  => \$options{$_} } @opt_params) );

    pod2usage(1)             if $help;
    pod2usage(-verbose => 2) if $man;

    # Set opt defaults
    set_param_defaults();
}


sub set_param_defaults {
    my %defaults = (
                    KrangRoot => '/usr/local/krang',
                    MySQLRootPassword => '',
                   );

    # Set up defaults if value is not otherwise set
    while (my ($k, $dv) = each(%defaults)) {
        # Skip if value already defined
        next if (length($options{$k}));

        # Set default
        $options{$k} = $dv;
    }

}


# Get the version of Krang installed in a particular KRANG_ROOT
sub get_krang_version {
    my $KrangRoot = shift;

    my $perl5lib = $KrangRoot ."/lib";

    my $get_version_perl = qq( print \$Krang::VERSION. "\\n"; );
    my $get_version_cmd = "PERL5LIB=$perl5lib ". PERL_BIN;
    $get_version_cmd .= " -MKrang -e '$get_version_perl' && echo \"Success $uniqueness\"";

    my $get_version_output = `$get_version_cmd`;

    unless ($get_version_output =~ /Success\ $uniqueness/) {
        print STDERR $get_version_output;
        exit_error("Error getting Krang version in $KrangRoot.  Cannot continue.");
    }

    # Trim off the last line
    my ($get_version_output_line1) = split(/\n/, $get_version_output);
    chomp($get_version_output_line1);

    return $get_version_output_line1;
}



###############
####  EOF  ####
###############
