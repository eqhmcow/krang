package Krang::CGI::ElementEditor;
use strict;
use warnings;

=head1 NAME

Krang::CGI::ElementEditor - element editor CGI class

=head1 SYNOPSIS

  http://krang/instance_name/element_editor

=head1 DESCRIPTION

Element editor CGI for Krang.  This CGI is embedded in the Story and
Category editors.  It allows users to edit the contents of the element
tree attached to the story or category.

=head1 INTERFACE

None.

=cut

use Krang::ElementLibrary;
use Krang::Element;
use Krang::DB qw(dbh);
use Carp qw(croak);
use Krang::Session qw(%session);

use base 'Krang::CGI';

sub setup {
    my $self = shift;
    $self->start_mode('choose_top_level');
    $self->mode_param('e_rm');
    $self->run_modes(choose_top_level => \&choose_top_level,
                     create           => \&create,
                     edit             => \&edit,
                     add              => \&add,
                     save             => \&save,
                     save_and_jump    => \&save_and_jump,
                     save_and_stay    => \&save_and_stay,
                     delete           => \&delete,
                     reorder          => \&reorder,
                    );
}

# show the top_level chooser (this won't be used in the final version
# of the editor, but it's need to allow it to be tested independently)
sub choose_top_level {
    my $self = shift;
    my $query = $self->query();
    my $dbh = dbh();
    my $template = $self->load_tmpl("element_editor_choose.tmpl",
                                    associate => $query);

    # whip up top level picker
    my @values = Krang::ElementLibrary->top_levels;
    my %labels = map { ($_, Krang::ElementLibrary->top_level(name => $_)
                                                  ->display_name) } 
                   @values;
    $template->param(top_level_select => 
                     $query->popup_menu(-name   => "top_level",
                                        -values => \@values,
                                        -labels => \%labels));

    # show a list of existing elements
    my $result = $dbh->selectall_arrayref('SELECT root_id, class FROM element WHERE parent_id IS NULL ORDER BY root_id');
    my @element_loop;
    foreach my $row (@$result) {
        push(@element_loop, { element_id => $row->[0],
                              name       => $row->[1] });
    }
    $template->param(element_loop => \@element_loop);


    return $template->output();
}

# create a new top-level element
sub create {
    my $self      = shift;
    my $query     = $self->query();
    my $top_level = $query->param("top_level") 
      or croak("Missing top_level param!");

    # create a new instance and save it in the session
    my $element = Krang::Element->new(class => $top_level);
    $session{root_element} = $element;

    # setup ids and toss to edit
    $query->param(path => '');
    $query->param(root_id => undef);
    return $self->edit;
}


# show the edit screen
sub edit {
    my $self = shift;
    my $query = $self->query();
    my $template = $self->load_tmpl("element_editor_edit.tmpl",
                                    associate => $query,
                                    loop_context_vars => 1);

    my $path = $query->param('path');
    my $root_id = $query->param('root_id');

    # find the root element, loading from the session or the DB
    my $root;
    if (defined $root_id) {
        $session{root_element} = 
          $root = Krang::Element->find(element_id => $root_id);        

        croak("Unable to load element from DB by id '$root_id'")
          unless defined $root;
        $query->param(root_id => undef);
    } else {
        $root = $session{root_element};
        croak("Unable to load element from session.") 
          unless defined $root;
    }

    # find the element being edited using path, build up @crumbs along the way
    my @crumbs;
    my $element = _find_element($root, $path, \@crumbs);
    $template->param(crumbs => \@crumbs);

    # can I get back from here?
    $template->param(return_path => @crumbs > 1 ? $crumbs[-2]{path} : "");

    # load invalid list, generated by save()
    my %invalid;
    %invalid = map { ($_ => 1) } (split(',', $query->param('invalid')))
      if $query->param('invalid');

    my @child_loop;
    my $index = 0;
    my $order;
    my @children = $element->children;
    
    # figure out list of slots that are reorderable
    my @avail_ord = grep { $children[$_-1]->reorderable } (1 .. @children);
        
    foreach my $child (@children) {        
        push(@child_loop, {
                           form         => $child->input_form(query => $query,
                                                              order => $index),
                           name         => $child->display_name(),
                           ($child->reorderable ? 
                            (order_select =>
                             $query->popup_menu(-name => "order_$index",
                                                -values => \@avail_ord,
                                                -default => $index + 1)) : ()),
                           is_container => $child->is_container,
                           index        => $index,
                           reorderable  => $child->reorderable,
                           allow_delete => $child->allow_delete,
                           invalid       => $invalid{$index},
                          });
        $index++;
    }
    $template->param(child_loop => \@child_loop);

    # whip up top level picker
    my @available =  $element->available_child_classes();
    my @values = map { $_->name } @available;
    my %labels = map { ($_->name, $_->display_name) } @available;
    $template->param(child_select => 
                     $query->popup_menu(-name   => "child",
                                        -values => \@values,
                                        -labels => \%labels));


    return $template->output();    
}


# add sub-elements
sub add {
    my $self = shift;
    my $query = $self->query();

    # gather params
    my $path    = $query->param('path');
    my $child   = $query->param('child');

    # find our element
    my $root    = $session{element_root};
    my $element = _find_element($root, $path);

    # add the child element and save the element tree
    $element->add_child(class => $child);

    # toss to edit
    return $self->edit();
}

# finds an element given the root and a path, optionally building @crumbs loop
sub _find_element {
    my ($element, $path, $crumbs) = @_;
    push(@$crumbs, { path => '',
                     name => $element->display_name })
      if $crumbs;

    # no path means the element is the root
    return $element unless defined $path;

    # otherwise, split up the path and locate the elements
    my @path = split(',', $path);
    my ($index, @path_back);
    while(@path) {
        $index = shift(@path);
        $element = $element->children()->[$index];
        if ($crumbs) {
            push @path_back, $index;
            push(@$crumbs, { path => join(',',@path_back),
                             name => $element->display_name });
        }
    } 

    return $element;
}

sub save_and_stay {
    my $self = shift;
    return $self->save(stay => 1);
}

sub save_and_jump {
    my $self = shift;
    my $query = $self->query();
    return $self->save(jump_to => $query->param("jump_to"));
}

sub save {
    my $self = shift;
    my %arg = @_;
    my $query = $self->query();
    my $template = $self->load_tmpl("element_editor_edit.tmpl",
                                    associate => $query,
                                    loop_context_vars => 1);

    my $path = $query->param('path');
    my $root_id = $query->param('root_id');

    my $root = Krang::Element->find(element_id => $root_id);    
    my $element = _find_element($root, $path);

    # validate data
    my @msgs;
    my $clean = 1;
    my $index = 0;
    my @invalid;
    foreach my $child ($element->children()) {
        my ($valid, $msg) = $child->validate(query => $query);
        if (not $valid) {
            push @msgs, "* $msg";
            push @invalid, $index;
            $clean = 0;
        }
        $index++;
    }

    # toss back to edit with an error message if not clean
    if (not $clean) {
        my %seen;
        $query->param(alert => join('<br>', grep { ++$seen{$_} == 1 } @msgs));
        $query->param(invalid => join(',', @invalid));
        return $self->edit();
    }

    # save data
    $index = 0;
    foreach my $child ($element->children()) {
        $child->load_query_data(query => $query);
        $index++;
    }

    # save element tree
    $root->save();
    $query->param(alert => $element->display_name() . " saved.");

    # save and stay?
    return $self->edit() if exists $arg{stay};

    # save and jump?
    if (exists $arg{jump_to}) {
        $query->param(path => $arg{jump_to});
        return $self->edit();
    }
                      

    # go up a level
    if (defined $path and length $path) {
        my @path = split(',', $path);
        pop @path;
        $path = join(',', @path);
        $query->param(path => $path);
        return $self->edit();
    } else {
        return $self->choose_top_level();
    }
}

# reorder sub-elements
sub reorder {
    my $self = shift;
    my $query = $self->query();
    my $template = $self->load_tmpl("element_editor_edit.tmpl",
                                    associate => $query,
                                    loop_context_vars => 1);

    my $path = $query->param('path');
    my $root_id = $query->param('root_id');

    my $root = Krang::Element->find(element_id => $root_id);    
    my $element = _find_element($root, $path);

    # compute new list of children
    my @new_children;
    my @old_children = $element->children();
    my @msgs;
    for my $index (0 .. @old_children - 1) {
        if ($query->param("order_$index")) {
            my $requested_index = $query->param("order_$index");
            # deal with collisions
            while(defined $new_children[$requested_index]) {
                $requested_index++;
            }
            $new_children[$requested_index] = $old_children[$index];
            $query->delete("order_$index");
        } else {
            push @new_children, $old_children[$index];            
        }
    }
    # compress empty space
    @new_children = grep { defined $_ } @new_children;

    # save list
    $element->children(@new_children);
    $root->save();

    # toss to edit
    return $self->edit();    
}

# delete sub-elements
sub delete {
    my $self = shift;
    my $query = $self->query();
    my $template = $self->load_tmpl("element_editor_edit.tmpl",
                                    associate => $query,
                                    loop_context_vars => 1);

    my $path = $query->param('path');
    my $root_id = $query->param('root_id');

    my $root = Krang::Element->find(element_id => $root_id);    
    my $element = _find_element($root, $path);

    # compute new list of children
    my @new_children;
    my @old_children = $element->children();
    my @msgs;
    for my $index (0 .. @old_children - 1) {
        if ($query->param("remove_$index")) {
            push @msgs, "Removed " . $old_children[$index]->display_name;
            $query->delete("remove_$index");
        } else {
            push @new_children, $old_children[$index];            
        }
    }
    # save list
    $element->children(@new_children);
    $root->save();

    # generate alert and toss to save
    @msgs = ('No elements marked for deletion!') unless @msgs;
    $query->param(alert => join('<br>', @msgs));
    return $self->edit();
}


1;
