#!/usr/bin/perl -w
use warnings;
use strict;
use IO::Socket;

# Path to pre-req binaries
use constant MYSQL_BIN      => '/usr/bin/mysql';
use constant PERL_BIN       => 'perl';
use constant GROUPADD_BIN   => '/usr/sbin/groupadd';
use constant USERADD_BIN    => '/usr/sbin/useradd';
use constant USERMOD_BIN    => '/usr/sbin/usermod';
use constant COPY_BIN       => '/bin/cp';
use constant CHOWN_BIN      => '/bin/chown';
use constant CHMOD_BIN      => '/bin/chmod';
use constant XARGS_BIN      => '/usr/bin/xargs';
use constant FIND_BIN       => '/usr/bin/find';
use constant MAKE_BIN       => '/usr/bin/make';
use constant ECHO_BIN       => '/bin/echo';
use constant TAR_BIN        => '/bin/tar';
use constant IFCONFIG_BIN   => '/sbin/ifconfig';
use constant CHKCONFIG_BIN  => '/sbin/chkconfig';
use constant LN_BIN         => '/bin/ln';

$|++;

=head1 NAME

krang_install - install Krang from a dist file


=head1 SYNOPSIS

  $ krang_install


=head1 DESCRIPTION

This script will install Krang on a RedHat 7.3 or Redhat 9
(i686-linux) system from a dist file created by krang_makedist.

It can also install Krang from a backup file created by krang_backup.
For more on this topic, see C<docs/ops_backup.pod>.


=head2 What C<krang_install> does

Following is a list of the tasks the installer script will perform.


=over 4

=item Check pre-requisites


=over 4

=item Must be running as root.

=item IP address must be configured on host.

=item InstanceElementSet must exist

=item Check for proper version of MySQL.


=item MySQLRootPassword must be valid for this box


=item Check for proper version of Perl.


=item InstallPath must NOT exist.

=item Start-up (init.d) script must NOT exist.

=back



=item Create Krang UNIX user and/or group


=over 4

=item Create with no password (unless user already exists).

=item Use C<useradd>, C<groupadd>, and C<usermod> to manage user account.

=back



=item Install Krang

=item Configure Krang and first instance.

=item Add Krang to init.d startup scripts.

=item Start Krang

=item Make test

=item Output settings and URL of Krang installation to console.



=back




=head1 OPTIONS

 Required parameters:
  --HostName             - Host name used for CMS
  --IPAddress            - IP address used for HTTP and FTP
  --AdminPassword        - For CMS "admin" user
  --DBUser               - MySQL user used by CMS
  --DBPass               - MySQL user password used by CMS
  --InstanceHostName     - Host name of CMS instance virtual server
  --InstanceDBName       - Name of MySQL database
  --InstanceElementSet   - Name of element set used by CMS instance

 Optional parameters:
  --FTPHostName          - Host name for FTP server, defaults to HostName.
  --MySQLRootPassword    - Password for the MySQL user "root"
  --InstallPath          - Directory for Krang install
  --KrangUser            - UNIX user for process ownership
  --KrangGroup           - UNIX group for process ownership
  --FTPPort              - Port for FTP server, 21 by default. 
  --ApachePort           - Port on which CMS HTTP server should run
  --SMTPServer           - Address of SMTP mail server 
  --InstanceDisplayName  - Name of the Instance for UI display
  --FromBackup           - the name of a backup file to restore from.
  --WithAddon            - Installs Krang with an addon.  May be repeated.
  --run-tests            - run Krang "make test", defaults off
  --help                 - Show usage
  --man                  - Show full man page

=head1 SEE ALSO

Refer to F<docs/ops_install.pod>.

=cut



use File::Spec::Functions qw(catdir catfile splitdir rel2abs);
use FindBin qw($RealBin);
use Config;


# Set up KRANG_ROOT and PERL5LIB
BEGIN {
    # Find a KRANG_ROOT based on path to bin
    my @dir = splitdir($RealBin);
    $ENV{KRANG_ROOT} ||= catdir(@dir[0 .. $#dir - 1]);

    # use $KRANG_ROOT/lib for modules
    my $lib    = catdir($ENV{KRANG_ROOT}, "lib");
    $ENV{PERL5LIB} = $ENV{PERL5LIB} ? "$ENV{PERL5LIB}:${lib}" :
      "${lib}";
    unshift @INC, $lib, "$lib/".$Config{archname};
}

use Krang;
use Getopt::Long;
use Pod::Usage;
use HTML::Template;
use File::Temp qw(tempdir);

my @original_args = ();
my $uniqueness = time();
my ($help, $man, $run_tests);
my @req_params = qw( HostName
                     IPAddress
                     InstanceHostName
                     AdminPassword 
                     InstanceDBName 
                     DBUser 
                     DBPass
                     InstanceElementSet );

my @opt_params = qw( FromBackup
                     MySQLRootPassword 
                     InstallPath 
                     KrangUser 
                     KrangGroup 
                     FTPPort 
                     ApachePort 
                     SMTPServer 
                     FTPHostName
                     InstanceDisplayName );

my %options = ( map { $_ => undef } @req_params, @opt_params);

do_install();
exit(0);


################################
####  MAKE INSTALL METHODS  ####
################################

sub do_install {
    setup_getopts();

    # unpack backup, which contributes to options
    unpack_backup() if $options{FromBackup};

    # enforce requirements
    enforce_requirements();
    
    # Do installation
    check_prereqs();

    # working here - must create all users spec'd in backup conf
    create_mysql_user();
    create_unix_user_group();
    install_krang();
    configure_krang();
    install_addons();
    create_database();
    update_password();
    add_krang_init();
    start_krang();
    make_test() if ($run_tests);
    output_report();
}

# open up the backup file, if one is specified, and load unspecified
# values from the config
sub unpack_backup {
    our $BACKUP_DIR;
    our $BACKUP_CONF;
    our @BACKUP_INSTANCES;

    # open up the backup
    my $kba = $options{'FromBackup'};
    exit_error("FromBackup file '$kba' should end in .kba or .kba.gz")
      unless $kba =~ /\.kba\.gz$/ or $kba =~ /\.kba$/;
    exit_error("FromBackup file '$kba' does not exist.")
      unless -e $kba;
    $kba = rel2abs($kba);

    # make temp directory for backup files
    $BACKUP_DIR = tempdir(CLEANUP => 1,
                          DIR     => catdir($ENV{KRANG_ROOT}, 'tmp'));

    print "Unpacking backup file '$kba'.\n";
    my $cmd = TAR_BIN . " -x" . ($kba =~ /gz$/ ? 'z' : '') . "f $kba -C $BACKUP_DIR";
    system($cmd) && die("Error un-tarring file '$kba' to '$BACKUP_DIR'.\n");
    exit_error("FromBackup file '$kba' is not a valid Krang backup - missing conf/krang.conf.")
      unless -e catfile($BACKUP_DIR, 'conf', 'krang.conf');

    # make sure the versions match
    my $this_version = _get_version("$ENV{KRANG_ROOT}/lib/Krang.pm");
    my $backup_version = _get_version("$BACKUP_DIR/lib/Krang.pm");
    exit_error("Backup file '$kba' was made with version '$backup_version' of Krang!  This is version '$this_version'.")
      unless $this_version == $backup_version;
    
    # load configuration file from backup to get defaults
    print "Loading backup configuration.\n";
    require Config::ApacheFormat;
    $BACKUP_CONF = Config::ApacheFormat->new();
    $BACKUP_CONF->read(catfile($BACKUP_DIR, 'conf', 'krang.conf'));    
    
    # use the values from the first instance
    my @blocks = $BACKUP_CONF->get('Instance');
    my $conf = $BACKUP_CONF->block($blocks[0]);

    # load option defaults from conf    
    $options{HostName}           ||= $conf->get('HostName');
    $options{IPAddress}          ||= $conf->get('ApacheAddr');
    $options{AdminPassword}      ||= '*** RESTORED FROM BACKUP ***';
    $options{DBUser}             ||= $conf->get('DBUser');
    $options{DBPass}             ||= $conf->get('DBPass');
    $options{InstanceElementSet} ||= $conf->get('InstanceElementSet');
    $options{InstanceDBName}     ||= $conf->get('InstanceDBName');
    $options{InstanceHostName}   ||= $conf->get('InstanceHostName');
    $options{KrangUser}          ||= $conf->get('KrangUser');
    $options{KrangGroup}         ||= $conf->get('KrangGroup');
    $options{FTPPort}            ||= $conf->get('FTPPort');
    $options{FTPHostName}        ||= $conf->get('FTPHostName');
    $options{ApachePort}         ||= $conf->get('ApachePort');
    $options{SMTPServer}         ||= $conf->get('SMTPServer');
    $options{InstanceDisplayName}||= $conf->get('InstanceDisplayName');

    # load extra instance data into @BACKUP_INSTANCES
    if (@blocks > 1) {
        foreach my $block_name (@blocks[1..$#blocks]) {
            $conf = $BACKUP_CONF->block($block_name);
            push(@BACKUP_INSTANCES, 
                 { InstanceElementSet => $conf->get('InstanceElementSet'),
                   InstanceDBName     => $conf->get('InstanceDBName'),
                   InstanceHostName   => $conf->get('InstanceHostName'),
                 });
        }
    }

    # set KrangRoot to backup directory so backup will flow from there
    $ENV{KRANG_ROOT} = $BACKUP_DIR;
}

# extract a version number from Krang.pm
sub _get_version {
    `perl -e 'require qq{$_[0]}; print \$Krang::VERSION'`;
}

sub check_prereqs {
    print "Checking prerequisites\n";

    # Must be running as root.
    exit_error("Must be run as root.") unless ($> eq "0");

    # IP address must be configured on host.
    my $ifconfig_bin = IFCONFIG_BIN;
    my $ifconfig = `$ifconfig_bin`;
    my @ip_addrs = ();
    foreach my $if_line (split(/\n/, $ifconfig)) {
        next unless ($if_line =~ /inet\ addr\:(\d+\.\d+\.\d+\.\d+)/);
        my $ip = $1;
        push(@ip_addrs, $ip);
    }
    my $IPAddress = $options{'IPAddress'};
    unless (grep {$_ eq $IPAddress} @ip_addrs) {
        exit_error("IPAddress '$IPAddress' not bound to machine");
    }

    # Addons files must exist
    foreach my $addon (@{$options{'WithAddon'}}) {
        exit_error("Addon file '$addon' does not exist")
          unless -e $addon;
        $addon = rel2abs($addon);
    }
    
    exit_error("InstanceElementSet '$options{InstanceElementSet}' does not exist in Krang.\nPerhaps you misspelled it, or forgot a --WithAddon option.\n")
      unless _check_element_set($options{'InstanceElementSet'});

    my $perl_version = $Config{version};
    my $archname = $Config{archname};
    unless (($perl_version eq '5.6.1') and ($archname eq 'i686-linux')) {
        exit_error("Incorrect Perl version (Found $perl_version/$archname, expecting 5.6.1/i686-linux).");
    }

    # InstallPath must NOT exist.
    my $InstallPath = $options{InstallPath};
    if (-e $InstallPath) {
        if (-e catfile($InstallPath,'bin','krang_uninstall')) {
             exit_error("Will not proceed due to existing krang install.") unless prompt("y", "InstallPath '$InstallPath' already exists and seems to contain\nan existing Krang instance.\nThis program must totally and permanently\nremove this krang installation in order to proceed.\n\nIs this what you really want to do?", "y/n", "n");
             {
                 local $ENV{KRANG_ROOT} = $InstallPath;
                 system(catfile($InstallPath,'bin','krang_uninstall').' --no_prompt --verbose');
             }
         } else { 
             exit_error("InstallPath '$InstallPath' already exists and does not appear to belong to an existing krang instance.  Cannot continue.");
         }
    }

    # Start-up (init.d) script must NOT exist.
    my $init_script = "/etc/init.d/krang-". $options{HostName} .".init";
    if (-l $init_script) {
        exit_error("Init script '$init_script' already exists.  Cannot continue.");
    }
        
        # Check for proper version of MySQL.
        #     Suggest ""--do-mysql-install"" flag if not
        #     installed.
        my $mysql_bin = MYSQL_BIN;
        unless (-f $mysql_bin) {
            exit_error("MySQL not installed.");
        }

        my $mysql_version = `$mysql_bin -V`;
        unless ((-f $mysql_bin) and ($mysql_version =~ /Distrib\ 4\./)) {
            exit_error("MySQL version 4.* not installed.");
        }

        # MySQLRootPassword must be valid, and MySQL should be running
        my $MySQLRootPassword = $options{'MySQLRootPassword'};
        my $test_mysql = ECHO_BIN ." 'select \"world\" as hello' | $mysql_bin -uroot";
        $test_mysql .= " -p$MySQLRootPassword" if (length($MySQLRootPassword));
        $test_mysql .= " 2>&1";
        my $mysql_test_output = `$test_mysql`;

        unless (($mysql_test_output =~ /hello/) and ($mysql_test_output =~ /world/)) {
            print STDERR "$mysql_test_output";
            if ($mysql_test_output =~ /ERROR 1045: Access denied/) {
                exit_error("MySQLRootPassword '$MySQLRootPassword' is not valid");
            } elsif ($mysql_test_output =~ /ERROR 2002: Can\'t connect/) {
                exit_error("Can't connect to MySQL.  Start MySQL and try again.");
            } else {
                exit_error("Unable to verify MySQLRootPassword.");
            }
        }

        # InstanceDBName should NOT exist in MySQL
        my $InstanceDBName = $options{InstanceDBName};
        my $db_exists_test = ECHO_BIN ." 'select 1' | $mysql_bin -uroot";
        $db_exists_test .= " -p$MySQLRootPassword" if (length($MySQLRootPassword));
        $db_exists_test .= " $InstanceDBName 2>&1";
        my $db_exists_test_output = `$db_exists_test`;

        unless ($db_exists_test_output =~ /ERROR 1049: Unknown database/) {
            exit_error("Database '$InstanceDBName' already exists.  Cannot continue.");
        }
    
}

# sort of simulates Term::Prompt, but not really
sub prompt {

    my($yes_val, $prompt_string,$choices,$default_val) = @_;

    #  if there is a default value, print it
    if ($default_val) {
        print $prompt_string, "($choices)", " [", $default_val, "]: ";
    } else {
        print $prompt_string, "($choices)", ": ";
    }

    $_ = <STDIN>;         # get the input from STDIN 


    # remove the newline character from the end of user input
    chomp;
   
    if ($_) {
        if ($_ eq $yes_val) {
            return 1;
        } else {
            return 0;
        } 
    } else {
        if ($default_val eq $yes_val) {
            return 1;
        } else {
            return 0;
        }
    }
}

sub create_mysql_user {
    # MySQLRootPassword must be valid, and MySQL should be running
    my $mysql_bin = MYSQL_BIN;
    my $MySQLRootPassword = $options{'MySQLRootPassword'};
    my $InstanceDBName = $options{'InstanceDBName'};
    my $DBUser = $options{'DBUser'};
    my $DBPass = $options{'DBPass'};

    my $grant = "grant all on $InstanceDBName\.* to $DBUser\@localhost";
    $grant .= " identified by '$DBPass'" if ($DBPass);

    my $mysql_grant = ECHO_BIN ." \"$grant\" | $mysql_bin -uroot";
    $mysql_grant .= " -p$MySQLRootPassword" if (length($MySQLRootPassword));

    print "Granting MySQL access to user '$DBUser' for database '$InstanceDBName'\n";
    system($mysql_grant) && exit_error("Can't grant DB access to $DBUser for $InstanceDBName.");
    print "  MySQL access granted.\n";

    # handles any backup instances
    our @BACKUP_INSTANCES;
    foreach my $instance (@BACKUP_INSTANCES) {
        my $InstanceDBName = $instance->{'InstanceDBName'};

        $grant = "grant all on $InstanceDBName\.* to $DBUser\@localhost";
        $grant .= " identified by '$DBPass'" if ($DBPass);
        
        my $mysql_grant = ECHO_BIN ." \"$grant\" | $mysql_bin -uroot";
        $mysql_grant .= " -p$MySQLRootPassword" if (length($MySQLRootPassword));
        print "Granting MySQL access to user '$DBUser' for database '$InstanceDBName'\n";
        system($mysql_grant) && exit_error("Can't grant DB access to $DBUser for $InstanceDBName.");
        print "  MySQL access granted.\n";
        
    }
}


sub create_unix_user_group {
    my $KrangUser = $options{'KrangUser'};
    my $KrangGroup = $options{'KrangGroup'};
    my $InstallPath = $options{InstallPath};

    # Create user, if necessary
    print "Creating UNIX user ('$KrangUser')\n";
    my ($uname,$upasswd,$uid,$ugid,$uquota,$ucomment,$ugcos,$udir,$ushell,$uexpire) = getpwnam($KrangUser);
    unless (defined($uid)) {
        my $useradd = USERADD_BIN;
        $useradd .= " -d $InstallPath -M $KrangUser";
        system($useradd) && die("Can't add user: $!");

        # Update user data
        ($uname,$upasswd,$uid,$ugid,$uquota,$ucomment,$ugcos,$udir,$ushell,$uexpire) = getpwnam($KrangUser);
        print "  User created (uid $uid).\n";
    } else {
        print "  User already exists (uid $uid).\n";
    }

    # Create group, if necessary
    print "Creating UNIX group ('$KrangGroup')\n";
    my ($gname,$gpasswd,$gid,$gmembers) = getgrnam($KrangGroup);
    unless (defined($gid)) {
        my $groupadd = GROUPADD_BIN;
        $groupadd .= " $KrangGroup";
        system($groupadd) && die("Can't add group: $!");

        # Update group data for later
        ($gname,$gpasswd,$gid,$gmembers) = getgrnam($KrangGroup);
        print "  Group created (gid $gid).\n";
    } else {
        print "  Group already exists (gid $gid).\n";
    }

    # Add user to group, if user not already a member
    print "Adding user $KrangUser to group $KrangGroup\n";
    my @group_members = ( split(/\s+/, $gmembers) );
    my $user_is_group_member = ( grep { $_ eq $KrangUser } @group_members );
    unless (($ugid eq $gid) or $user_is_group_member) {
        my $usermod = USERMOD_BIN;
        $usermod .= " -G $KrangGroup $KrangUser";
        system($usermod) && die("Can't add user $KrangUser to group $KrangGroup: $!");
        print "  User added to group.\n";
    } else {
        print "  User already in group.\n";
    }
}

sub install_krang {
    my $InstallPath = $options{InstallPath};
    mkdir($InstallPath) || die($!);

    print "Installing Krang files into '$InstallPath'\n";

    chdir($ENV{KRANG_ROOT});
    my $copy = COPY_BIN ." -r * $InstallPath\/";
    system($copy) && die("Can't copy: $!");

    # remove scripts that won't do anything useful in an installed
    # system
    system("rm $InstallPath/bin/krang_install $InstallPath/bin/krang_makedist $InstallPath/bin/krang_upgrade");

    print "  Fixing ownership\n";
    my $KrangUser = $options{KrangUser};
    my $KrangGroup = $options{KrangGroup};
    my $chown = CHOWN_BIN ." -R $KrangUser\.$KrangGroup $InstallPath";
    system($chown) && die("Can't update ownership: $!");

    # For commands
    my $chmod;

    print "  Setting group write permissions\n";
    $chmod = CHMOD_BIN ." -R g+w $InstallPath";
    system($chmod) && die("Can't set group write permissions: $!");

    print "  Fixing file read permissions\n";
    $chmod = CHMOD_BIN ." -R +r $InstallPath";
    system($chmod) && die("Can't fix file read permissions: $!");

    print "  Fixing directory read permissions\n";
    $chmod = FIND_BIN ." $InstallPath -type d | ". XARGS_BIN ." ". CHMOD_BIN ." +rx";
    system($chmod) && die("Can't fix directory read permissions: $!");

    print "  Setting execute bits on scripts\n";

    # Set all *.pl files
    $chmod = FIND_BIN ." $InstallPath -type f -name '*.pl' | ". XARGS_BIN ." ". CHMOD_BIN ." +x";
    system($chmod) && die("Can't set execite bits: $!");

    # Set all *.cgi files
    $chmod = FIND_BIN ." $InstallPath -type f -name '*.cgi' | ". XARGS_BIN ." ". CHMOD_BIN ." +x";
    system($chmod) && die("Can't set execite bits: $!");

    # Set all files in krang/bin/*
    $chmod = CHMOD_BIN ." +x $InstallPath/bin/*";
    system($chmod) && die("Can't set execite bits: $!");

    print "  Krang files installed.\n";
}


sub configure_krang {
    print "Configuring Krang installation\n";

    my $InstallPath = $options{InstallPath};
    chdir($InstallPath);

    if ($options{FromBackup}) {
        print "Updating backup krang.conf\n";

        # processing existing krang.conf, replacing IPAddress and
        # HostName parameters needed to migrate a backup to a new machine
        open(CONF, "<", "conf/krang.conf") 
          or die "Unable to open conf/krang.conf : $!";
        my @conf = <CONF>;
        close(CONF);

        open(CONF, ">", "conf/krang.conf") 
          or die "Unable to open conf/krang.conf : $!";
        foreach my $line (@conf) {
            if ($line =~ /^\s*ApacheAddr\s/i) {
                print CONF "ApacheAddr $options{IPAddress}\n";
            } elsif ($line =~ /^\s*FTPAddress\s/i) {
                print CONF "FTPAddress $options{IPAddress}\n";
            } elsif ($line =~ /^\s*HostName\s/i) {
                print CONF "HostName $options{HostName}\n";
            } elsif ($line =~ /^\s*FTPHostName\s/i) {
                print CONF "FTPHostName $options{FTPHostName}\n";
            } else {
                print CONF $line;
            }
        }
        close CONF;
        

    } else {
    
        # Make custom krang.conf
        print "Creating krang.conf from specification\n";
        my $t = HTML::Template->new(filename => $ENV{KRANG_ROOT} ."/conf/krang.conf.tmpl");
        foreach my $param (keys(%options)) {
            # Filter out params which are not in HTML::Template file 'krang.conf.tmpl'
            unless ( grep { $param eq $_ } qw/AdminPassword MySQLRootPassword InstallPath FromBackup WithAddon/ ) {
                $t->param($param => $options{$param});
            }
        }
        my $output_conf = $InstallPath ."/conf/krang.conf";
        open(OUTPUT, ">$output_conf") || die("Can't open '$output_conf' for writing: $!");
        print OUTPUT $t->output();
        close(OUTPUT);
    }

    print "  Conf written to '$InstallPath/conf/krang.conf'.\n";
}


# create the DB
sub create_database {
    my $InstallPath = $options{InstallPath};
    chdir($InstallPath);

    if ($options{FromBackup}) {
        # load database SQL
        opendir(BACKUP, catdir($ENV{KRANG_ROOT}, 'data', 'backup'))
          or die "Unable to open data/backup: $!";
        my @sql = grep { /\.sql$/ } readdir(BACKUP);
        closedir(BACKUP);
                
        foreach my $sql (@sql) {
            print "Creating MySQL database from backup source '$sql'.\n";
            my $file = catfile($ENV{KRANG_ROOT}, 'data', 'backup', $sql);
            my $cmd = "cat $file | mysql -uroot ";
            $cmd .= " -p$options{'MySQLRootPassword'}" 
              if length $options{'MySQLRootPassword'};
            system($cmd);
        }
    } else {
        # Create DB
        print "Creating MySQL database and loading schema\n";
        my $MySQLRootPassword = $options{'MySQLRootPassword'};
        my $createdb = "KRANG_ROOT='' PERL5LIB='' $InstallPath/bin/krang_createdb --all";
        $createdb .= " --password $MySQLRootPassword" if (length($MySQLRootPassword));
        system($createdb) && die("Error calling krang_createdb.  Unable to continue");
    }
}

sub install_addons {
    my @addons = @{$options{WithAddon}};
    my $InstallPath = $options{InstallPath};

    foreach my $addon (@addons) {
        print "Installing addon '$addon'.\n";
        local $ENV{KRANG_ROOT} = $InstallPath;
        my $cmd = catfile($InstallPath, 'bin', 'krang_addon_installer') .
          ' ' . $addon;
        my $result = `$cmd`;
        exit_error("Unable to install addon '$addon':\n\n$result")
          unless $result =~ /Installation complete\./;
    }
}

sub update_password {
    return if $options{FromBackup};

    # Customize DB (Admin password)
    my $InstallPath = $options{InstallPath};
    my $AdminPassword = $options{AdminPassword};
    print "  Changing 'admin' CMS login password to '$AdminPassword'\n";
    my $update_pw_perl = qq(
                            my (\$user) = Krang::User->find(login=>"admin");
                            \$user->password("$AdminPassword");
                            \$user->save();
                           );
    my $update_admin_pw = "KRANG_ROOT='$InstallPath' PERL5LIB='$InstallPath/lib' ";
    $update_admin_pw .= PERL_BIN ." -MKrang::Script -MKrang::User -e '$update_pw_perl'";
    system($update_admin_pw) && die("Error changing admin password.\n");    
}

sub add_krang_init {
    my $init_script = "krang-". $options{HostName} .".init";
    print "Installing Krang init.d script '$init_script'\n";

    chdir("/etc/init.d");
    my $InstallPath =  $options{InstallPath};
    my $link_init = LN_BIN ." -s $InstallPath\/bin/krang_ctl $init_script";
    system($link_init) && die ("Can't link init script: $!");

    print "Setting $init_script to start on boot\n";
    my $chkconfig = CHKCONFIG_BIN ." --add $init_script";
    system($chkconfig) && die("Can't chkconfig --add $init_script: $!");

    $chkconfig = CHKCONFIG_BIN ." $init_script on";
    system($chkconfig) && die("Can't chkconfig $init_script on: $!");
}


sub start_krang {
    my $init_script = "krang-". $options{HostName} .".init";
    print "Starting Krang via init.d script '$init_script'\n";
    my $start = "KRANG_ROOT='' PERL5LIB='' /etc/init.d/$init_script start";
    system($start) && die("Can't start Krang: $!");
}


sub make_test {
    print "Running Krang tests...\n";

    my $AdminPassword = $options{AdminPassword};

    my $InstallPath =  $options{InstallPath};
    chdir($InstallPath);

    my $make_bin = MAKE_BIN;
    my $make_test = "KRANG_ROOT='' PERL5LIB='' KRANG_PASSWORD='$AdminPassword' $make_bin test";
    system($make_test) && die("Error running tests: $!");
}


sub output_report {
    my $init_script = "/etc/init.d/krang-". $options{HostName} .".init";
    my $krang_conf = $options{InstallPath} ."/conf/krang.conf";

    print <<EOREPORT;


#####                                                         #####
###                                                             ###
##                  KRANG INSTALLATION COMPLETE                  ##
###                                                             ###
#####                                                         #####


   Installed at        :  $options{InstallPath}
   Startup init script :  $init_script
   Krang conf file     :  $krang_conf

   Running on $options{IPAddress} --
     http://$options{HostName}:$options{ApachePort}/
     ftp://$options{HostName}:$options{FTPPort}/

   CMS admin user password:  "$options{AdminPassword}"


EOREPORT
}





###########################
####  PRIVATE METHODS  ####
###########################

sub exit_error {
    my $cmd = $0;
    $cmd =~ s/.*\/(.+)$/$1/;

    my $message = shift;
    print STDERR "\nError: $cmd:  $message\n\n";
    exit(1);
}


sub setup_getopts {
    # Copy the original args for re-invoking later
    @original_args = @ARGV;

    $options{WithAddon} = [];
    pod2usage(2) unless
        GetOptions( 'help'      => \$help,
                    'man'       => \$man,
                    'run-tests' => \$run_tests,
                    'WithAddon=s' => $options{WithAddon},
                    (map { $_."=s" => \$options{$_} } @req_params, @opt_params) );

    pod2usage(1)             if $help;
    pod2usage(-verbose => 2) if $man;

}

sub enforce_requirements {
    # Enforce required params
    my $error_output = "";
    foreach my $p (@req_params) {
        next if defined($options{$p});
        $error_output .= "Missing --". $p ."\n";
    }
    if ($error_output) {
        print "Error:\n\n$error_output\n";
        pod2usage(1);
    }

    # Set opt defaults
    set_param_defaults();
}


sub set_param_defaults {
    my %defaults = (
                    MySQLRootPassword => '',
                    InstallPath => '/usr/local/krang',
                    KrangUser => 'krang',
                    KrangGroup => 'krang',
                    FTPPort => '21',
                    FTPHostName => $options{'HostName'},
                    ApachePort => '80',
                    SMTPServer => '127.0.0.1',
                    );

    # Set up defaults if value is not otherwise set
    while (my ($k, $dv) = each(%defaults)) {
        # Skip if value already defined
        next if (defined $options{$k});

        if ($k eq 'FTPPort') {
            # attempt to connect to port 21. else default to 2121
            my $remote;
            $remote = IO::Socket::INET->new(
                        Proto    => "tcp",
                        PeerAddr => $options{'IPAddress'},
                        PeerPort => "ftp(21)",
                    ) || '';
            close $remote if $remote;

            $dv = 2121 if (not $remote);
        }

        # Set default
        $options{$k} = $dv;
    }

    # Default instancedisplayname => $instancevirtualhost
    my $idn = "InstanceDisplayName";
    unless (defined $options{$idn}) {
        $options{$idn} = $options{'InstanceHostName'};
    }
}

# check that the specified element set exists in Krang or in an addon
# to be installed.  Returns 1 if ok, else 0.
sub _check_element_set {
    my $set = shift;

    return 1 if -d catfile($ENV{KRANG_ROOT}, "element_lib", $set);

    foreach my $addon (@{$options{WithAddon}}) {
        my $tar = TAR_BIN . " t" . ($addon =~ /gz$/ ? "z" : "") . "f $addon";
        my $contents = `$tar`;
        if ($contents =~ m!element_lib/$set/set.conf!) {
            return 1;
        }
    }
    return 0;
}
