=head1 Writing HTML::Template Templates in Krang

=over

=item * Name

=item * Introduction

=item * Templates in Krang

=item * Publish Methods and Templates

=item * Choosing a Strategy


----------------------------------------

=item * Publishing With Stock Krang Publish Methods 

=over

=item * An Example Story Type

=item * How Krang Builds Template Data

=item * Elements Without Templates

=item * Example 1: Using One Large Template

=item * Example 2: Using Multiple Templates

=back

----------------------------------------

=item * Publishing With Customized Publish Methods

=over

=item * Overriding Krang::ElementClass Methods in Your Element Library

=over

=item * template_data()

=item * fill_template()

=item * find_template()

=item * publish()

=back

=item * Example 3: Using One Large Template

=item * Example 4: Using Multiple Templates

=back

----------------------------------------

=item * How Categories and Category Templates Work

=item * Using Pagination

=item * Links to Other Stories

=item * Media Objects

=item * Contributors

=back

=head1 Name

Writing HTML::Templates in Krang - A guide to using the Krang templating system.

=head1 Introduction

This document describes how to use templating system in Krang, which is based on HTML::Template.  An understanding of the way stories are constructed in Krang will be helpful in getting the most out of this document.  A general understanding of how the HTML::Template templating language works will help as well.

=head1 Templates in Krang

Krang uses templates to generate output for stories when they're published.  These templates are organized on the filesystem in the same category tree that is used for arranging stories and media.  When a story is published, the category tree is searched for appropriate templates, starting at the story's current category.  If no match is found immediately, Krang will then proceed up the category tree until a matching template is found.


=head1 Publish Methods and Templates

Krang uses the HTML::Template templating system.  The philosophy behind HTML::Template is to separate the code required to build the content of a page from the template used for the layout of the final page.  Krang takes this philosophy one step further - by using the element tree of a story to automate the construction of a story's content, template developers can do their work with minimal programmer involvement.

If you are migrating from Bricolage, the templating system in Krang does not make use of separate publish scripts, the way that Bricolage did.  In Krang, every element in the element tree contains code to publish itself.  If customization is required, you can override the default publish methods within the element.

For further information on Krang's element tree, see C<Creating Element Libraries in Krang>.


=head1 Choosing a Strategy

When first building templates for Krang, try and use the stock publish methods with one or more templates (See C<Publishing With Stock Krang Publish Methods>, below).  As you get more familiar with Krang, you will discover that using many templates will allow you to customize the appearance of various sections of your site, without doing anything more than template development.

The publish methods that exist in Krang were designed with flexibility and performance in mind.  Consider overriding methods (C<Publishing With Customized Publish Methods>) in the publish process only in the event that you cannot get the behavior you need out of the standard methods.

Realize that overriding publish methods can potentially affect the performance of the preview/publish process, as any given method may be called a large number of times.


=head1 Publishing With Stock Krang Publish Methods

The publish methods provided by Krang should be sufficient for just about everyone.  Get familiar with the standard publish process and use it for a little while before getting into the more advanced techniques in the publish process - chances are you won't need to use them.

The most important things to understand when getting into template development in Krang are the relationships that elements have to eachother (the element tree), and how those relationships are used to build out the data structures used in your templates.

=head2 An Example Story Type

We'll examine a simple example story type called C<Story>. Here's the element tree for C<Story>:

   Story
        - Deck             (textbox attribute)
        + Page             (repeatable element)
             - Paragraph   (repeatable textbox attribute)
             - Pull Quote  (repeatable textbox attribute)

The Story element has an attribute called Deck, and can contain any number of Page elements. Pages are composed of Paragraph attributes and Pull Quote attributes, both of which can be repeated.

When the publish process is called on this story, Krang will walk this element tree, starting from the top (C<Story>), recursively touching every element in the tree to construct the final output.

Each element within C<Story> contains methods to retrieve the appropriate template, build the appropriate data to populate that template, and return the output that results from the merger of the data and template.

No element can return until it's children have returned.  Using the above tree as an example, a C<Page> element will not return its output until its children, the C<Paragraph> and C<Pull Quote> elements, have returned their output.


=head2 How Krang Builds Template Data

Krang uses an internal method, C<< Krang::ElementClass->fill_template() >> (see more in C<Publishing With Customized Publish Methods>) to buld the data available to a template.  fill_template() will fill in the variables and loops in your template in a predictable fashion.

Several types of variables and loops are created.  Using the element tree for C<Story> above as an example, the follwoing variables will be created:

=over

=item *

B<NOTE>: All variable names are lower case, and any spaces in between words will be replaced with underscores.

=item *

A single variable is created for every element using C<< $element->name() >>

An examples would be <tmpl_var deck>.

=item *

A loop is created for every element named with the name of the element followed by _loop. The rows of the loop contain the variable described above and a _count variable.

The <tmpl_loop page_loop> is an example of this type of loop.  Each element in C<page_loop> will contain <tmpl_var page> and <tmpl_var page_count>.

=item *

A loop called C<element_loop> is created with a row for every element contained. The values are the same as for the loop above with the addition of a boolean is_ variable.

For example, <tmpl_loop element_loop> would contain the variables <tmpl_var is_deck>, <tmpl_var deck>, <tmpl_var is_page>, <tmpl_var page>.

=item *

A variable for the total number of elements named with the element name and a trailing _total.

<tmpl_var deck_total> would return 1, as would <tmpl_var page_total>.


=item *

A variable called C<title> containing $story->title.

This is available to all templates, regardless of where in the element tree you are.

Accessed in the template as <tmpl_var title>.

=item * 

A variable called C<page_break> that forces Krang to create a new page.

This is available to all templates.  Careful as to where this is implemented, as you could find yourself creating far more pages than you intend to.

<tmpl_var page_break>

=item *

A loop called C<contrib_loop> containing all contributors to a story.

See the section C<Contributors>, further on in this document, for more information on Contributors.

=item *

A loop called C<pagination_loop> containing links to other pages in the story.

See the section C<Using Pagination>, further on in this document, for more information on Pagination.  This variable is only available to elements marked as I<pageable>.

=back

=head2 Example 1: Using One Large Template




Overriding the various methods in the element tree is not always required.  If no methods are overridden, the methods found in Krang::ElementClass are used.



B<Additional notes>

The template being used in this strategy is almost exactly the same as for strategy 1. There are a couple changes.  First, the variable names used in the template must correspond to what $element->name() will return.  Second, the default fill_template() method provides "is_$element->name()" variables inside the element_loops to make testing for the type of row more obvious and more fool-proof.  In STRATEGY 1 a paragraph with the sole contents "0" wouldn't have been printed.

B<The Template - Story.tmpl>

 #
 # Note: Need to explain how to save in Krang::Template
 #

 <tmpl_loop page_loop>

   <html>

   <head>
     <title><tmpl_var title></title>
   </head>
   <body>

     <tmpl_if __first__>
        <h1><tmpl_var title></h1>
        <b><tmpl_var deck></b>
     </tmpl_if>

     <tmpl_loop element_loop>
        <tmpl_if is_paragraph>
          <p><tmpl_var paragraph></p>
        </tmpl_if>
        <tmpl_if is_pull_quote>
          <p><blockquote><i>
            <tmpl_var pull_quote>
          </i></blockquote></p>
        </tmpl_if>
     </tmpl_loop>

     <tmpl_unless __first__>
     <a href=<tmpl_var expr="prev_page_link(page_count)">>Previous Page</a>
     </tmpl_unless>

     <tmpl_unless __last__>
     <a href=<tmpl_var expr="next_page_link(page_count)">>Next Page</a>
     </tmpl_unless>

   </body>
   </html>

   <tmpl_var page_break>

 </tmpl_loop>



=head2 Example 2: Using Multiple Templates

If your building an element that will be used as a sub-element in more than one tree, you can save a lot of time and effort by splitting out the functionality of that element from the rest of the system.

This example will take what we did in Example 2 (single template, no fill_template() method), and break out the construction of the Page element into a separate template.  The publish() method will not be overloaded in this example, so the default publish() method will be relied upon to build the loops and variables.  All behavior of the default publish() method talked about in Example 2 still applies.


B<The Templates>

B<Story.tmpl>

The Story template (taken from Story.tmpl in Example 2 above) sees one major revision - the entire <tmpl_loop element_loop> section has been removed and replaced with a single B<<tmpl_var page>>.  The default publish() method (or the one you roll on your own, see Example 4, below) will see this and now make a call to the publish() method for the page element to generate the HTML needed by <tmpl_var>.

# Note: Need to explain how to save in Krang::Template

 <tmpl_loop page_loop>

   <html>

   <head>
     <title><tmpl_var title></title>
   </head>
   <body>

     <tmpl_if __first__>
        <h1><tmpl_var title></h1>
        <b><tmpl_var deck></b>
     </tmpl_if>

     <tmpl_var page>

     <tmpl_unless __first__>
     <a href=<tmpl_var expr="prev_page_link(page_count)">>Previous Page</a>
     </tmpl_unless>

     <tmpl_unless __last__>
     <a href=<tmpl_var expr="next_page_link(page_count)">>Next Page</a>
     </tmpl_unless>

   </body>
   </html>

   <tmpl_var page_break>

 </tmpl_loop>


B<Page.tmpl>

Page.tmpl is simply the inner loop @element_loop that was found in the Story.tmpl of Example 2.  By removing it from Story.tmpl, we now have a small, easy-to-maintain template with very simple functionality.

Notice that the header and footer logic found in the previous template (using __first__ and __last__) is not present here - those variables are internal HTML::Template variables that correspond to the current location in @page_loop, which doesn't exist here.  

# Note: Need to explain how to save in Krang::Template

 <tmpl_loop element_loop>
   <tmpl_if paragraph>
     <p><tmpl_var paragraph></p>
   </tmpl_if>
   <tmpl_if name="pull quote">
     <p><blockquote><i>
       <tmpl_var name="pull quote">
     </i></blockquote></p>
   </tmpl_if>
 </tmpl_loop>





=head2 RESULTS


B<Advanteges:>

=over

=item * Two simplified templates easier to understand than one large complex one.

=item * Customizability - multiple implementations of the Page template can be used to provide different layouts, all without touching the Story template.

=item * Use of the default publish() method means that no custom perl code is required.

=back

B<Disadvanteges:>

=over

=item * Everything is no longer in a single spot - the developer is now forced to look in multiple locations for all template information.

=back

=head1 Publishing with Customized Publish Methods

=head1 Overriding Krang::ElementClass Methods in Your Element Library

If you do decide to make changes to the publish process, the following methods exist in Krang::ElementClass as part of the publish process, and can be overridden as needed:

=over

=item * template_data()

This returns the data stored in the element.  In most cases, it's the actual data stored in the element, unformatted.  In the case of C<Krang::ElementClass::StoryLink> or C<Krang::ElementClass::MediaLink> objects, C<template_data()> will return the fully-qualified URL of the object.

If you want to change the form of the returned data for a single class of element in your element library, overriding template_data() for that element should be the first thing you try.


=item * fill_template()

fill_template() is responsible for filling the template object with data built from the element tree.  Generally, it traverses the element tree, creating scalars and loops on an as-needed basis, populating the template objects with the results.  The rules by which fill_template() operates can be found in C<Example 1>.

If you are familiar with Bricolage, fill_template() functions using the same rules as the autofill() functionality found in Bricolage.

This method is the most likely candidate for overriding, as this is the method that actually determines what goes into the template.

This method is responsible for calling publish() on all children of the current element.  If you decide to override fill_template, but don't want to deal with the manual work of walking the element tree, make sure to make a call to $self->SUPER::fill_template().


=item * find_template()

Returns an HTML::Template::Expr object with the template to be used by the element.  Follows a specific procedure for locating the template on the filesystem.

Unless you need to alter the process for loading templates (e.g. you don't want a template to get loaded under certain circumstances), this method should generally be left alone.

=item * publish()

Ties the above methods together and returns HTML for the current element (and therefore, any children beneath it).  Overriding publish() is a pretty drastic action, and should only be done if absolutely needed. 

publish() takes a hash as an argument, allowing for named parameters.  Anything passed in will subsuquently be passed into the above methods.

=back

Read the POD for C< Krang::ElementClass > if you want to learn more about how these methods work, and how to use them.


=head1 Example 3: Using One Large Template

In this case, we have a very simple system, a single story template made up of basic elements:

=head2 The Template - Story.tmpl

 #
 # NOTE - need notes on how to save template properly in the Krang::Template hierarchy..
 #

 <tmpl_loop page_loop>

   <html>

   <head>
     <title><tmpl_var title></title>
   </head>
   <body>

     <tmpl_if __first__>
        <h1><tmpl_var title></h1>
        <b><tmpl_var deck></b>
     </tmpl_if>

     <tmpl_loop element_loop>
        <tmpl_if paragraph>
          <p><tmpl_var paragraph></p>
        </tmpl_if>
        <tmpl_if name eq "pull quote">
          <p><blockquote><i>
            <tmpl_var name="pull quote">
          </i></blockquote></p>
        </tmpl_if>
     </tmpl_loop>

     <tmpl_unless __first__>
     <a href=<tmpl_var expr="prev_page_link(page_count)">>Previous Page</a>
     </tmpl_unless>

     <tmpl_unless __last__>
     <a href=<tmpl_var expr="next_page_link(page_count)">>Next Page</a>
     </tmpl_unless>

   </body>
   </html>

   <tmpl_var page_break>

 </tmpl_loop>



=head2 The Overridden Element Method

In the Package that describes the Story element, we'll override the fill_template() method.  For the time being, the find_template() and publish() methods will be left alone (see Krang::ElementClass POD for more info).

 sub fill_template {

  my $self = shift;
  my (%named_params) = @_;

  my $template = $named_params{template};
  my $story    = $named_params{story};

  # setup story title
  $template->param(title => $story->title());

  # setup story slug
  $template->param(slug => $story->slug());

  # setup the page break variable
  $template->param(page_break => Krang::Publisher::PAGE_BREAK);

  my $deck_element = $self->children('deck');
  $template->param(deck => $deck_element->publish());

  # Build up @page_loop
  my @page_list = $self->match('/page'); # returns all elements
  my @page_loop;
  my $page_count = 1;

  foreach my $page (@page_list) {

    # build per-page element loop
    my @element_loop;
    foreach my $e ($page->children()) {
        # push on a row for this element
        push(@element_loop, { $e->name() => $e->publish(@_) });
    }

    # push element_loop and a page_count on this loop
    push(@page_loop, { 
                      element_loop => \@element_loop,
                      page_count   => $page_count++
                     });
  }

  # finish the page_loop
  $template->param(page_loop => \@page_loop);

 }



=head2 RESULTS

Using the basic element set, we now have a single story template that can be used when generating content.

Advanteges:

* Single page, single element.  Everything's centrally located, and easy to manipulate.

Disadvanteges:

* With a single template, customization for individual stories is very difficult - there's no possibility of re-using this element in a different tree - it would need to be re-written.





=head1 Example 4: Multiple Templates, Multiple Publish Methods

The last example takes everything done so far, and rolls it all up - using templates for individual elements, and overloading the publish() method within elements, rather than relying on the default publish() method.

One of the advanteges of this rolling your own publish() methods in this case is the ability to pass variables to the sub-element template that would otherwise not exist.  In Example 3, there was no way to use __first__ and __last__ logic in Page.tmpl, because that information was not available.  This can be fixed here.


=head2 The Templates

B<Story.tmpl>

 <tmpl_loop page_loop>

   <html>

   <head>
     <title><tmpl_var title></title>
   </head>
   <body>

     <tmpl_var page>

   </body>
   </html>

   <tmpl_var page_break>

 </tmpl_loop>

MUCH smaller.  All the logic involving __first__ and __last__ has now been moved over to Page.tmpl, where it really belongs.  


B<Page.tmpl>

 <tmpl_if first>
    <h1><tmpl_var title></h1>
    <b><tmpl_var deck></b>
 </tmpl_if>

 <tmpl_loop element_loop>
    <tmpl_if is_paragraph>
      <p><tmpl_var paragraph></p>
    </tmpl_if>
    <tmpl_if is_pull_quote>
      <p><blockquote><i>
    <tmpl_var pull_quote>
      </i></blockquote></p>
    </tmpl_if>
 </tmpl_loop>

 <tmpl_unless first>
   <a href=<tmpl_var expr="prev_page_link(page_count)">>Previous Page</a>
 </tmpl_unless>

 <tmpl_unless last>
   <a href=<tmpl_var expr="next_page_link(page_count)">>Next Page</a>
 </tmpl_unless>


So Page.tmpl is larger than before, but it makes more sense - all the Page logic is now in one place.


=head2 The publish() Methods

As Page.tmpl now needs to know about what page is currently being processed, the publish() method for both the Story element and then Page element needs to be overloaded.

B<Story>

The fill_template() method for Story needs to be able to pass page_count information to the publish() method for Page.  In turn, publish() will pass it to the fill_template() for Page.


 sub fill_template {

  my ($self, $story, $publisher) = @_;

  my $template = $named_params{template};

  # Get the list of pages into @pages
  my @pages = $self->match('/page');
  my @page_loop = ();
  my $page_count = 1;

  foreach my $page (@pages) {
    # each $page is an element
    push @page_loop, { page => $page->publish(story => $story,
                                              page_count => $page_count++,
                                              pages      => scaler @pages
                                             )
                     };
  }

  # populate template.
  $template->param(page_loop => \@page_loop);

 }


B<Page>

So now that the fill_template() method for Story has passed the page count information along, the fill_template() method for Page needs to use that information.

 sub fill_template {

  my $self = shift;
  my %named_parms = @_;

  my $template = $named_params{template};

  my $story = $named_params{story};
  my $page_count = $named_params{page_count};
  my $page_total = $named_params{page_total};

  # setup params
  if ($page_count == 0) {
     $template->param(first => 1);
  }
  if ($page_count == $page_total) {
     $template->param(last => 1);
  }

  $template->param(title => $story->title());

  # setup story slug
  $template->param(slug => $story->slug());

  # setup the page break variable
  $template->param(page_break => Krang::Publisher::PAGE_BREAK);

 }




=head2 Conclusion

B<Advantages>

=over

=item * This style is very flexible - the programmer can add functionality to the autofilled content without having to re-invent the wheel.

=item * Elements that are broken out into discrete scripts and templates can be reused between element trees.

=item * In this particular case bending the rules a bit allows the page formatting to be more logically grouped and easier to edit.

=back

B<Disadvantages>

=over

=item * Requires coding.

=item * Requires communication between template programmer and template designer since the variables and loops are somewhat different from the normal autofill setup.

=back

=head1 Handling Links to Other Stories

Links to other stories in Krang are all of the type Krang::ElementClass::StoryLink.  As a subclass of Krang::ElementClass, Krang::ElementClass::StoryLink objects do inherit all the methods of the parent class, but the publish() and fill_template() methods are overridden to handle the differences that exist within Krang::ElementClass::StoryLink objects.

B<Default Functionality>

=over

=item * Without a template:

If no corresponding template is found, the StoryLink object will simply return the URL to the connected story.

=item * Constructing a template:

If you decide to create a template, the following story attributes will be available as variables in the template: B<url>, B<title>

B<Example:>

 <a href="<tmpl_var escape=html url>"><tmpl_var title></a>

=back

=head1 Handling Media Objects

Links to media objects in Krang are all of the type Krang::ElementClass::MediaLink.  As a subclass of Krang::ElementClass, Krang::ElementClass::MediaLink objects do inherit all the methods of the parent class, but the publish() and fill_template() methods are overridden to handle the differences that exist within Krang::ElementClass::MediaLink objects.

B<Default Functionality>

=over

=item * Without a template:

If no corresponding template is found, the MediaLink object will simply return the URL to the referenced media file.

=item * Constructing a template:

If you decide to create a template, the following media attributes will be available as variables in the template: B<url>, B<title>, B<caption>

B<Example:>

 <img src="<tmpl_var escape=html url>">>
   <br>
   <tmpl_if title>
     <tmpl_var title>
   </tmpl_if>
   <br>
   <tmpl_if caption>
     <tmpl_var caption>
   </tmpl_if>

=back

=head2 Templates

B<Story.tmpl>

Returning to the template in Example 2, a small addition is made:


 <tmpl_loop page_loop>

   <html>

   <head>
     <title><tmpl_var title></title>
   </head>
   <body>

     <tmpl_if __first__>
        <h1><tmpl_var title></h1>
        <b><tmpl_var deck></b>
     </tmpl_if>

     <tmpl_loop element_loop>
        <tmpl_if is_paragraph>
          <p><tmpl_var paragraph></p>
        </tmpl_if>
        <tmpl_if is_pull_quote>
          <p><blockquote><i>
            <tmpl_var pull_quote>
          </i></blockquote></p>
        </tmpl_if>
        <tmpl_if is_photo>
            <tmpl_var photo>
        </tmpl_if>
     </tmpl_loop>

     <tmpl_unless __first__>
     <a href=<tmpl_var expr="prev_page_link(page_count)">>Previous Page</a>
     </tmpl_unless>

     <tmpl_unless __last__>
     <a href=<tmpl_var expr="next_page_link(page_count)">>Next Page</a>
     </tmpl_unless>

   </body>
   </html>

   <tmpl_var page_break>

 </tmpl_loop>


If you missed it, the entry is here - as a conditional within <tmpl_var element_loop>:

  <tmpl_if is_photo>
     <tmpl_var photo>
  </tmpl_if>



B<Photo.tmpl>

The template for the photo itself will be very small.  For example:


 <img src="<tmpl_var escape=html url>">
 <tmpl_if caption>
  <br><font size=-1><tmpl_var caption></font>
 </tmpl_if>


=head2 Methods

Generally, the default fill_template() method should be sufficient - but for reference purposes, overriding it would go as follows:

 sub fill_template {
    my $self = shift;
    my %named_params = @_;
    my $template = $named_params{template};
    my $element  = $named_params{element};

    # get linked object from element
    my $media = $self->data();

    # fill in URL to link to media  -- creates a varable based on element name.
    $template->param($element->name . "_url" => $media->url);
    # fill in image caption
    $template->param(caption => $media->caption);

 }


=head1 Working With Categories

Just as elements can have templates, each category may have one template associated with it called "category.tmpl".

For an example, let's imagine that we want to put a blue box around every page in our output. Instead of putting this HTML into our templates we'll do it in a category template.

=head2 Template - Category.tmpl

 <html>
 <head><tmpl_var title></head>
 <body>

 <table bgcolor=blue cellspacing=5 border=0><tr><td>

   <tmpl_var content>

 </td></tr></table>

 </body>
 </html>

One thing to note is that do the wrapping we had to move the <head> setup with the title var into the category template. This is an unfortunate fact-of-life for HTML since the <head> section has to precede the <body> most category templates will have to include it.

Internally, Krang will split this template into a header and footer, and replace the <tmpl_var content> with individual pages of Story content when it glues everything back together.


=head2 Methods

B<fill_template();>

Generally, the default fill_template() will suffice.  For reference, here's a sample:

 sub fill_template {

  my $self = shift;
  my %named_params = @_;

  my $story = $named_params{story};
  my $template = $named_params{template};

  $template->param(title => $story->title());

 }


=head1 Pagination

Variables for pagination will be built as a part of the Krang autofill process whenever it encounters a story element with the attribute C<pageable> set to 1 (Generally the C<page> element).  The following variables are made available:

=over 4

=item current_page_number

Contains the number (starting at 1) of the current page being built.

=item total_pages

Contains the total number of pages in the story.

=item previous_page_url

Contains the URL of the previous page in the story.  Will be empty if on the first page of the story.

=item next_page_url

Contains the URL of the next page in the story.  Will be empty if on the last page of the story.

=item first_page_url

Contains the URL for the first page in the story.

=item last_page_url

Contains the URL for the last page in the story.

=item is_first_page

Boolean that will be true if the current page is the first page.

=item is_last_page

Boolean that will be true if the current page is the last page.

=item pagination_loop

Each element in the loop contains variables that correspond to pages in the story, in page order.

The variables in each loop element are as follows:

=over 4

=item is_current_page

Boolean that will be true if C<page_number> = C<current_page_number>.

=item page_number

The number of the page in the story, starting at 1.

=item page_url

The URL for the page.  Will be empty if C<page_number> = C<current_page_number>.

=back

=back

=head2 Template Example

Again, using page.tmpl:

B<Page.tmpl>

 <!-- Test for first page here -->
 <tmpl_if is_first_page>
    <h1><tmpl_var title></h1>
    <b><tmpl_var deck></b>
 </tmpl_if>

 <tmpl_loop element_loop>
    <tmpl_if is_paragraph>
      <p><tmpl_var paragraph></p>
    </tmpl_if>
    <tmpl_if is_pull_quote>
      <p><blockquote><i>
    <tmpl_var pull_quote>
      </i></blockquote></p>
    </tmpl_if>
 </tmpl_loop>

 <!-- Pagination at the bottom of the page -->

 <P>Currently reading page <tmpl_var current_page_number> of <tmpl_var total_pages>.<BR>

 <tmpl_unless is_first_page>
   <a href="<tmpl_var previous_page_url>">Previous Page</a>
 </tmpl_unless>

 <tmpl_loop pagination_loop>
   <tmpl_if is_current_page>
     <tmpl_var page_number>
   <tmpl_else>
     <a href="<tmpl_var page_url>"><tmpl_var page_number></a>
   </tmpl_if>
 </tmpl_loop>

 <tmpl_unless is_last_page>
   <a href="<tmpl_var next_page_url>">Next Page</a>
 </tmpl_unless>

 <!-- /Pagination -->


=head1 Contributors

Contributors in Krang are attached directly to stories.  By default, they are made available to all templates as a list (tmpl_loop) of contributors, under the loop B<contrib_loop>.

=head2 Template Example

In this case, we want to publish contributors on every page of a given story.  Using the B<page.tmpl> from Example 4, the addition of a contributors loop goes as follows:

B<Page.tmpl>

 <tmpl_if first>
    <h1><tmpl_var title></h1>
    <b><tmpl_var deck></b>
 </tmpl_if>

 <tmpl_loop element_loop>
    <tmpl_if is_paragraph>
      <p><tmpl_var paragraph></p>
    </tmpl_if>
    <tmpl_if is_pull_quote>
      <p><blockquote><i>
    <tmpl_var pull_quote>
      </i></blockquote></p>
    </tmpl_if>
 </tmpl_loop>

 Contributors to this story:
 <tmpl_if contrib_loop>
   <tmpl_loop contrib_loop>
      <tmpl_var prefix> <tmpl_var first> <tmpl_var last><br>
      <tmpl_if contrib_type_loop>
         <tmpl_loop contrib_type_loop>
            Task ID:   <tmpl_var contrib_type_id><BR>
            Task Name: <tmpl_var contrib_type_name>
         </tmpl_loop>
      </tmpl_if>
   </tmpl_loop>
 <tmpl_else>
   None.
 </tmpl_if>

Now the contributors block can look confusing, but it's not.  The breakdown is as follows:

=over

=item *

Each element in B<contrib_loop> corresponds to a single contributor.

=item *

Within each element, the following variables are available (corresponding to the parameters available within the Contributers interface):

B<contrib_id>, B<prefix>, B<first>, B<middle>, B<last>, B<suffix> B<email>, B<phone>, B<bio>, B<url>

=item *

Finally, within each element, there is an additional loop: B<contrib_type_loop>.  This loop corresponds to the the various tasks a contributor may have performed (e.g. Writer, Illustrator).  Within this loop, there are two fields:

B<contrib_type_id>, B<contrib_type_name>

=back

=head2 Code Example

If you decide to override B<fill_template()> and still need contributors data, use the following example as your guide (again, derived from Example 4).


 sub fill_template {

  my $self = shift;
  my %named_parms = @_;

  my $template = $named_params{tmpl};
  my $publisher = $named_params{publisher};
  my $element   = $named_params{element};

  my $story = $publisher->story();

  $template->param(title => $story->title())
    if $template->query(name => 'title');

  # setup story slug
  $template->param(slug => $story->slug())
    if $template->query(name => 'slug');

  # setup the page break variable
  $template->param(page_break => Krang::Publisher::PAGE_BREAK)
    if $template->query(name => 'page_break');

  $template->param(contrib_loop => $self->_build_contrib_loop(@_))
    if ($template->query(name => 'contrib_loop);


 }
