#!/usr/bin/perl 
use warnings;
use strict;

# set to location of mysql_dump, or leave with no path to search PATH
use constant MYSQL_DUMP => 'mysqldump';

=head1 NAME

krang_backup - make a backup of a Krang installation

=head1 SYNOPSIS

Create a backup named C<krang-`hostname`-YYYYMMDD.kba>:

  bin/krang_backup

Create a compressed backup named C<krang-`hostname`-YYYYMMDD.kba.gz>:

  bin/krang_backup --compress

Create a backup named C<backup.kba>:

  bin/krang_backup backup.kba

=head1 DESCRIPTION

This script creates a backup of a Krang installation.  The C<.kba> (or
C<.kba.gz>) file produced may be later fed to C<krang_install --FromBackup>
to recreate the Krang installation.

For more details, see L<docs/ops_backup.pod>.

=head1 OPTIONS

=over 4

=item --compress

If this option is specified then the resulting file will be compressed
using gzip.  For large installations this can be very slow.

=item --verbose

Prints a running dialog of what's happening.  Repeat for more details.

=item --help

=item --man

=back

=cut

use File::Spec::Functions qw(catdir catfile splitdir rel2abs);
use FindBin qw($RealBin);
use Config;

BEGIN {
    # Find a KRANG_ROOT based on path to bin
    my @dir = splitdir($RealBin);
    $ENV{KRANG_ROOT} ||= catdir(@dir[0 .. $#dir - 1]);

    # use $KRANG_ROOT/lib for modules
    my $lib    = catdir($ENV{KRANG_ROOT}, "lib");
    $ENV{PERL5LIB} = $ENV{PERL5LIB} ? "$ENV{PERL5LIB}:${lib}" : 
      "${lib}";
    unshift @INC, $lib, "$lib/".$Config{archname};

    # load Krang::Conf (don't need to load Krang here because we won't
    # be slinging elements)
    eval { require Krang::Conf };
    die <<"END" if $@;
######################################################################

Cannot load Krang.

Error message:

$@

######################################################################
END
}

# use first instance if one isn't set.  Backups are installation wide
# anyway.
BEGIN { $ENV{KRANG_INSTANCE} ||= (Krang::Conf->instances)[0]; }

use Krang::Script;
use Krang::Conf qw(KrangRoot InstanceDBName DBUser DBPass);
use Getopt::Long;
use Pod::Usage;
use Sys::Hostname;
use File::Path;
use Cwd qw(cwd);

my ($help, $man, $compress);
my $verbose = 0;

pod2usage(2) unless
  GetOptions(help       => \$help,
             man        => \$man,
             'verbose+' => \$verbose,
             'compress' => \$compress,
            );
pod2usage(1)             if $help;
pod2usage(-verbose => 2) if $man;

# figure out filename
my $file;
if (@ARGV == 1) {
    $file = shift @ARGV;
    die "Filename '$file' should end in .gz to be used with --compress.\n"
      if $compress and $file !~ /.gz$/;
} elsif (@ARGV) {
    pod2usage("Too many arguments to $0.");
} else {
    my ($y, $m, $d) = (localtime)[5,4,3];
    $file = sprintf('krang-%s-%04d%02d%02d.%s', 
                    hostname, ($y+1900), $m, $d, ($compress ?'kba.gz':'kba'));
}
die "File '$file' already exists.\n" if -e $file;
print STDERR "Creating backup in '$file'...\n\n" if $verbose;

# make backup directory if needed
my $dir = catdir(KrangRoot, 'data', 'backup');
mkpath([$dir]) unless -d $dir;

# dump all databases into data/backup
foreach my $instance (Krang::Conf->instances) {
    Krang::Conf->instance($instance);

    my $cmd = MYSQL_DUMP . ' -u' . DBUser .
      (DBPass ? (' -p' . DBPass) : '') . ' -e -l --databases ' . 
        InstanceDBName . 
        ' >' . catfile($dir, InstanceDBName . '.sql');
    print STDERR "Dumping " . InstanceDBName . " database with command:" .
      "\n\t$cmd\n\n"
        if $verbose;
    system($cmd);
}

# create .kba tar file
my $full_file = rel2abs($file);
my $cmd = "tar cp" . ($verbose > 1 ? "v" : "") . 
  "f $full_file --exclude $full_file --exclude $file " . 
  ($compress ? " --gzip " : "") .  " .";

print STDERR "Creating backup archive with command:\n\t$cmd\n\n"
  if $verbose;

# go to KrangRoot if not already there and run the tar command
chdir(KrangRoot) or die $!;
system($cmd);

# clean up backup dir
rmtree([$dir]);

print "Backup complete in $file.\n";
exit 0;
