#!/usr/bin/perl
use warnings;
use strict;
use Getopt::Long;
use Pod::Usage;

=pod

=head1 NAME

krang_floodfill - create fake Krang data the easy way

=head1 SYNOPSIS

  krang_floodfill --sites 5 --cats 10

=head1 DESCRIPTION

This script creates fake Krang data for use during testing.  It uses
the standard UNIX dict file in F</usr/dict/words> (or
F</usr/share/dict/words> if that's not available) to generate random
text.

=head1 OPTIONS

  --sites    - number of sites to create, defaults to 3

  --cats     - number of categories to create, defaults to 15

  --contribs - number of contributors to create, defaults to 50

  --media    - number of media objects to create, defaults to 25

  --stories  - number of stories to create, defaults to 50

  --templates- number of templates to create, defaults to 50

  --users    - number of users to create, defaults to 50

=cut

use File::Spec::Functions qw(catdir catfile splitdir rel2abs);
use FindBin qw($RealBin);
use Config;

BEGIN {
    # Find a KRANG_ROOT based on path to bin
    my @dir = splitdir($RealBin);
    $ENV{KRANG_ROOT} ||= catdir(@dir[0 .. $#dir - 1]);

    # use $KRANG_ROOT/lib for modules
    my $lib    = catdir($ENV{KRANG_ROOT}, "lib");
    $ENV{PERL5LIB} = $ENV{PERL5LIB} ? "$ENV{PERL5LIB}:${lib}" :
      "${lib}";
    unshift @INC, $lib, "$lib/".$Config{archname};

    # load Krang::Conf (don't need to load Krang here because we won't
    # be slinging elements)
    eval { require Krang::Conf };
    die <<"END" if $@;
######################################################################

Cannot load Krang.

Error message:

$@

######################################################################
END
}

use Krang::Script;
use Krang::Conf qw(KrangRoot);
use Krang::ElementLibrary;
use Krang::Site;
use Krang::Category;
use Krang::Pref;
use Krang::User;
use Krang::Template;

use Time::Piece;
use Imager;

my ($help, $man);
my $sites    = 3;
my $cats     = 15;
my $contribs = 50;
my $stories  = 50;
my $media    = 25;
my $users    = 50;
my $templates = 50;
pod2usage(2) unless
  GetOptions(help         => \$help,
             man          => \$man,
             'sites=s'    => \$sites,
             'cats=s'     => \$cats,
             'contribs=s' => \$contribs,
             'stories=s'  => \$stories,
             'media=s'    => \$media,
	     'users=s'	  => \$users,
             'templates=s'=> \$templates,
            );

pod2usage(1)             if $help;
pod2usage(-verbose => 2) if $man;

# create sites
my (@sites, @cats);
for(1 .. $sites) {
    my $name = get_word();
    my $site = Krang::Site->new(publish_path => "/tmp/${name}_publish/",
                                preview_path => "/tmp/${name}_preview/",
                                preview_url  => "preview.$name.com",
                                url          => "$name.com");
    eval { $site->save() };
    redo if $@ and $@ =~ /duplicate/;
    print STDERR "Created site " . $site->url . "...\n";
    push(@sites, $site);

    # remember root category
    my ($root) = Krang::Category->find(site_id => $site->site_id);
    push(@cats, $root);
}


# create categorie
for(1 .. $cats) {
    my $cname = get_word();
    my $cat = Krang::Category->new(dir       => $cname,
                                   parent_id => $cats[int(rand(scalar(@cats)))]->category_id);
    eval { $cat->save() };
    redo if $@ and $@ =~ /duplicate/;
    print STDERR "Created category " . $cat->url . "...\n";
    push(@cats, $cat);
}


# create contribs
my %types = Krang::Pref->get('contrib_type');
my @contribs;
for(1 .. $contribs) {
    my $fname = ucfirst(get_word());
    my $lname = ucfirst(get_word());
    my $mname = int(rand(2)) ? ucfirst(get_word()) : "";
    my $prefix = ("Sir", "General", "Her Royal Highness",
                  ("") x 20)[int(rand(23))];
    my $suffix = ("Jr.", "Sr.", "III", "IV",
                  ("") x 20)[int(rand(24))];
    my @types = grep { int(rand(2)) } keys %types;
    @types = (keys %types)[0] unless @types;

    my $contrib = Krang::Contrib->new(prefix => $prefix,
                                      first  => $fname,
                                      middle => $mname,
                                      last   => $lname,
                                      email  => "$fname\@$lname.com",
                                      phone  => "1-800-$lname",
                                      bio    => join(' ',
                                                     map { get_word() }
                                                         (0 .. 20)),
                                      url => "http://$fname.$lname.com");
    $contrib->contrib_type_ids(@types);
    eval { $contrib->save() };
    redo if $@ and $@ =~ /duplicate/;
    push(@contribs, $contrib);
    print STDERR "Created contributor " .
      join(' ', grep { $_ } ($prefix, $fname, $mname, $lname, $suffix)) .
        " (" . join(', ', map { $types{$_} } @types) . ")" .
           "\n";
}

# create media
my @media;
for my $media_count (1 .. $media) {
    # create a random image
    my ($x, $y);
    my $img = Imager->new(xsize => $x = (int(rand(300) + 50)),
                          ysize => $y = (int(rand(300) + 50)),
                          channels => 3,
                         );

    # fill with a random color
    $img->box(color => Imager::Color->new(map { int(rand(255)) } 1 .. 3),
              filled => 1);

    # draw some boxes and circles
    for (0 .. (int(rand(8)) + 2)) {
        if ((int(rand(2))) == 1) {
            $img->box(color =>
                      Imager::Color->new(map { int(rand(255)) } 1 .. 3),
                      xmin => (int(rand($x - ($x/2))) + 1),
                      ymin => (int(rand($y - ($y/2))) + 1),
                      xmax => (int(rand($x * 2)) + 1),
                      ymax => (int(rand($y * 2)) + 1),
                      filled => 1);
        } else {
            $img->circle(color =>
                         Imager::Color->new(map { int(rand(255)) } 1 .. 3),
                         r => (int(rand(100)) + 1),
                         x => (int(rand($x)) + 1),
                         'y' => (int(rand($y)) + 1));
        }
    }

    # pick a format
    my $format = (qw(jpg png gif))[int(rand(3))];

    $img->write(file => catfile(KrangRoot, "tmp", "tmp.$format"));
    my $fh = IO::File->new(catfile(KrangRoot, "tmp", "tmp.$format"))
      or die "Unable to open tmp/tmp.$format: $!";

    # Pick a type
    my %media_types = Krang::Pref->get('media_type');
    my @media_type_ids = keys(%media_types);
    my $media_type_id = $media_type_ids[int(rand(scalar(@media_type_ids)))];

    # create a media object
    my $media = Krang::Media->new(title      => join(" ",
                                                     map {ucfirst(get_word())}
                                                     (1..(int(rand(3)) + 2))),
                                  filename   => get_word() . ".$format",
                                  filehandle => $fh,
                                  category_id => $cats[int(rand(scalar(@cats)))]->category_id,
                                  media_type_id => $media_type_id,
                                  );
    eval { $media->save };
    if ($@) {
        if (ref($@) and ref($@) eq 'Krang::Media::DuplicateURL') {
            redo;
        } else {
            die $@;
        }
    }
    push(@media, $media);
    unlink(catfile(KrangRoot, "tmp", "tmp.$format"));
    print STDERR "Created Media " . $media->url . "\n";
}


# create stories
my @stories;
for my $story_count (1 .. $stories) {

    # determine categories, up to 3
    my @c = ($cats[int(rand(scalar(@cats)))]);
    push(@c, $cats[int(rand(scalar(@cats)))])
      if (int(rand(2)));
    push(@c, $cats[int(rand(scalar(@cats)))])
      if (int(rand(2)));
    my %c = map { ($_->category_id,$_) } @c;
    @c = values(%c);

    # create story
    my $story;

    eval {
        $story = Krang::Story->new(title     => join(" ",
                                                     map {ucfirst(get_word())}
                                                     (1..(int(rand(3)) + 2))),
                                   slug       => get_word(),
                                   categories => \@c,
                                   cover_date => get_date(),
                                   class      => "article");
    };
    if ($@) {
        if (ref($@) and ref($@) eq 'Krang::Story::DuplicateURL') {
            redo;
        } else {
            die $@;
        }
    }

    # add some contribs, up to 5
    my @con;
    for(1 .. (int(rand(4)) + 1)) {
        my $contrib = $contribs[int(rand(scalar(@contribs)))];
        my @types = $contrib->contrib_type_ids;
        $contrib->selected_contrib_type($types[int(rand(scalar(@types)))]);
        push(@con, $contrib)
          unless grep { $_->contrib_id == $contrib->contrib_id } @con;
    }
    $story->contribs(@con);

    # make a multi-page story
    my $element = $story->element;
    my $deck = join(" ", map { get_word() } (1 .. ((int(rand(100)))+1)));
    $element->child('deck')->data($deck);
    $element->add_child(class => "page") for (1 .. ((int(rand(5)))+1));

    # foreach page, add some paragraphs and photos
    foreach my $page (grep { $_->name eq 'page' } $element->children()) {
        $page->child('header')->data(join(" ", map { ucfirst(get_word()) } (1 .. ((int(rand(6)))+1))));
        foreach my $obj_num (1 .. ((int(rand(20)))+1)) {
            if ((int(rand(3))) != 1) {
                my $para = join(" ",
                                map { get_word() } 
                                (0 .. ((int(rand(100)))+1)));
                $page->add_child(class => "paragraph",
                                 data => $para);
            } else {
                $page->add_child(class => "photo",
                                 data => $media[int(rand(scalar(@media)))]);
            }
        }
    }

    # add some keywords
    $element->child('fancy_keyword')->data([ map { get_word() } (1 .. ((int(rand(10)))+1))]);

    $story->save;

    print STDERR "Created Story " . $story->url . "\n";
    push(@stories, $story);
}

# create templates
my @templates;
for (1..$templates) {
    my @elements = Krang::ElementLibrary->element_names;
    my $blrplt = <<TMPL;
I'm a %s and I'm OK.  I work all night and I play all day.
<tmpl_var %s>
TMPL
    my $element = $elements[int(rand(scalar @elements))];
    my $content = sprintf($blrplt, $element, $element);
    my $category_id = $cats[int(rand(scalar(@cats)))]->category_id;
    my $tmpl = Krang::Template->new(category_id		=> $category_id,
                                    content		=> $content,
                                    element_class_name	=> $element,);
    eval {$tmpl->save};
    redo if $@;
    push @templates, $tmpl;
    print STDERR "Created Template: ", $tmpl->url, "($element)\n";
}

# create users
my %groups = %Krang::User::user_groups;
my @users;
for(1 .. $users) {
    my $login = lc(get_word());
    my $fname = ucfirst(get_word());
    my $lname = ucfirst(get_word());
    my $password = lc(get_word());
    my @groups = grep { int(rand(5)) } keys %groups;
    @groups = (keys %groups)[0] unless @groups;

    my $user = Krang::User->new(login 		=> $login,
                                first_name  	=> $fname,
                                last_name   	=> $lname,
                                email  		=> "$fname\@$lname.com",
                                password	=> $password,
                                phone		=> "1-800-$lname",);
    $user->group_ids(@groups);
    eval { $user->save() };
    redo if $@ and $@ =~ /duplicate/;
    push(@users, $user);
    print STDERR "Created user " .
      join(' ', grep { $_ } ("$login:", $fname, $lname)) .
        " (" . join(', ', map { $groups{$_} } @groups) . ")" .
          "\n";
}

# get a random date, with time set to midnight
sub get_date {
    my $m = int rand(11) + 1;
    my $d = int rand(27) + 1;
    my $y = int rand(50) + 1975;
    return Time::Piece->strptime("$m/$d/$y", '%m/%d/%Y');
}


# get a random word
BEGIN {
    my @words;
    open(WORDS, "/usr/dict/words")
      or open(WORDS, "/usr/share/dict/words")
        or die "Can't open /usr/dict/words or /usr/share/dict/words: $!";
    while (<WORDS>) {
        chomp;
        push @words, $_;
    }
    srand (time ^ $$);

    sub get_word {
        return lc $words[int(rand(scalar(@words)))];
    }
}

# we outy
exit(0);
