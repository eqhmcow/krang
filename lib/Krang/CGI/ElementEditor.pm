package Krang::CGI::ElementEditor;
use strict;
use warnings;

=head1 NAME

Krang::CGI::ElementEditor - element editor CGI class

=head1 SYNOPSIS

  http://krang/instance_name/element_editor

=head1 DESCRIPTION

Element editor CGI for Krang.  This CGI is embedded in the Story and
Category editors.  It allows users to edit the contents of the element
tree attached to the story or category.

=head1 INTERFACE

None.

=cut

use Krang::ElementLibrary;
use Krang::Element;
use Krang::DB qw(dbh);
use Carp qw(croak);
use Krang::Session qw(%session);

use base 'Krang::CGI';

sub setup {
    my $self = shift;
    $self->start_mode('choose_top_level');
    $self->mode_param('e_rm');
    $self->run_modes(choose_top_level => \&choose_top_level,
                     create           => \&create,
                     edit             => \&edit,
                     add              => \&add,
                     save             => \&save,
                     save_and_jump    => \&save_and_jump,
                     save_and_stay    => \&save_and_stay,
                     delete_children  => \&delete_children,
                     delete           => \&delete,
                     reorder          => \&reorder,
                    );
}

# show the top_level chooser (this won't be used in the final version
# of the editor, but it's need to allow it to be tested independently)
sub choose_top_level {
    my $self = shift;
    my $query = $self->query();
    my $dbh = dbh();
    my $template = $self->load_tmpl("element_editor_choose.tmpl",
                                    associate => $query);

    # whip up top level picker
    my @values = Krang::ElementLibrary->top_levels;
    my %labels = map { ($_, Krang::ElementLibrary->top_level(name => $_)
                                                  ->display_name) } 
                   @values;
    $template->param(top_level_select => 
                     $query->popup_menu(-name   => "top_level",
                                        -values => \@values,
                                        -labels => \%labels));

    # show a list of existing elements
    my $result = $dbh->selectall_arrayref('SELECT root_id, class FROM element WHERE parent_id IS NULL ORDER BY root_id');
    my @element_loop;
    foreach my $row (@$result) {
        push(@element_loop, { element_id => $row->[0],
                              name       => $row->[1] });
    }
    $template->param(element_loop => \@element_loop);


    return $template->output();
}

# create a new top-level element
sub create {
    my $self      = shift;
    my $query     = $self->query();
    my $top_level = $query->param("top_level") 
      or croak("Missing top_level param!");

    # create a new instance and save it in the session
    my $element = Krang::Element->new(class => $top_level);
    $session{element} = $element;

    # setup ids and toss to edit
    $query->param(path => '/');
    $query->param(root_id => undef);
    return $self->edit;
}


# show the edit screen
sub edit {
    my $self = shift;
    my $query = $self->query();
    my $template = $self->load_tmpl("element_editor_edit.tmpl",
                                    associate => $query,
                                    loop_context_vars => 1);
    
    my $path    = $query->param('path') || '/';
    my $root_id = $query->param('root_id');

    # find the root element, loading from the session or the DB
    my $root;
    if ($root_id) {
        $session{element} = 
          $root = Krang::Element->find(element_id => $root_id);        

        croak("Unable to load element from DB by id '$root_id'")
          unless defined $root;
        $query->param(root_id => undef);
    } else {
        $root = $session{element};
        croak("Unable to load element from session.") 
          unless defined $root;
    }

    # find the element being edited using path
    my $element = _find_element($root, $path);

    # crumbs let the user jump up the tree
    my $pointer = $element;
    my @crumbs;
    do {
        unshift(@crumbs, { name => $pointer->display_name,
                           path => $pointer->xpath });
        $pointer = $pointer->parent;
    } while ($pointer);
    $template->param(crumbs => \@crumbs);

    # load invalid list, generated by save()
    my %invalid;
    %invalid = map { ($_ => 1) } (split(',', $query->param('invalid')))
      if $query->param('invalid');

    my @child_loop;
    my $index = 0;
    my $order;
    my @children = $element->children;
    
    # figure out list of slots that are reorderable
    my @avail_ord = grep { $children[$_-1]->reorderable } (1 .. @children);
        
    foreach my $child (@children) {        
        push(@child_loop, {
                           form         => $child->input_form(query => $query,
                                                              order => $index),
                           name         => $child->display_name(),
                           path         => $child->xpath(),
                           ($child->reorderable ? 
                            (order_select =>
                             $query->popup_menu(-name => "order_$index",
                                                -values => \@avail_ord,
                                                -default => $index + 1)) : ()),
                           is_container => $child->is_container,
                           index        => $index,
                           reorderable  => $child->reorderable,
                           allow_delete => $child->allow_delete,
                           invalid       => $invalid{$index},
                          });
        $index++;
    }
    $template->param(child_loop => \@child_loop);

    # whip up top level picker
    my @available =  $element->available_child_classes();
    my @values = map { $_->name } @available;
    my %labels = map { ($_->name, $_->display_name) } @available;
    $template->param(child_select => 
                     $query->popup_menu(-name   => "child",
                                        -values => \@values,
                                        -labels => \%labels));


    return $template->output();    
}


# add sub-elements
sub add {
    my $self = shift;
    my $query = $self->query();

    # gather params
    my $path    = $query->param('path') || '/';
    my $child   = $query->param('child');

    # find our element
    my $root    = $session{element};
    my $element = _find_element($root, $path);

    # add the child element and save the element tree
    my $kid = $element->add_child(class => $child);

    # start editing the new element if it has children
    $query->param(path => $kid->xpath()) if $kid->is_container;
    
    $query->param(alert => "Added " . $kid->display_name() . " to " . 
                           $element->display_name() . ".");

    # toss to edit
    return $self->edit();
}

# finds an element given the root and a path, optionally building @crumbs loop
sub _find_element {
    my ($root, $path, $crumbs) = @_;

    my ($element) = $root->match($path);
    croak("Unable to find element for path '$path'.")
      unless $element;

    return $element;
}

sub save_and_stay {
    my $self = shift;
    return $self->save(stay => 1);
}

sub save_and_jump {
    my $self = shift;
    my $query = $self->query();
    print STDERR "in save and jump: " . $query->param("jump_to") . "\n";
    return $self->save(jump_to => $query->param("jump_to"));
}

sub save {
    my $self = shift;
    my %arg = @_;
    my $query = $self->query();
    my $template = $self->load_tmpl("element_editor_edit.tmpl",
                                    associate => $query,
                                    loop_context_vars => 1);

    my $path    = $query->param('path') || '/';
    my $root_id = $query->param('root_id');

    my $root = $session{element};
    my $element = _find_element($root, $path);

    # validate data
    my @msgs;
    my $clean = 1;
    my $index = 0;
    my @invalid;
    foreach my $child ($element->children()) {
        my ($valid, $msg) = $child->validate(query => $query);
        if (not $valid) {
            push @msgs, "* $msg";
            push @invalid, $index;
            $clean = 0;
        }
        $index++;
    }

    # toss back to edit with an error message if not clean
    if (not $clean) {
        my %seen;
        $query->param(alert => join('<br>', grep { ++$seen{$_} == 1 } @msgs));
        $query->param(invalid => join(',', @invalid));
        return $self->edit();
    }

    # save data
    $index = 0;
    foreach my $child ($element->children()) {
        $child->load_query_data(query => $query);
        $index++;
    }

    # save element tree to DB if this is the root and this isn't an
    # intermediate save.
    $root->save() unless $element->parent() or $arg{jump_to};
    $query->param(alert => $element->display_name() . " saved.")
      unless $query->param('alert');

    # save and stay?
    return $self->edit() if exists $arg{stay};

    # save and jump?
    if (exists $arg{jump_to}) {
        $query->param(path => $arg{jump_to});
        return $self->edit();
    }
                      
    # go up a level
    if ($element->parent()) {
        $query->param(path => $element->parent->xpath);
        return $self->edit();
    } else {
        return $self->choose_top_level();
    }
}

# reorder sub-elements
sub reorder {
    my $self = shift;
    my $query = $self->query();
    my $template = $self->load_tmpl("element_editor_edit.tmpl",
                                    associate => $query,
                                    loop_context_vars => 1);

    my $path = $query->param('path') || '/';
    my $root_id = $query->param('root_id');

    my $root = Krang::Element->find(element_id => $root_id);    
    my $element = _find_element($root, $path);

    # compute new list of children
    my @new_children;
    my @old_children = $element->children();
    my @msgs;
    for my $index (0 .. @old_children - 1) {
        if ($query->param("order_$index")) {
            my $requested_index = $query->param("order_$index");
            # deal with collisions
            while(defined $new_children[$requested_index]) {
                $requested_index++;
            }
            $new_children[$requested_index] = $old_children[$index];
            $query->delete("order_$index");
        } else {
            push @new_children, $old_children[$index];            
        }
    }
    # compress empty space
    @new_children = grep { defined $_ } @new_children;

    # save list
    $element->children(@new_children);
    $root->save();

    # toss to edit
    return $self->edit();    
}

# delete this element
sub delete {
    my $self  = shift;
    my $query = $self->query();

    my $path = $query->param('path') || '/';
    my $root_id = $query->param('root_id');

    my $root = $session{element};
    my $element = _find_element($root, $path);

    my $parent = $element->parent();
    if (not $parent) {
        # this is the root, delete it from the DB if it has an ID
        $element->delete()
          if $element->element_id;
        return $self->choose_top_level();
    }

    # remove this element from parent    
    $parent->children(grep { $_ != $element } $parent->children());
    
    $query->param(path => $parent->xpath());
    $query->param(alert => 'Removed ' . $element->display_name . ' from ' .
                           $parent->display_name());
    return $self->edit();
}

# delete sub-elements
sub delete_children {
    my $self = shift;
    my $query = $self->query();

    my $path = $query->param('path') || '/';
    my $root_id = $query->param('root_id');

    my $root = $session{element};
    my $element = _find_element($root, $path);

    # compute new list of children
    my @new_children;
    my @old_children = $element->children();
    my @msgs;
    for my $index (0 .. @old_children - 1) {
        if ($query->param("remove_$index")) {
            push @msgs, "Removed " . $old_children[$index]->display_name;
            $query->delete("remove_$index");
        } else {
            push @new_children, $old_children[$index];            
        }
    }
    # save list
    $element->children(@new_children);

    # generate alert and toss to save
    @msgs = ('No elements marked for deletion!') unless @msgs;
    $query->param(alert => join('<br>', @msgs));
    return $self->edit();
}

1;
