package Krang::CGI::ElementEditor;
use strict;
use warnings;

=head1 NAME

Krang::CGI::ElementEditor - element editor CGI base class

=head1 SYNOPSIS

  http://krang/instance_name/element_editor

=head1 DESCRIPTION

Element editor CGI for Krang.  This module is a super-class upon which
element editing CGIs (story and category editors) may be built.  It
supplies some full run-modes as well as some helper functions which
the child classes will use to implement their run-modes.

=head1 INTERFACE

=head2 Provided Run Modes

This module implements the following run modes:

=over

=item add

Called when the user clicks the "Add Element" button in the element
editor.  Returns to the 'edit' mode when complete.

=item delete_children

Called to delete sub-elements.  Returns to the 'edit' mode when
complete without modifying 'path'.

=item reorder

Called to reorder sub-elements.  Returns to the 'edit' mode when
complete without modifying 'path'.

=item delete_element

Called to delete an element.  This should called when the user clicks
the delete button, except on the root screen where delete refers to
the containing object.

=back

=head2 Provided Methods

The following methods are available to perform interface tasks
involving elements.  These should be called from within the child
class' run-modes.

=over

=item $self->element_edit(template => $template, element  => $element)

Called to fill in template parameters for the element editor
(F<ElementEditor/edit.tmpl>).  Both the template and element are
required parameters.  When it returns the template will contain all
necessary parameters to display the element editor.

=item $self->element_view(template => $template, element  => $element)

Called to fill in template parameters for the element viewer
(F<element_editor_view.tmpl>).  Both the template and element are
required parameters.  When it returns the template will contain all
necessary parameters to display the element viewer.

=item $ok = $self->element_save(element  => $element)

Called to save element data to the element passed to the method.  Will
return a boolean value indicating whether or not the save was
successful.  If the save was not successful then messages will have
been registered with Krang::Message to explain the problem to the
user.

=back

=head2 Required Runmodes

You must implement the following run-modes in any child class:

=over 4

=item edit

The edit run mode is called after a number of the run-modes available
complete their work.

=item save_and_add

This mode should do a save and then go to the add run-mode described
above.  It will only be called when adding container elements.

=item save_and_jump

This mode is called with a 'jump_to' parameter set.  It must save,
substitute the 'jump_to' value for 'path' in query and return to edit.

=item save_and_go_up

This mode should save, hack off the last part of path (s!/.*$!!) and
return to edit.

=back

=head2 Required Methods

Your sub-class must define the following helper methods:

=over

=item _get_element

Must return the element currently being edited from the session.

=back

=cut

use Krang::ElementLibrary;
use Krang::Element;
use Krang::DB qw(dbh);
use Carp qw(croak);
# use Krang::Session qw(%session);
use Krang::Log qw(debug assert affirm ASSERT);
use Krang::Message qw(add_message get_messages);
use base 'Krang::CGI';

sub setup {
    my $self = shift;
    $self->start_mode('fake');
    $self->mode_param('rm');
    $self->run_modes(
                     fake             => sub { "OK" },
                     add              => 'add',
                     delete_children  => sub { shift->revise('delete') },
                     reorder          => sub { shift->revise('reorder') },
                     delete_element   => 'delete_element',
                    );
}

# show the edit screen
sub element_edit {
    my ($self, %args) = @_;
    my $query = $self->query();
    my $template = $args{template};
    my $path    = $query->param('path') || '/';

    # pass to bulk edit it bulk editing
    return $self->element_bulk_edit(%args) if $query->param('bulk_edit');

    # find the root element, loading from the session or the DB
    my $root = $args{element};
    croak("Unable to load element from session.") 
      unless defined $root;

    # find the element being edited using path
    my $element = _find_element($root, $path);

    # crumbs let the user jump up the tree
    my $pointer = $element;
    my @crumbs;
    do {
        unshift(@crumbs, { name => $pointer->display_name,
                           path => $pointer->xpath });
        $pointer = $pointer->parent;
    } while ($pointer);
    $template->param(crumbs => \@crumbs) unless @crumbs == 1;

    # load invalid list, generated by save()
    my %invalid;
    %invalid = map { ($_ => 1) } (split(',', $query->param('invalid')))
      if defined $query->param('invalid');

    my @child_loop;
    my $index = 0;
    my $order;
    my @children = $element->children;
    
    # figure out list of slots that are reorderable
    my @avail_ord = grep { $children[$_-1]->reorderable } (1 .. @children);
        
    foreach my $child (@children) {        
        push(@child_loop, {
                           form         => $child->input_form(
                                                query   => $query,
                                                order   => $index,
                                                invalid => $invalid{$index},
                                                             ),
                           name         => $child->display_name(),
                           path         => $child->xpath(),
                           (order_select =>
                             $child->reorderable ? 
                             $query->popup_menu(-name => "order_$index",
                                                -values => \@avail_ord,
                                                -default => $index + 1,
                                                -override => 1) : 
                             ($index + 1) .  
                             $query->hidden(-name     => "order_$index",
                                            -default  => $index + 1,
                                            -override => 1)),
                           is_container => $child->is_container,
                           index        => $index,
                           allow_delete => $child->allow_delete,
                           required     => $child->required,
                           invalid      => $invalid{$index},
                          });
        $index++;
    }
    $template->param(child_loop => \@child_loop);

    # whip up child element picker from available classes
    my @available =  $element->available_child_classes();
    if (@available) {
        my @values = map { $_->name } @available;
        my %labels = map { ($_->name, $_->display_name) } @available;
        $template->param(child_select => 
                         $query->popup_menu(-name   => "child",
                                            -values => \@values,
                                            -labels => \%labels));
    }

    # bulk edit selector
    my @bulk_edit = grep { $_->bulk_edit } $element->class->children;
    if (@bulk_edit) {
        my @values = map { $_->name } @bulk_edit;
        my %labels = map { ($_->name, $_->display_name) } @bulk_edit;
        $template->param(bulk_edit_select => 
                         $query->popup_menu(-name   => "bulk_edit_child",
                                            -values => \@values,
                                            -labels => \%labels));
    }

    $template->param(container_loop => 
                     [ map { { name => $_->name } } 
                         grep { $_->is_container } @available ]);

}

sub element_bulk_edit {
    my ($self, %args) = @_;
    my $query = $self->query();
    my $template = $args{template};
    my $path    = $query->param('path') || '/';

    # find the root element, loading from the session or the DB
    my $root = $args{element};
    croak("Unable to load element from session.") 
      unless defined $root;

    # find the element being edited using path
    my $element = _find_element($root, $path);

    # get list of existing elements to be bulk edited
    my $name = $query->param('bulk_edit_child');
    my @children = grep { $_->name eq $name } $element->children;

    my $sep = $query->param('bulk_edit_sep');
    $sep = (defined $sep and length $sep) ? $sep : "__TWO_NEWLINE__";

    $template->param(bulk_edit_sep_selector => scalar
                     $query->radio_group(-name => 'new_bulk_edit_sep',
                                         -values => [ "__TWO_NEWLINE__",
                                                      "<p>",
                                                      "<br>" ],
                                         -labels => { "__TWO_NEWLINE__" =>
                                                      "One Blank Line" },
                                         -default => $sep,
                                         -override => 1,
                                        ),
                     bulk_edit_sep => $sep);
    
    $template->param(bulk_edit => 1,
                     bulk_data => join(($sep eq "__TWO_NEWLINE__" ? 
                                        "\n\n" : "\n" . $sep . "\n"), 
                                       grep { defined } 
                                         map { $_->data } @children));

    # crumbs let the user jump up the tree
    my $pointer = $element;
    my @crumbs = ({ name => $element->class->child($name)->display_name });
    do {
        unshift(@crumbs, { name => $pointer->display_name,
                           path => $pointer->xpath });
        $pointer = $pointer->parent;
    } while ($pointer);
    $template->param(crumbs => \@crumbs) unless @crumbs == 1;
}


sub element_view {
    my ($self, %args) = @_;
    my $query    = $self->query();
    my $template = $args{template};
    my $root     = $args{element}; 
    my $path    = $query->param('path') || '/';

    # find the element being edited using path
    my $element = _find_element($root, $path);

    # crumbs let the user jump up the tree
    my $pointer = $element;
    my @crumbs;
    do {
        unshift(@crumbs, { name => $pointer->display_name,
                           path => $pointer->xpath,
                         });
        $pointer = $pointer->parent;
    } while ($pointer);
    $template->param(crumbs => \@crumbs) unless @crumbs == 1;

    my @child_loop;
    my @children = $element->children;
    
    # figure out list of slots that are reorderable
    foreach my $child (@children) {        
        push(@child_loop, {
                           data         => $child->view_data(),
                           name         => $child->display_name(),
                           path         => $child->xpath(),
                           is_container => $child->is_container,
                          });
    }
    $template->param(child_loop => \@child_loop,
                     parent_path => ($element->parent ?
                                     $element->parent->xpath : 0),
                    );
    
}

# add sub-elements
sub add {
    my $self = shift;
    my $query = $self->query();

    # gather params
    my $path    = $query->param('path') || '/';
    my $child   = $query->param('child');

    # find our element
    my $root    = $self->_get_element;
    my $element = _find_element($root, $path);

    # add the child element and save the element tree
    my $kid = $element->add_child(class => $child);

    # start editing the new element if it has children
    $query->param(path => $kid->xpath()) if $kid->is_container;
    
    add_message('added_element', child  => $kid->display_name(),
                                 parent => $element->display_name());

    # toss to edit
    return $self->edit();
}

# finds an element given the root and a path, optionally building @crumbs loop
sub _find_element {
    my ($root, $path, $crumbs) = @_;

    my ($element) = $root->match($path);
    croak("Unable to find element for path '$path'.")
      unless $element;

    return $element;
}

sub element_bulk_save {
    my ($self, %args) = @_;
    my $query = $self->query();
    my $path    = $query->param('path') || '/';

    my $root = $args{element};
    my $element = _find_element($root, $path);

    my $sep = $query->param('bulk_edit_sep');
    $sep = ($sep eq "__TWO_NEWLINE__") ? "\r?\n\r?\n" : "\r?\n?$sep\r?\n?";
    my $data = $query->param('bulk_data');
    my $name = $query->param('bulk_edit_child');
    my @children = grep { $_->name eq $name } $element->children;
    my @data     = split(/$sep/, $data);

    # match up one to one as possible
    while(@children and @data) {
        my $child = shift @children;
        my $data  = shift @data;
        $child->data($data);
    }

    # left over data, create new children
    if (@data) {
        $element->add_child(class => $name,
                            data  => $_)
          for @data;
    }

    # left over children, remove them from this element
    elsif (@children) { 
        my %to_delete = map { ($_->xpath, 1) } @children;
        my @old = $element->children();
        my @new;
        foreach (@old) {
            push(@new, $_) 
              unless $to_delete{$_->xpath};
        }
        $element->children_clear();
        $element->children(@new);
    }

    add_message('saved_bulk', 
                name => $element->class->child($name)->display_name);
}


sub element_save {
    my ($self, %args) = @_;
    my $query = $self->query();
    my $path    = $query->param('path') || '/';

    my $root = $args{element};
    my $element = _find_element($root, $path);

    # pass to bulk edit it bulk editing
    return $self->element_bulk_save(%args) if $query->param('bulk_edit');

    # validate data
    my @msgs;
    my $clean = 1;
    my $index = 0;
    my @invalid;
    foreach my $child ($element->children()) {
        my ($valid, $msg) = $child->validate(query => $query);
        if (not $valid) {
            add_message('invalid_element_data', msg => $msg);
            push @invalid, $index;
            $clean = 0;
        }
        $index++;
    }

    # toss back to edit with an error message if not clean
    if (not $clean) {
        my %seen;
        $query->param(invalid => join(',', @invalid));
        return 0;
    }

    # save data
    $index = 0;
    foreach my $child ($element->children()) {
        $child->load_query_data(query => $query);
        $index++;
    }

    # notify user of the save
    add_message('saved_element', name => $element->display_name())
      if $element->parent();    

    # success
    return 1;
}

# revise sub-element list, reordering or deleting as requested.  This
# is combined because the complex parameter reordering has to be done
# in either case.
sub revise {
    my ($self, $op) = @_;
    my $query = $self->query();

    my $path = $query->param('path') || '/';
    my $root = $self->_get_element;
    my $element = _find_element($root, $path);

    # get list of existing children and their query parameters
    my @old = $element->children();
    my @old_names =  map { [ $_->param_names ] } @old;

    # compute new list of children and rearrange query data
    my (@new, @old_to_new, @msgs);
    if ($op eq 'reorder') {
        for (0 .. $#old) {
            $new[$query->param("order_$_") - 1] = $old[$_];
            $old_to_new[$_] = $query->param("order_$_") - 1;
        }
    } elsif ($op eq 'delete') {
        for (0 .. $#old) {
            if ($query->param("remove_$_")) {
                add_message("deleted_element", name => $old[$_]->display_name);
            } else {
                push(@new, $old[$_]);
                $old_to_new[$_] = $#new;
            }
        }
    } else {
        croak("Unknown op: '$op'");
    }

    # the javascript should ensure all order_$n fields are present and
    # non-overlapping
    assert(@old == @new)                      if ASSERT and $op eq 'reorder';
    assert(not(grep { not defined $_ } @new)) if ASSERT;

    # effect the change in the element tree
    $element->clear_children();
    $element->children(@new);

    # get a list of new param names
    my @new_names =  map { [ $_->param_names ] } @new;

    # fix up query data assignments, which depend on ordering
    my (%params, @old_params, @new_params);
    for my $index (0 .. $#old) {
        next unless defined $old_to_new[$index];
        @old_params = @{$old_names[$index]};
        @new_params = @{$new_names[$old_to_new[$index]]};
        foreach my $p (0 .. $#old_params) {
            $params{$new_params[$p]} = [$query->param($old_params[$p])];
        }
    }
    $query->param($_ => @{$params{$_}}) for keys %params;

    # deletions get a message listing deleted elements
    if ($op eq 'delete') {
        my %msg = get_messages(keys => 1);
        add_message('no_elements_deleted') unless $msg{deleted_element};

    } else {
        add_message('reordered_elements');
    }

    return $self->edit();
}

# delete this element
sub delete_element {
    my $self  = shift;
    my $query = $self->query();

    my $path = $query->param('path') || '/';

    my $root = $self->_get_element;
    my $element = _find_element($root, $path);

    my $parent = $element->parent();
    if (not $parent) {
        # this is the root, aw crap
        croak("Element editor can't delete the root element!");
    }

    # remove this element from parent    
    $parent->children(grep { $_ != $element } $parent->children());
    
    $query->param(path => $parent->xpath());
    add_message('deleted_element', name => $element->display_name);
    return $self->edit();
}

1;
