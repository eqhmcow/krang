#!/usr/bin/perl
use strict;
use warnings;

=head1 NAME

krang_addon_framework - auto-generate the support skeleton for a Krang addon

=head1 SYNOPSIS

Start work on a new addon called Turbo:

  krang_addon_framework --name Turbo

Now get to work:

  cd addons/Turbo
  emacs krang_addon.conf

=head1 DESCRIPTION

krang_addon_framework builds a support framework to speed the
development process when constructing an addon.

In short, it does the following:

=over

=item *

Creates a directory (specified by the C<--name> argument) under
addons/ in your Krang direction.  All subsequent files are created
within this new directory.

=item *

Autogenerates a C<krang_addon.conf> file with the required C<Name> and
C<Version> filled in.

=item *

Autogenerates a skeleton element library if the --element_lib
parameter is supplied.

=item *

Autogenerates a skeleton skin directory if the --skin parameter is
supplied.

=back

=head1 OPTIONS

Options are as follows:

=over

=item --element_lib

Generates a directory structure for a new element library, adds it to
the support scripts. 

=item --skin

Generates a directory structure for a new Krang skin, adds it to the
support scripts.

=item --verbose

Get a better idea of what is going on.

=back

=head1 SEE ALSO

  C<bin/krang_addon_installer>

  HREF[docs/add_on.html|Building a Krang Addon]

=cut

use FindBin qw($RealBin);
use Config;
use File::Spec::Functions qw(catdir splitdir canonpath);

BEGIN {

    # Find a KRANG_ROOT based on path to bin
    my @dir = splitdir(canonpath($RealBin));
    $ENV{KRANG_ROOT} ||= catdir(@dir[0 .. $#dir - 1]);

    # use $KRANG_ROOT/lib for modules
    my $lib = catdir($ENV{KRANG_ROOT}, "lib");
    $ENV{PERL5LIB} =
      $ENV{PERL5LIB}
      ? "$ENV{PERL5LIB}:${lib}"
      : "${lib}";
    unshift @INC, $lib, "$lib/" . $Config{archname};

    # load Krang::Conf (don't need to load Krang here because we won't
    # be slinging elements)
    $ENV{KRANG_NO_ELEMENTLIBS} = 1;
    eval { require Krang::Conf };
    warn << "END" and exit(1) if $@;
######################################################################

Cannot load Krang.

Error message:

$@

######################################################################
END
}

# process command-line args.
use Krang::ClassFactory qw(pkg);
use Getopt::Long;
use Pod::Usage;
use Krang::ClassLoader Conf => 'KrangRoot';

my ($addon_name, $element_lib, $skin, $verbose, $man, $help);

BEGIN {
    eval {
        $verbose     = 0;
        $addon_name  = '';
        $element_lib = 0;
        $skin        = 0;

        pod2usage(2)
          unless GetOptions(
            help           => \$help,
            man            => \$man,
            'verbose+'     => \$verbose,
            'name=s'       => \$addon_name,
            'element_lib+' => \$element_lib,
            'skin+'        => \$skin,
          );

        pod2usage(1) if $help;
        pod2usage(-verbose => 2) if $man;
        pod2usage("Unrecognized options to krang_addon_framework: '" . join(' ', @ARGV) . "'\n")
          if @ARGV;
    };

    # output errors without the BEGIN compilation failed message
    if ($@) {
        warn $@;
        exit(1);
    }
}

use File::Path qw/mkpath/;
use File::Spec::Functions qw/catdir catfile/;
use Time::Piece;

use IO::File;

# get a timestamp
my $timestamp = localtime;
my $cdate     = $timestamp->cdate;

# create the root dir.
my $root_dir = create_root_dir();

# create krang_addon.conf
krang_addon_conf();

# create element_lib files if needed.
element_lib_files() if $element_lib;

# create skin files if needed.
skin_files() if $skin;

print "\nFinished.  Framework for the $addon_name addon has been written to:\n\t$root_dir\n\n";

sub skin_files {
    my $skin_root = catdir($root_dir, 'skins', $addon_name);

    my @dirs = mkpath([$skin_root], 0, 0755);

    if ($verbose) {
        foreach (@dirs) { print "Created: '$_'\n"; }
    }

    my $skin_conf = <<SKINCONF;
# $addon_name skin.conf
# Autogenerated by krang_addon_framework $cdate

# screen background
background_color #ffffff

# basic palette
dark_color       #5a6952
light_color      #acba94
bright_color     #7b855a
border_color     #c5c6c5

# logo colors
logo_color1      #83a139
logo_color2      #bdd27b
logo_color3      #4a7541

# text colors
text_color       #5a695a
light_text_color #e6eacd
link_color       #5a695a
button_color     #5a6952
alert_color      #ff2800
invalid_color    #ffffac

SKINCONF

    my $skin_conf_path = catfile($skin_root, 'skin.conf');

    write_file($skin_conf_path, $skin_conf);

}

sub element_lib_files {
    my $element_lib_root = catdir($root_dir, 'element_lib', $addon_name);
    my @dirs = mkpath([$element_lib_root], 0, 0755);

    if ($verbose) {
        foreach (@dirs) { print "Created: '$_'\n"; }
    }

    my $set_conf = <<SETCONF;
# $addon_name set.conf
# Autogenerated by krang_addon_framework $cdate

Version 1.0

### set list of top-level story types (required)
#
# TopLevels category article open_format ...

### load parent set(s) used by this set (optional)
#
# ParentSets Default OtherSet ...

SETCONF

    my $set_conf_path = catfile($element_lib_root, 'set.conf');

    write_file($set_conf_path, $set_conf);
}

#
# create $root_dir/krang_addon.conf for $addon_name.
#
sub krang_addon_conf {

    my $addon_conf_path = catfile($root_dir, 'krang_addon.conf');

    die "ERROR: Cannot create '$addon_conf_path': - already exists!\n\n"
      if (-e $addon_conf_path);

    my $addon_conf = <<ENDCONF;
# krang_addon.conf
# Autogenerated by krang_addon_framework $cdate

# addon name
Name $addon_name

# addon version
Version 1.00

# minimum version of Krang required (optional)
# RequireKrang 1.102

# files to be excluded on install (optional)
# ExcludeFiles README postinstall

# script to run after installation is complete (optional)
# PostInstallScript postinstall

ENDCONF
    ;    # this comma keeps emacs from getting confused.  :)

    write_file($addon_conf_path, $addon_conf);
}

sub create_root_dir {
    my $root_dir = catdir(KrangRoot, 'addons', $addon_name);
    die "ERROR: Cannot create '$root_dir' - already exists\n\n"
      if -e $root_dir;

    my @dirs = mkpath([$root_dir], 0, 0755);

    if ($verbose) {
        foreach (@dirs) { print "Created: '$_'\n"; }
    }

    return $root_dir;
}

sub write_file {

    my ($filename, $content) = @_;

    print "Created: '$filename'\n" if ($verbose);

    my $fh = IO::File->new(">$filename")
      or die "ERROR: Cannot create '$filename': $!\n\n";

    $fh->print($content);

    $fh->close;

}

1;
