#!/usr/bin/perl 
use warnings;
use strict;

=pod

=head1 NAME

krang_import - import Krang data sets (.kds files)

=head1 SYNOPSIS

List the contents of export.kds, but don't import anything:

  $ krang_import --list export.kds

Import the contents of export.kds into the system:

  $ krang_import export.kds

=head1 DESCRIPTION

This script imports the contents of a Krang Data Set (.kds) file into
a Krang instance.  Set the instance to work on using the
KRANG_INSTANCE environment variable or the first one in krang.conf
will be used.

=head1 OPTIONS

=over 4

=item --list

Just list the contents of the data set, don't import.

=item --no-update

Never attempt to update existing objects, even when duplicates exist.
You probably don't want this option unless you're importing into an
entirely empty system and you want to know if that's not the case.

=item --skip sites

=item --skip categories

The --skip option tells the importer to not load a certain class of
object from the KDS file.  This is primarly used to skip loading of
sites and categories while loading stories, media or templates.  

For example, to load a KDS file containing templates without loading
the categories and sites that may be present in the file:

  krang_import --skip sites --skip categories templates.kds

Note that the sites and categories are still used to place the
templates in the proper place on the target system, but they will not
overwrite any existing data.

=item --verbose

Prints a running dialog of what's happening.  Repeat (--verbose
--verbose) and you'll be treated to a directory listing of the created
.kds at the end.

=back

=cut

use File::Spec::Functions qw(catdir catfile splitdir rel2abs canonpath);
use FindBin qw($RealBin);
use Config;

BEGIN {
    # Find a KRANG_ROOT based on path to bin
    my @dir = splitdir(canonpath($RealBin));
    $ENV{KRANG_ROOT} ||= catdir(@dir[0 .. $#dir - 1]);

    # use $KRANG_ROOT/lib for modules
    my $lib    = catdir($ENV{KRANG_ROOT}, "lib");
    $ENV{PERL5LIB} = $ENV{PERL5LIB} ? "$ENV{PERL5LIB}:${lib}" : 
      "${lib}";
    unshift @INC, $lib, "$lib/".$Config{archname};

    # load Krang::Conf (don't need to load Krang here because we won't
    # be slinging elements)
    eval { require Krang::Conf };
    warn << "END" and exit(1) if $@;
######################################################################

Cannot load Krang.

Error message:

$@

######################################################################
END
}

# process options
use Getopt::Long;
use Pod::Usage;

our ($help, $man, $list, $no_update, $verbose, $file, @skip, @skip_classes);
BEGIN {
    $verbose = 0;
    pod2usage(2) unless
      GetOptions(help       => \$help,
                 man        => \$man,
                 'verbose+' => \$verbose,
                 list       => \$list,
                 'no-update'=> \$no_update,
                 'skip=s'   => \@skip,
                );
    pod2usage(1)             if $help;
    pod2usage(-verbose => 2) if $man;
    
    # get input file
    $file = shift(@ARGV);
    pod2usage("Missing filename command-line parameter!\n")
      unless $file;

    # validate filename
    warn "Specified file '$file' does not exist.\n" and exit(1)
      unless -e $file;
    warn "Input filename must end in .kds or .kds.gz\n" and exit(1)
      unless $file =~ /\.kds$/ or $file =~ /\.kds\.gz$/;

    # make sure that's it
    pod2usage("Unrecognized options to krang_export: '" . join(' ', @ARGV) . "'\n")
      if @ARGV;

    # make up a list of skip classes
    foreach my $skip (@skip) {
        my $class = ucfirst lc $skip;
        $class =~ s!ies$!y!;
        $class =~ s!s$!!;
        $class = "Krang::$class";
        die "Unrecognized type '$skip' found in --skip option.  Should be 'sites' or 'categories'.\n" 
          unless $class eq 'Krang::Site' or $class eq 'Krang::Category';
        push(@skip_classes, $class);
    }
     
    # open file for later processing.  this has to happen before
    # Krang::Script loads and su's to KrangUser
    open(SOURCE, '<', $file) or warn "Unable to open '$file': $!" and exit(1);
}



use Krang::Script;
use Krang::Conf qw(KrangRoot);
use Krang::DataSet;
use Krang::Story;
use Krang::Media;
use Krang::Template;
use Krang::Contrib;
use Krang::Category;
use Krang::Site;
use Krang::User;
use Krang::ListGroup;
use Krang::List;
use Krang::ListItem;
use File::Temp qw(tempfile);
use File::Copy qw(copy);

# copy file someplace Krang can open it
my (undef, $tempfile) = tempfile(DIR => catdir(KrangRoot, 'tmp'),
                               SUFFIX => 
                               ($file =~ /\.gz$/ ? '.kds.gz' : '.kds'),
                               CLEANUP => 1);
copy(\*SOURCE, $tempfile) 
  or die "Unable to copy '$file' to '$tempfile': $!";
close SOURCE;
print STDERR "Copied '$file' to '$tempfile'.\n" if $verbose > 1;
$file = $tempfile;

# open up the dataset
my $set = Krang::DataSet->new(path            => $file, 
                              import_callback => \&import_callback);

# produce a listing?
if ($list) {
    foreach my $row ($set->list) {
        my ($class, $id) = @$row;
        printf("%15s => %6d\n", $class, $id);
    }
    exit(0);
}

# get a hash of maximum IDs for each class in the import.  Used to
# detect updates.
my %classes = map { ($_->[0], 1) } $set->list;
my %max_id;
foreach my $class (keys %classes) {
    my $id_field = $class;
    $id_field =~ s/^Krang:://;
    $id_field = lc($id_field) . "_id";
    $id_field = 'list_item_id' if ($id_field eq 'listitem_id');
    $id_field = 'list_group_id' if ($id_field eq 'listgroup_id');
    my ($max) = $class->find(ids_only   => 1, 
                             order_by   => $id_field, 
                             order_desc => 1, 
                             limit      => 1);
    $max_id{$class} = $max || 0;
}


    

# do the import
eval { $set->import_all(($no_update ? (no_update => 1) : ()),
                        (@skip_classes ? (skip_classes => \@skip_classes): ()),
                       ); };
if ($@ and ref $@ and $@->isa('Krang::DataSet::ImportRejected')) {
    print STDERR "Import failed for the following reasons:\n\n",
      $@->message, "\n";
    exit 1;
} elsif ($@) {
    die $@;
}

print "Import completed.\n";
exit 0;

sub import_callback {
    my %arg = @_;
    my $object = $arg{object};
    
    if ($verbose) {
        my ($class, $id) = Krang::DataSet::_obj2id($object);
        if ($id > $max_id{$class}) {
            print STDERR "Imported $class => $id\n";
        } elsif (grep { $_ eq $class } @skip_classes) {
            print STDERR "Skipped $class => $id\n";
        } else {            
            print STDERR "Updated $class => $id\n";
        }
    }
}
