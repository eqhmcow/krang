
=head1 NAME

Krang::Schedule::Action::clean - Scheduler Action class which implements scheduled cleanup and maintenance functions 

=cut

package Krang::Schedule::Action::clean;

use Krang::ClassFactory qw(pkg);
use strict;
use warnings;
use Krang::ClassLoader base => 'Schedule::Action';

use Krang::ClassLoader Conf => qw(KrangRoot BadLoginCount BadLoginWait);
use Krang::ClassLoader DB   => qw(dbh);
use Krang::ClassLoader Log  => qw(ASSERT assert critical debug info);

use Carp qw(verbose croak);
use File::Spec::Functions qw(catdir catfile);
use File::Path qw(rmtree);
require File::Find;    # File::Find exports a find() method if we use 'use'.
use Time::Piece;
use Time::Piece::MySQL;
use Time::Seconds;

my $tmp_path = catdir(KrangRoot, 'tmp');

=head1 SYNOPSIS

Concrete Krang::Scheduler::Action class which deletes expired sessions, cleans out tmp directories, or mysql table maintenance.

=head1 DESCRIPTION

This class is used to do scheduled maintenance.  It is instantiated in the scheduler depending on action type.

=head1 INTERFACE

use Krang::ClassLoader base => 'Schedule::Action';
sub execute { }

=head1 METHODS 

=over

=item C<< $schedule->execute() >>

Action method for class.  Must be defined in Krang::Scheduler::Action classes.
This method serves as the entry point method in Krang::Scheduler::Action class implementations.
In this class it functions to do scheduled maintenance in krang which includes cleaning of tmp directory, removal of expired sessions and analyzing mysql tables,  additional mysql maintenance functions would ideally go in this class.  The type of maintenance function is determined in object_type.

=back

=cut

sub execute {
    my $self = shift;

    if ($self->{object_type} eq 'tmp') {
        $self->_clean_tmp();
    } elsif ($self->{object_type} eq 'session') {
        $self->_expire_sessions();
    } elsif ($self->{object_type} eq 'analyze') {
        $self->_analyze_db();
    } elsif ($self->{object_type} eq 'rate_limit') {
        $self->_expire_rate_limit_data();
    } else {
        my $msg =
          sprintf("%s->execute('clean'): unknown object '%s'", __PACKAGE__, $self->{object_type});
        die($msg);
    }

    $self->clean_entry();
}

=over

=item C<< pkg('Schedule')->_clean_tmp() >>

 @deletions = pkg('Schedule')->_clean_tmp( max_age => $max_age_hrs )
 @deletions = pkg('Schedule')->_clean_tmp()

 Class method that will remove all files in $KRANG_ROOT/tmp older than
 $max_age_in_hours.  If no parameter is passed file and directories older than
 24 hours will be removed.  This method will croak if it
 is unable to delete a file or directory.  Returns a list of files and
 directories deleted.

=back

=cut 

sub _clean_tmp {

    my $self    = shift;
    my %args    = @_;
    my $max_age = (exists($args{max_age})) ? $args{max_age} : 24;

    my (@dirs, @files);

    my $date = (exists($self->{_test_date})) ? $self->{_test_date} : localtime;
    $date = $date - ($max_age * ONE_HOUR);

    debug(  __PACKAGE__
          . "->_clean_tmp(): looking to delete files in tmp/ older than "
          . $date->mysql_datetime);

    # build a list of files to delete
    opendir(DIR, $tmp_path) || croak(__PACKAGE__ . "->_clean_tmp(): Can't open tmpdir: $!");
    for (readdir DIR) {

        # skip the protected files
        next if $_ =~ /(CVS|\.{1,2}|\.(conf|cvsignore|pid|svn))$/;

        # skip the SSL files
        next if $_ =~ /^ssl_/;

        # skip them if they're too young
        my $file = catfile($tmp_path, $_);
        my $mtime = Time::Piece->new((stat($file))[9]);
        next unless ($mtime - $date) <= 0;

        if (-f $file) {
            push @files, $file;
        } elsif (-d $file) {
            push @dirs, $file;
        }
    }
    closedir(DIR);

    # handle warnings generated by File::Path
    local $SIG{__WARN__} = sub { debug(__PACKAGE__ . "->clean_tmp(): " . $_[0]); };

    # list of files deleted
    my @deletions;

    # delete files
    for (@files) {
        unless (unlink $_) {
            critical(__PACKAGE__ . "->_clean_tmp(): Unable to delete '$_': $!");
        } else {
            debug(__PACKAGE__ . "->_clean_tmp(): deleted file '$_'");
            push @deletions, $_;
        }
    }

    # delete directories
    for my $dir (@dirs) {
        File::Find::find(\&_delete_files, $dir);

        debug(__PACKAGE__ . "->_clean_tmp(): deleting dir '$dir'");
        rmtree([$dir], 0, 1);
        if (-e $dir) {
            critical("Unable to delete '$dir'.");
        } else {
            debug(__PACKAGE__ . "->_clean_tmp(): deleted dir '$dir'");
            push @deletions, $dir;
        }
    }

    return @deletions;
}

=over

=item C<< pkg('Schedule')->_expire_sessions() >>

@ids = pkg('Schedule')->_expire_sessions( max_age => $max_age_hrs )

@ids = pkg('Schedule')->_expire_sessions()

Class method that deletes sessions from the sessions table whose
'last_modified' field contains a value less than 'now() - INTERVAL
$max_age_in_hours HOUR'.  Returns a list of the session ids that have been
expired.

If max_age is not supplied, defaults to 24 hours.

=back

=cut

sub _expire_sessions {
    my $self    = shift;
    my %args    = @_;
    my $max_age = exists $args{max_age} ? $args{max_age} : 24;
    my $dbh     = dbh();
    my ($i, @ids, $query);

    # get deletion candidates
    $query = <<SQL;
SELECT id
FROM sessions
WHERE last_modified < now() - INTERVAL ? HOUR
SQL
    my $row_refs = $dbh->selectall_arrayref($query, undef, $max_age);
    for $i (0 .. $#{@$row_refs}) {
        push @ids, $row_refs->[$i][0];
    }

    # destroy them
    if (@ids) {
        $query = "DELETE FROM sessions WHERE " . join(" OR ", map { "id = ?" } @ids);
        $dbh->do($query, undef, @ids);

        # log destruction
        debug(  __PACKAGE__
              . "->_expire_sessions(): Deleted the following Expired Session IDs: ("
              . join(" ", @ids)
              . ")");

        return @ids;
    }
}

=over

=item C<< $schedule->_analyze_db() >>

_analyze_db() - analyzes all database tables for maximum performance

=back

=cut

sub _analyze_db {
    my $dbh = dbh();

    my $tables = $dbh->selectcol_arrayref('show tables');
    foreach my $table (@$tables) {
        debug("Analyzing table $table.");
        $dbh->do("ANALYZE TABLE $table");
    }
}

=over

=item C<< $schedule->_delete_files() >>

subroutine to be passed to File::Find::find to delete files
before passing the remaining directory tree to rmtree.

=cut

sub _delete_files {

    my $file = $File::Find::name;

    # skip if it's not a file.
    return unless -f $file;

    debug(__PACKAGE__ . "->_delete_files() - unlinking '$file'");

    unlink $file;

}

=over

=item C<< pkg('Schedule')->_expire_rate_limit_data() >>


Class method that deletes rate_limit data from the rate_limit_hits table whose
'timestamp' field contains a value less than C<time() + BadLoginWait>

    pkg('Schedule')->_expire_rate_limit_data()

=back

=cut

sub _expire_rate_limit_data {
    my $self = shift;
    my %args = @_;
    my $dbh  = dbh();

    # only clean up if we have BadLoginCount set
    if (BadLoginCount) {
        my $past_due = time() + (BadLoginWait * 60);
        $dbh->do('DELETE FROM rate_limit_hits WHERE timestamp < ?', undef, $past_due);
        debug(
            __PACKAGE__ . "->expire_rate_limit_data() Deleted all hits with timestamp < $past_due");
    }
}

=back

=head1 See Also

=over

=item Krang::Scheduler

=item Krang::Scheduler::Action

=back

=cut

1;
