=head1 Krang Permissions System

Krang implements an authentication and authorization system which
controls the users' ability to access different aspects of the
system.  This system works by affiliating named "groups" with sets of
privileges.  Users are then affiliated with these groups, through
which they are granted authority.

The purpose of this document is two-fold:

=over 4

=item 1. Functionality

To describe the functionality of the Krang permissions system.


=item 2. Implementation

To describe how the Krang permissions system is implemented, and why.


=back



=head1 Functionality

Krang's security is based on "groups".  Groups are logical containers
which are affiliated with permission settings and users.  Permissions
for a group are assigned in three major "security realms":


=head2 Security Realms

=over 4

=item 1. Sites/Categories

Sites, and the categories (e.g., directories) within each site.


=item 2. Assets

Includes three classes of assets: Story, Media, and Templates


=item 3. Desks

Logical desks, such as "Edit" or "Publish"


=back



=head2 Security Levels

Within these three security realms, authority is granted to one of
three levels:


=over 4

=item A. Edit

User may add, modify or delete.


=item B. Read-Only

User can view items but not make changes.


=item C. Hide

User may neither see nor change items.


=back



=head2 Administration permissions

In addition to the realms and levels described above, there are a handful
of security items affiliated with a group which are global to the whole
system.

=over 4

=item * May publish (may_publish)

Publish stories and media to the live server.


=item * Manage users (admin_users)

Add, edit, or delete users.


=item * Group limited user manage (admin_users_limited)

When editing users, may only grant access to groups to which user personally has access.


=item * Manage groups (admin_groups)

Add, edit, or delete permission groups.


=item * Manage contributors (admin_contribs)

Add, edit or delete contributors.


=item * Manage sites (admin_sites)

Add, edit or delete sites.


=item * Manage categories (admin_categories)

Add, edit or delete categories.


=item * Manage jobs (admin_jobs)

Add, edit or delete jobs.


=item * Manage desks (admin_desks)

Add, edit or delete desks.


=back



=head2 Use Cases

These permissions are applied intuitively based on their context.  For
example:

=over 4


=item *

A user is granted "Read-Only" access to a particular category.  As a
result, they can see the contents of the category and its
sub-categories, but may not add, modify or delete categories in the
affected hierarchy.  Furthermore, the user may see but not edit media
and story objects which are within the affected hierarchy.


=item *

A user is granted "Edit" access to desk "A", but "Read-Only" access to
desk "B".  as a result, they can manipulate content on desk "A", and
they may move it to desk "B" -- but once on desk "B" they cannot
make any changes.


=item *

A user is granted "Hide" access to the "Admin" application class.  As
a result, they cannot see or access any of the applications in that
class, including Users, Groups, Contributors, Sites, Categories, Jobs,



=item *

A user is granted "Edit" access to "Story" and "Media" application
classes, but not to "Templates".  As a result, they can manage
content, but may not make changes to the templates which control the
appearance of content.


=item * 

User is NOT granted "may publish" access.  As a result, the publish 
buttons are hidden from all screens on which they normally appear.


=item * 

User is NOT granted "manage contributors" access.  As a result, the
"Contributors" link is hidden from the left navigation in Krang.
The user may still associate contributors with stories or media, but
they cannot access the edit screen for existing contributors or delete 
contributors.


=back



=head1 Implementation

There are two primary tasks for which the Krang permissions system is
responsible:


=over 4

=item 1. API security

Limit access to Krang objects.


=item 2. UI security

Influence UI based on access to functionality.


=back


It is through these two mechanisms that Krang permissions are implemented.


=head2 API security

The purpose of API security is to limit access to Krang objects.  This
mechanism is implemented by modifying the Krang object modules (e.g.,
Krang::Media, Krang::Story, etc.).

Typically, this means modifying the find() method to hide objects
which the current user is not allowed to see and throwing exceptions
when the user tries to perform an operation they are not allowed to
perform, such as calling save() on an object to which they have
"Read-Only" access.

The implementation varies according to the security realm:

=over 4


=item * Sites/Categories

Site/categories are the most complex aspect of the Krang
permissions system.  Because categories touch so many different parts
of the Krang system, and because they are so voluminous (possibly
numbering around 10,000 per Krang instance) a special mechanism has
been devised to handle category-based permissions.

Primarily, a table called "category_group_permission" has been
created.  This table stores the category permission configuration
designated by the users.  For example, imagine the following was
configured for the "Car Editors" group:

  site1.com/, "Read-Only"
  site1.com/departments/cars/, "Edit"

The intention of the user who configured these permissions would be to
grant "Car Editors" the ability to manage content within their
section, but not anywhere else.  For example, if they wanted to add a
story to the system they would be granted access as follows to the
following categories:

  Not allowed:  site1.com/
  Allowed:      site1.com/departments/cars/
  Allowed:      site1.com/departments/cars/toyota/prius/
  Not allowed:  site1.com/departments/unicycles/

In order to make a permissions decision about the category
"site1.com/departments/cars/" there is an exact match in the
"category_group_permission" table.  Unfortunately, in order to find
permissions for "site1.com/departments/cars/toyota/prius/" it is
necessary to ascend the hierarchy until we get to
"site1.com/departments/cars/".

The "category_group_permission" table is expected to be a very sparse
matrix of categories and groups.  If we were to rely on this table for
making all category permission decisions we would spend a considerable
amount of time negotiating the category hierarchy, and performance
would greatly suffer as a result.

In order to avoid this problem, another table called
"category_group_permission_cache" has been created.  Unlike
"category_group_permission", this table stores every possible
combination of group and category.  As a result, any look up for
category/group permissions is certain to be resolved in a single
query.

Furthermore, in order to streamline the ability to integrate category
permission checking into SQL, the permission levels "Edit",
"Read-Only", and "Hide" have been implemented as two columns in
"category_group_permission_cache": "may_see" and "may_edit".

Finally, it is important to recognize that a user may be a member of
more than one group.  The result of this is that the database may
return more than one row per user/category.  In order to compensate
for the possible 1:N nature of users to qualifying groups, a group-by
SQL mechanism should be employed when retrieving permissions, and a
"select distinct" when doing a count.

Put together with the rest of the system, here is how a count of media
records might be implemented in SQL:

  select
    count(distinct media_id)

  from
    media
      left join category_group_permission_cache as cgpc
        ON cgpc.category_id = media.category_id
      left join usr_user_group
        ON cgpc.group_id = usr_user_group.user_group_id

  where
    usr_user_group.user_id = 1 AND
    cgpc.may_see = 1 


Here is how you would retrieve matching media records for the same
query.  Note the use of sum() and "group by":

  select
    media.media_id,
    media.title,
    media.category_id,
    (sum(cgpc.may_see) > 0) as may_see,
    (sum(cgpc.may_edit) > 0) as may_edit

  from
    media
      left join category_group_permission_cache as cgpc
        ON cgpc.category_id = media.category_id
      left join usr_user_group
        ON cgpc.group_id = usr_user_group.user_group_id

  where
    usr_user_group.user_id = 1 AND
    cgpc.may_see = 1 

  group by
    media.media_id

Because the may_edit column will contain "1" if true and "0"
if not, sum() will effectively be greater than zero if the user is
allowed to edit a particular object via at least one group.

As you can see, this SQL will hide records to which the user has no
authority to see.  This is not always the desired behavior.  For
example, if a story is in a category to which the user has read
access, but that story uses media which is in a category to which the
user does NOT have access, it is expected that the media will appear
in the context of the story, nonetheless.  This requires that the API
only hide hidden records when specifically requested to do so.  To
this end, a new parameter to find() is provided, "hide".  For example:

  my @media = Krang::Media->find( hide=>1 );

If "hide" is not specified (or is set to "0"), all records will be
shown.  It is expected that objects will only be hidden when viewed by
applications which are specifically for managing that object type.
For example, story objects will only be hidden when accessed via the
story manager application.  When non hidden, the "may_see" property
will be propagated to the object, and may be used as needed.

This handles the "Hide" case, but does not handle
the "Edit" verses "Read-Only" case.  To support this case, the
"may_edit" property should be used.  When records are instantiated
from the database the "may_edit" property (as well as the "may_see"
property) should be stored with the object.

This object property should be considered whenever the user attempts
to trigger a write operation on the object, in which case the
operation should croak().  Examples of methods which should implement
this behavior are:

  save()
  delete()
  checkout()
  checkin()

This will ensure that even if the calling code erroneously issues
write operations, those operations will not be permitted thus
corrupting the database.


Maintenance of the category_group_permission_cache table is managed by
the Krang::Group module which is called when categories or groups are
changed.  If it is necessary to rebuild the cache from the ground up, 
the class function rebuild_category_cache() is provided.  This can be 
invoked from the command-line as follows:

  perl -MKrang::Script -MKrang::Group -e 'Krang::Group->rebuild_category_cache()'

This method may take some time to complete during which a running system will 
not function properly.  Rebuilding the cache table requires iterating through 
possibly thousands of SQL statements.  Precisely speaking, the cache table 
contains one row for every group/category combination.  When designing the
permissions system, the following quantities were considered possible per 
Krang instance:

    Number of groups: 20
    Number of sites: 20
    Categories per site: 500
    Total cache table rows:    20 (groups)
                             * 20 (sites)
                            * 500 (site/categories)
                        -----------------------------
                          200,000 (cache entries)

Rebuilding the entire category permissions cache is not usually necessary.
As a result, it is not optimized for run-time performance.  If it is necessary 
to rebuild the cache table it is recommended that the Krang instance be shut 
down first.


=item * Assets

In Krang, "assets" refer to stories, media, or templates.  Permissions
are assigned independently to these three different asset types, for
each group.

Access to the permission settings are provided via the Krang::User
module.  For each asset type, a group may be granted "edit",
"read-only", or "hide" access.

A user may be a member of more than one group.  The asset permissions
work on a basis of "most permissive", meaning that if a user is
allowed to "edit" an asset because of their membership in one group,
they are then allowed to edit that asset, regardless of whether
another group of which they are a member does not have "edit" access.

These asset permission settings are implemented as enumerated fields
in the "permission_groups" table.  In order to more easily use these
permissions, they are logically converted into two Boolean permissions
for each asset type:  may_edit and may_see.  For example:

 If asset_story == edit, then...
   ...may_edit_story == 1
   ...may_see_story == 1

 If asset_media == read-only, then...
   ...may_edit_media == 0
   ...may_see_media == 1

 If asset_template == hide, then...
   ...may_edit_template == 0
   ...may_see_template == 0

These six properties are provided as read-only methods of Krang::User
objects.

Functionally, there are two significant differences between asset
permissions and category permissions.  The first difference is that
asset permissions affect the whole class, where category permissions
are particular to an individual object.

For example, if a user has "read-only" access to media, the
Krang::Media methods which require "edit" access will croak() when
called.  These methods include:

  save()
  delete()
  checkout()
  checkin()

This methods should all croak() if "may_edit_media" is false.

The second difference between category and asset permissions is that
"hide" permissions for a particular asset class have no effect on
the behavior of the find() method.  Unlike category permissions which
will automatically hide results if a user has "hide" access to a
category which contains a particular object, all objects will be
returned by find() even if a user has "hide" for the asset type.

The reason for this is because quite a lot of functionality in Krang
requires access to find().  For example, a user with access to see or
edit stories must be able to see the media associated with the
stories.  If the behavior of find() were modified to hide all media,
the story interface would break.

Instead, the semantics of "hide" with regards to assets will be that
the link to the web interfaces to managing the hidden assets will be 
removed from view.  This is discussed more in the UI section of this 
document.


=item * Desks



=item * Administration permissions



=back


=head2 User Interface (UI) security

The purpose of UI security is to inform the various user interface
applications so that features to which the user does not have access
are hidden from view.  The goal of hiding these inaccessible features
is to improve ease of use for the typical user.

The UI security is expected to be back-stopped by the API security.
There are two reasons for this dual implementation:  First is defense
in depth.  Unauthorized actions should not simply be hidden from view
-- they should be blocked from execution.  This prevents a malicious
user who has reversed engineered UI functionality from issuing
commands which should not be allowed.

The second reason is quality assurance.  Both the UI and the API
should implement the same logical authorization rules.  If the UI
allows some functionality which is not permitted, the API will catch
the error and croak().  This will offer a better opportunity to catch
flaws in the software system before they create corrupted records in
the database.


=over 4


=item * Sites/Categories

Site/categories affect a most of the objects in the Krang system.  The
web UI needs to decide whether or not to display buttons for write
operations for a given object.  In order to inform the UI code of the
ability to edit a particular object, every object should implement a
method, may_edit(), which returns "1" or "0" indicating whether an
object is editable or not, respectively.

In practice, this would effect list views which display "edit" buttons
or check boxes to delete or checkout objects.  This would be
implemented via the Krang::HTMLPager row handler function.  For
example:

  sub row_handler {
    my ($row_hashref, $row_obj) = @_;

    my @commands = qw(view log);

    # Add "edit" function if user may edit
    if ($row_obj->may_edit) {
      unshift(@commands, 'edit');
    }

    # Build HTML for commands
    my $row_id = $row_obj->story_id();
    my @commands_html = ();
    foreach my $command (@commands) {
      my $href = "javascript:$command('$row_id')";
      my $link = "<a href=\"$href\">$command</a>";
      push(@commands_html, $link);
    }

    # Set up command column
    my $command_column_html = join("&nbsp;|&nbsp;", @commands_html);
    $row_data->{command_column} = $command_column_html;

    # ...Rest of row handler here...
  }

This same technique can be used to remove delete and checkout
check boxes from rows which are not editable.


=item * Assets

As described previously in this document, for each asset type, a 
group may be granted "edit", "read-only", or "hide" access which 
are accessible via logical Boolean values stored in the %session:

  $session{permissions}->{may_edit_story};
  $session{permissions}->{may_see_story};

  $session{permissions}->{may_edit_media};
  $session{permissions}->{may_see_media};

  $session{permissions}->{may_edit_template};
  $session{permissions}->{may_see_template};

Unlike category permissions, asset permissions UI security is 
not entirely back-stopped by API security.  The "edit" functions are
secured in the API, but "hide" security is exclusively the
responsibility of the UI to implement.

The "hide" permission setting is implemented, for all asset classes,
as a Boolean "may see" variable, as specified above.  It is expected
that this will be respected by the "left navigation" system.  If
"may_see_media" is false ("0"), the left navigation system should hide
the links to "New Media" and "Find Media".  The "may_see_story" and
"may_see_template" should function similarly.

There may be other places where it is intuitive to hide functional
links based on "may_see_*" values.  It is *NOT* expected that a false
"may_see_*" value would hide a record from display in another object
view of which the hidden object class is a constituent.  When in
doubt, consult the paper prototyping team.

The "may_edit_*" properties function similarly to "may_see_*", but
they have more complex requirements.  For example, if "may_edit_media"
is false, this should result in all interfaces to adding, editing, or
deleting media be hidden from view.  This affects multiple
applications throughout Krang, such as Krang::CGI::Story, which
provide contextual links to manipulate media objects.

Unlike "may_see_*", "may_edit_*" is back-stopped by API security.  If
a link to a write operation is made accessible to a user who does not
have "edit" permissions to that particular object, an internal server
error will result if the user clicks on that button.



=item * Desks



=item * Administration permissions



=back


