=head1 Writing HTML::Template Templates in Krang

=over

=item * Name

=item * Introduction

=item * Templates in Krang

=item * Publish Methods and Templates

=item * Choosing a Strategy


----------------------------------------

=item * Publishing With Stock Krang Publish Methods 

=over

=item * An Example Story Type

=item * How Krang Builds Template Data

=item * Elements Without Templates

=item * Example 1: Using One Large Template

=item * Example 2: Using Multiple Templates

=over

=item * The Next Step

=back

=back

----------------------------------------

=item Varying Templates and Output by Category -- Overriding Templates

----------------------------------------

=item * Additional Publishing Components

=over

=item * Pagination

=item * Links to Other Stories in Krang

=item * Links to Media Objects in Krang

=item * Category Templates

=item * Contributors

=back

----------------------------------------

=item * Publishing With Customized Publish Methods

=over

=item * Overriding Krang::ElementClass Methods in Your Element Library

=over

=item * template_data()

=item * fill_template()

=item * find_template()

=item * publish()

=back

=item * Example 3: Using One Large Template

=item * Example 4: Using Multiple Templates

=item * Story and Media Links

=back




=back

=head1 Name

Writing HTML::Templates in Krang - A guide to using the Krang templating system.

=head1 Introduction

This document describes how to use templating system in Krang, which is based on HTML::Template.  An understanding of the way stories are constructed in Krang will be helpful in getting the most out of this document.  A general understanding of how the HTML::Template templating language works will help as well.

=head1 Templates in Krang

Krang uses templates to generate output for stories when they're published.  These templates are organized on the filesystem in the same category tree that is used for arranging stories and media.  When a story is published, the category tree is searched for appropriate templates, starting at the story's current category.  If no match is found immediately, Krang will then proceed up the category tree until a matching template is found.


=head1 Publish Methods and Templates

Krang uses the HTML::Template templating system.  The philosophy behind HTML::Template is to separate the code required to build the content of a page from the template used for the layout of the final page.  Krang takes this philosophy one step further - by using the element tree of a story to automate the construction of a story's content, template developers can do their work with minimal programmer involvement.

If you are migrating from Bricolage, the templating system in Krang does not make use of separate publish scripts, the way that Bricolage did.  In Krang, every element in the element tree contains code to publish itself.  If customization is required, you can override the default publish methods within the element.

For further information on Krang's element tree, see C<Creating Element Libraries in Krang>.


=head1 Choosing a Strategy

When first building templates for Krang, try and use the stock publish methods with one or more templates (See C<Publishing With Stock Krang Publish Methods>, below).  As you get more familiar with Krang, you will discover that using many templates will allow you to customize the appearance of various sections of your site, without doing anything more than template development.

The publish methods that exist in Krang were designed with flexibility and performance in mind.  Consider overriding methods (C<Publishing With Customized Publish Methods>) in the publish process only in the event that you cannot get the behavior you need out of the standard methods.

Realize that overriding publish methods can potentially affect the performance of the preview/publish process, as any given method may be called a large number of times.


=head1 Publishing With Stock Krang Publish Methods

The publish methods provided by Krang should be sufficient for just about everyone.  Get familiar with the standard publish process and use it for a little while before getting into the more advanced techniques in the publish process - chances are you won't need to use them.

The most important things to understand when getting into template development in Krang are the relationships that elements have to eachother (the element tree), and how those relationships are used to build out the data structures used in your templates.

=head2 An Example Story Type

We'll examine an example story type called C<Story>. Here's the element tree for C<Story>:

   Story
        - Deck             (textbox attribute)
        + Page             (repeatable element)
             - Paragraph   (repeatable textbox attribute)
             - Pull Quote  (repeatable textbox attribute)
             - Paragraph   (repeatable textbox attribute)


The Story element has an attribute called Deck, and can contain any number of Page elements. Pages are composed of Paragraph and Pull Quote attributes, both of which can be repeated.

When the publish process is called on this story, Krang will walk this element tree, starting from the top (C<Story>), recursively touching every element in the tree to construct the final output.

Each element within C<Story> contains methods to retrieve the appropriate template, build the appropriate data to populate that template, and return the output that results from the merger of the data and template.

No element can return until it's children have returned.  Using the above tree as an example, a C<Page> element will not return its output until its children, the C<Paragraph> and C<Pull Quote> elements, have returned their output.


=head2 How Krang Builds Template Data

Krang uses an internal method, C<< Krang::ElementClass->fill_template() >> (see more in C<Publishing With Customized Publish Methods>) to buld the data available to a template.  fill_template() will fill in the variables and loops in your template in a predictable fashion.

Several types of variables and loops are created.  Using the element tree for C<Story> above as an example, the follwoing variables will be created:

=over

=item *

B<NOTE>: All variable names are lower case, and any spaces in between words will be replaced with underscores.

=item *

A single variable is created for every element using C<< $element->name() >>

An examples would be <tmpl_var deck>.

=item *

A loop is created for every element named with the name of the element followed by _loop. The rows of the loop contain the variable described above and a _count variable.

The <tmpl_loop page_loop> is an example of this type of loop.  Each element in C<page_loop> will contain <tmpl_var page> and <tmpl_var page_count>.

=item *

A loop called C<element_loop> is created with a row for every element contained. The values are the same as for the loop above with the addition of a boolean is_ variable.

For example, <tmpl_loop element_loop> would contain the variables <tmpl_var is_deck>, <tmpl_var deck>, <tmpl_var is_page>, <tmpl_var page>.

=item *

A variable for the total number of elements named with the element name and a trailing _total.

<tmpl_var deck_total> would return 1, as would <tmpl_var page_total>.


=item *

A variable called C<title> containing $story->title.

This is available to all templates, regardless of where in the element tree you are.

Accessed in the template as <tmpl_var title>.

=item * 

A variable called C<page_break> that forces Krang to create a new page.

This is available to all templates.  Careful as to where this is implemented, as you could find yourself creating far more pages than you intend to.

<tmpl_var page_break>

=item *

A loop called C<contrib_loop> containing all contributors to a story.

See the section C<Contributors>, further on in this document, for more information on Contributors.

=item *

A loop called C<pagination_loop> containing links to other pages in the story.

See the section C<Using Pagination>, further on in this document, for more information on Pagination.  This variable is only available to elements marked as I<pageable>.

=back

=head2 Example 1: Using One Large Template

With very simple stories, you can use a single template to handle the entire publish process.

For the purposes of this example, imagine the following element tree for a story:

   Story
        - Deck        (textbox attribute)
        - Paragraph   (repeatable textbox attribute)
        - Pull Quote  (repeatable textbox attribute)
        - Paragraph   (repeatable textbox attribute)


B<The Template - Story.tmpl>

   <html>

   <head>
     <title><tmpl_var title></title>
   </head>

   <body>

     <h1><tmpl_var title></h1>
     <b><tmpl_var deck></b>

     <tmpl_loop element_loop>

        <tmpl_if is_paragraph>
          <p><tmpl_var paragraph></p>
        </tmpl_if>

        <tmpl_if is_pull_quote>
          <p><blockquote><i>
            <tmpl_var pull_quote>
          </i></blockquote></p>
        </tmpl_if>

     </tmpl_loop>

   </body>
   </html>


This is a pretty boring example, but it illustrates the basic concepts of variable construction in Krang.  Because there are no elements containing children, the only loop that is available to the template is C<element_loop>.  While <tmpl_var paragraph> exists only once in the template, because it is within the context of <tmpl_loop element_loop>, both paragraphs will be built.

B<Results:>

=over

=item * Pros

=over

=item *

With only one template, everything is in a single place - easy to keep track of everything.

=item *

For simple stories, putting together a single template is fast.

=back

=item * Cons

=over

=item *

The complexity of the element tree is greatly limited.  No story elements can have children (this is why we could not use the first example story type, and had to use a simplified version).

=item *

There is no customizability - small variations require the entire template to be re-implemented each time.  If you want to publish a story in several different categories, each with it's own appearance, the entire template needs to be re-written each time.

=item *

Pagination (links between pages of a multiple-page story) is not available.

=back

=back

=head2 Example 2: Using Multiple Templates

The real power of Krang comes about when you start associating templates with elements within your stories.  By breaking up your templates into element-specific components, you can begin to really take control of how parts of your element tree will represent themselves when published.

Beyond the advantages of control and customizability, you can now support far more complex story architectures - the initial example of a Story element tree (with page elements) can now be supported.

B<The Example Story Tree>

Going back to the original example Story Tree:

   Story
        - Deck             (textbox attribute)
        + Page             (repeatable element)
             - Paragraph   (repeatable textbox attribute)
             - Pull Quote  (repeatable textbox attribute)
             - Paragraph   (repeatable textbox attribute)

While this may not look like a big step up from the element tree in Example 1, we're now making use of an important concept in Krang - elements that contain other elements as their children.

B<The Templates>

With the more complex element tree, we now need a minimum of two templates - a template for the story, and a template for the page element - which will handle its own children.

B<Page.tmpl>

Page.tmpl will look a lot like the inner loop <tmpl_loop element_loop> that was found in Story.tmpl for example 1.  By removing it from Story.tmpl, we now have a small, easy-to-maintain template with very simple functionality.


 <tmpl_loop element_loop>

   <tmpl_if is_paragraph>
     <p><tmpl_var paragraph></p>
   </tmpl_if>

   <tmpl_if is_pull_quote>
     <p><blockquote><i>
       <tmpl_var pull_quote>
     </i></blockquote></p>
   </tmpl_if>

 </tmpl_loop>



B<Story.tmpl>

The story template you see here is somewhat revised from the Story.tmpl you saw in the first example.


 <tmpl_loop page_loop>

   <html>

   <head>
     <title><tmpl_var title></title>
   </head>
   <body>

     <tmpl_if __first__>
        <h1><tmpl_var title></h1>
        <b><tmpl_var deck></b>
     </tmpl_if>

     <tmpl_var page>

     Page Number: <tmpl_var page_count>

   </body>
   </html>

   <tmpl_unless __last__>
     <tmpl_var page_break>
   </tmpl_unless>

 </tmpl_loop>

B<Questions>:

=over

=item *

Where do <tmpl_var page> and <tmpl_var page_count> come from?

Go back and re-read C<How Krang Builds Template Data>.  Each element within <tmpl_loop page_loop> contains two variables - <tmpl_var page> (containing the output from the page element), and <tmpl_var page_count> (which tells you what the number of the element is in the loop).

=item *

<tmpl_loop element_loop> has been removed, and replaced with <tmpl_loop page_loop>.

Rather than iterate over all child elements of Story, we're now looping over page elements, each of which will return the results of publishing with Page.tmpl above.

=item *

<tmpl_var page_break> ?

They are called B<page> elements.  Each page should be considered separate, the I<page_break> tag will tell Krang to create a new page for the next page element's content.

=item *

What's the deal with <tmpl_if __first__> and <tmpl_unless __last__> ?

__first__ and __last__ are loop variables that are always made available within the context of a <tmpl_loop>.

__first__ returns true if you are on the first iteration through a loop, false otherwise.

__last__ returns true if you are on the last iteration through a loop, false otherwise.

In this case, we're putting the story title and deck at the head of the first page only, and putting in a page break on every page except the last one.  Since we only have one page to this story, there's only one page break.

=back



B<Results:>

=over

=item Pros

=over

=item *

Two simplified templates are easier to understand than one large complex one.

=item * 

Customizability - multiple implementations of the Page template can be used to provide different layouts, all without touching the Story template.

=item *

Complex story types - multiple pages and all!

=back

=item Cons

=over

=item * 

Everything is no longer in a single spot - the developer is now forced to look in multiple locations for all template information.

=back

=back


=head2 The Next Step

You can create templates for any element you choose.  For example, the C<Pull Quote> element.  If you wanted all Pull Quotes to be identical in appearance, you could create a template specific to the Pull Quote.

B<Pull_Quote.tmpl>

 <p><blockquote><i>
   <tmpl_var pull_quote>
 </i></blockquote></p>


Now whenever Krang attempts to publish a Pull Quote element, rather than simply return the data stored within the Pull Quote element, it will return the formatted output.

The Page template can now stop formatting Pull Quotes:

B<Page.tmpl>

 <tmpl_loop element_loop>

   <tmpl_if is_paragraph>
     <p><tmpl_var paragraph></p>
   </tmpl_if>

   <tmpl_if is_pull_quote>
     <tmpl_var pull_quote>
   </tmpl_if>

 </tmpl_loop>



=head1 Varying Templates and Output by Category -- Overriding Templates

Every template created in Krang is associated with a category for a very specific reason:  When publishing a story, Krang uses the category under which that story is being published to determine where to look for element templates.

The process by which an element's template is chosen works as follows:

=over

=item *

You're publishing a story under the category C<www.foo.com/bar/baz/>.

=item *

For the element C<Page>, the Krang publish system will start looking in the template repository for C<page.tmpl> in C<www.foo.com/bar/baz/page.tmpl>.  As soon as it finds C<page.tmpl>, it will stop looking and continue the publish process using the newly-found template.

=item *

If C<page.tmpl> is not found there, it will move up directories, continuing to look for C<page.tmpl>.  C<www.foo.com/bar/page.tmpl>, followed by C<www.foo.com/page.tmpl>.

=item *

The last place it will check is the root category (underneath the site www.foo.com).  If it cannot find the required template at this point, an error message will be generated.

=back

As you build your site, you can now customize the appearance of your site on a site-by-site and category-by-category basis.

A further example - you have a story publishing under two different categories:  C<www.foo.com/foo> and C<www.foo.com/foo/bar/baz/>.  The basic pull_quote.tmpl template doesn't do anything special, it simply returns the Pull Quote.  But for the purposes of better design, the second category requires Pull Quotes in an entirely different format.  But at the same time, you don't want to affect the look of the story as it's published in the first category.

By creating a new pull_quote.tmpl for the category C<www.foo.com/foo/bar/baz/> with the necessary formatting, your job is done.  Only stories published under C<www.foo.com/foo/bar/baz/> (or the categories beneath it) will use that Pull Quote template, everything else will continue on unaffected.





=head1 Additional Publishing Components

=head2 Pagination

A whole set of template variables relating to pagination are created by Krang for specific elements.  These variables are built whenever Krang encounters an element with the attribute C<pageable> set to 1 (Generally the C<page> element -- See C<Creating Element Libraries in Krang> for more information).

To put things in the context of the previous example, pagination information will be available to Page.tmpl, B<not> to Story.tmpl.


B<Variables>

For pageable elements, the following variables are made available:

=over 4

=item current_page_number

Contains the number (starting at 1) of the current page being built.

=item total_pages

Contains the total number of pages in the story.

=item previous_page_url

Contains the URL of the previous page in the story.  Will be empty if on the first page of the story.

=item next_page_url

Contains the URL of the next page in the story.  Will be empty if on the last page of the story.

=item first_page_url

Contains the URL for the first page in the story.

=item last_page_url

Contains the URL for the last page in the story.

=item is_first_page

Boolean that will be true if the current page is the first page.

=item is_last_page

Boolean that will be true if the current page is the last page.

=item pagination_loop

Each element in the loop contains variables that correspond to pages in the story, in page order.

The variables in each loop element are as follows:

=over 4

=item is_current_page

Boolean that will be true if C<page_number> = C<current_page_number>.

=item page_number

The number of the page in the story, starting at 1.

=item page_url

The URL for the page.  Will be empty if C<page_number> = C<current_page_number>.

=back

=back

B<Updated Story Tree>

Since pagination isn't very interesting with only one page, let's add a second page to the previous Story Tree.  Furthermore, since the two pages are entirely separate constructs, there's no reason why the second page has to be identical to the first in structure.

   Story
        - Deck             (textbox attribute)
        + Page             (repeatable element)
             - Paragraph   (repeatable textbox attribute)
             - Pull Quote  (repeatable textbox attribute)
             - Paragraph   (repeatable textbox attribute)
        + Page             (repeatable element)
             - Pull Quote  (repeatable textbox attribute)
             - Paragraph   (repeatable textbox attribute)
             - Paragraph   (repeatable textbox attribute)
             - Paragraph   (repeatable textbox attribute)


B<Templates>

Continuing with the templates from the previous example, all the pagination logic will be found in Page.tmpl.  As a result, Story.tmpl becomes further simplified, as you will see.


B<Page.tmpl>

 <!-- Test for first page here -->
 <tmpl_if is_first_page>
    <h1><tmpl_var title></h1>
    <b><tmpl_var deck></b>
 </tmpl_if>

 <tmpl_loop element_loop>

    <tmpl_if is_paragraph>
      <p><tmpl_var paragraph></p>
    </tmpl_if>

    <tmpl_if is_pull_quote>
      <tmpl_var pull_quote>
    </tmpl_if>

 </tmpl_loop>

 <!-- Pagination at the bottom of the page -->

 <P>Currently reading page <tmpl_var current_page_number> of <tmpl_var total_pages>.<BR>

 <tmpl_unless is_first_page>
   <a href="<tmpl_var previous_page_url>">Previous Page</a>
 </tmpl_unless>

 <tmpl_loop pagination_loop>
   <tmpl_if is_current_page>
     <tmpl_var page_number>
   <tmpl_else>
     <a href="<tmpl_var page_url>"><tmpl_var page_number></a>
   </tmpl_if>
 </tmpl_loop>

 <tmpl_unless is_last_page>
   <a href="<tmpl_var next_page_url>">Next Page</a>
 </tmpl_unless>

 <!-- /Pagination -->


Notice a few things that used to exist in Story.tmpl?  The <tmpl_var title> and <tmpl_var deck> that should only appear on the first page can now be placed here.  And the <tmpl_var page_count> that used to provide an element (page) count is now pretty redundant as well.

The new Story.tmpl looks a lot smaller now:


B<Story.tmpl>

 <tmpl_loop page_loop>

   <html>

   <head>
     <title><tmpl_var title></title>
   </head>
   <body>

     <tmpl_var page>

   </body>
   </html>

   <tmpl_unless __last__>
     <tmpl_var page_break>
   </tmpl_unless>

 </tmpl_loop>

B<Note> - it is possible to move <tmpl_var page_break> into Page.tmpl as well, but would require moving around a lot of HTML and other page logic, in this case it's simply easier to leave it in place.




=head2 Links to Other Stories in Krang

Links to other stories are provided by whatever element subclasses Krang::ElementClass::StoryLink.  Something to remember here is that Krang does not put forth any rules as to the naming of elements in an element library - so an element that subclasses to Krang::ElementClass::StoryLink could be called anything.

B<NOTE:> While the lack of explicit element naming in Krang may sound odd, consider the possibilities - you can create multiple elements, all which provide links to other stories in Krang (e.g. they all subclass Krang::ElementClass::StoryLink), but each element can now have its own template, outputting links in its own way.

For the purposes of this example, the element will be called 'leadin'.

B<Story Tree>

Taking the story tree from C<Example 2>, we'll add a leadin element to the page:

   Story
        - Deck             (textbox attribute)
        + Page             (repeatable element)
             - Paragraph   (repeatable textbox attribute)
             - Pull Quote  (repeatable textbox attribute)
             - Paragraph   (repeatable textbox attribute)
             - Leadin      (repeatable storylink attribute)

B<Templates>

StoryLink elements can function with or without their own templates.

=over

=item * Without a template

If no corresponding template is found, the StoryLink object will simply return the URL to the connected story.

=item * Constructing a template:

If you decide to create a template, the following variables will be available as variables in the template: B<url>, B<title>

B<Leadin.tmpl>

 <a href="<tmpl_var escape=html url>"><tmpl_var title></a>

=back


The Page.tmpl template will treat leadin like any other child element - <tmpl_var leadin>, within <tmpl_loop element_loop>.  Be careful - this example Page.tmpl assumes that leadin is using the template above - if the leadin element has no template, the story URL will be displayed instead.

B<Page.tmpl>

 <!-- Test for first page here -->
 <tmpl_if is_first_page>
    <h1><tmpl_var title></h1>
    <b><tmpl_var deck></b>
 </tmpl_if>

 <tmpl_loop element_loop>

    <tmpl_if is_paragraph>
      <p><tmpl_var paragraph></p>
    </tmpl_if>

    <tmpl_if is_pull_quote>
      <tmpl_var pull_quote>
    </tmpl_if>

    <tmpl_if is_leadin>
      <p><tmpl_var leadin></p>
    </tmpl_if>

 </tmpl_loop>

 <!-- Pagination Removed to shorten Example -->





=head2 Links to Media Objects in Krang

Links to media objects are provided by whatever element (or elements) subclasses Krang::ElementClass::MediaLink.  In short, these elements will behave in the same way as elements that subclass Krang::ElementClass::StoryLink (see C<Links to Other Stories in Krang> in the section above).

B<NOTE:> Expect to use more than one element in your handling of media objects in Krang, simply because different media objects require different HTML.  Consider this - do you really want the URL to your Flash or PDF file embedded in an <img src=> tag?

For the purposes of this example, the element that handles links to Media Objects will be called 'image'.  

B<Story Tree>

Taking the story tree from C<Example 2>, we'll add a leadin element to the page:

   Story
        - Deck             (textbox attribute)
        + Page             (repeatable element)
             - Paragraph   (repeatable textbox attribute)
             - Pull Quote  (repeatable textbox attribute)
             - Paragraph   (repeatable textbox attribute)
             - Image       (repeatable medialink attribute)


B<Templates>

StoryLink elements can function with or without their own templates.

=over

=item * Without a template

If no corresponding template is found, the MediaLink object will simply return the URL to the object.

=item * Constructing a template:

If you decide to create a template, the following variables will be available as variables in the template: B<url>, B<title>, B<caption>

B<Image.tmpl>

 <img src="<tmpl_var escape=html url>">>
 <br>

 <tmpl_if title>
   <tmpl_var title><br>
 </tmpl_if>

 <tmpl_if caption>
   <tmpl_var caption><br>
 </tmpl_if>

=back


The Page.tmpl template will treat image like any other child element - <tmpl_var image>, within <tmpl_loop element_loop>.  Be careful - this example Page.tmpl assumes that the image element is using the template above.  If the image element has no template, the resulting HTML will simply display a URL to the image, rather than the image itself!


B<Page.tmpl>

 <!-- Test for first page here -->
 <tmpl_if is_first_page>
    <h1><tmpl_var title></h1>
    <b><tmpl_var deck></b>
 </tmpl_if>

 <tmpl_loop element_loop>

    <tmpl_if is_paragraph>
      <p><tmpl_var paragraph></p>
    </tmpl_if>

    <tmpl_if is_pull_quote>
      <tmpl_var pull_quote>
    </tmpl_if>

    <tmpl_if is_image>
      <p><tmpl_var image></p>
    </tmpl_if>

 </tmpl_loop>

 <!-- Pagination Removed to shorten Example -->



=head2 Category Templates

Just as elements can have templates, category elements may have a template associated with it called C<category.tmpl>.

For an example, let's imagine that we want to put a blue box around every page in our output. Instead of putting this HTML into our templates we'll do it in a category template.

The way this all works is by using the tag <tmpl_var content>.  This tag is handled internally by Krang, where it will replace the tag with the output of the Story element (Story.tmpl).

B<Templates>

B<Category.tmpl>

 <html>
 <head><tmpl_var title></head>
 <body>

 <table bgcolor=blue cellspacing=5 border=0><tr><td>

   <tmpl_var content>

 </td></tr></table>

 </body>
 </html>


Note that since the Category.tmpl template now makes up the header and footer of the document, Story.tmpl becomes greatly simplified:

B<Story.tmpl>

 <tmpl_loop page_loop>

     <tmpl_var page>

     <tmpl_unless __last__>
       <tmpl_var page_break>
     </tmpl_unless>

 </tmpl_loop>


B<NOTE:> Yes, the page-break logic is still correct in Story.tmpl.  Krang will take each page of output generated by Story.tmpl, and merge that page with Category.tmpl.




=head2 Contributors

Contributors in Krang are attached directly to stories.  They are made available to all elements as a list (tmpl_loop) of contributors, under the loop B<contrib_loop>.

B<Variables>

The variables that make up the contributors are as follows:

=over 4

=item contrib_loop

Each element in B<contrib_loop> corresponds to a single contributor.

Within each element, the following variables are available (corresponding to the parameters available within the Contributers interface):

=over 

=item contrib_id

The internal ID attached to the specific contributor.

=item prefix

The prefix of the contributor's name.

=item first

The contributor's first name.

=item middle

The contributor's middle name.

=item last

The contributor's last name.

=item suffix

The suffix of the contributor's name.

=item email

The contributor's email address.

=item phone

The contributor's phone number.

=item bio

The contributor's biography.

=item url

The url to the contributor's website.

=item contrib_type_loop

This loop corresponds to the the various tasks a contributor may have performed (e.g. Writer, Illustrator).  The loop exists because a single contributor may have performed multiple tasks for a given story.

Within this loop, there are two fields:

=over

=item contrib_type_id

The internal id of the task performed.

=item contrib_type_name

The name of the task performed (e.g. Writer).


=back

=back

=back

B<Templates>

In this case, we want to publish contributors on the first page of the story.  Because of this, the contributors loop should be placed in Page.tmpl.


B<Page.tmpl>

 <tmpl_if is_first_page>
    <h1><tmpl_var title></h1>
    <b><tmpl_var deck></b>

    <!-- Contributors on the first page only! -->

    <p>Contributors to this story:
      <tmpl_if contrib_loop>
         <tmpl_loop contrib_loop>
            <tmpl_var prefix> <tmpl_var first> <tmpl_var last><br>
            <tmpl_if contrib_type_loop>
               <tmpl_loop contrib_type_loop>
                  Task ID:   <tmpl_var contrib_type_id><BR>
                  Task Name: <tmpl_var contrib_type_name>
               </tmpl_loop>
            </tmpl_if>
         </tmpl_loop>
      <tmpl_else>
         None.
      </tmpl_if>

    <!-- /Contributors -->

 </tmpl_if>

 <tmpl_loop element_loop>
    <tmpl_if is_paragraph>
      <p><tmpl_var paragraph></p>
    </tmpl_if>
    <tmpl_if is_pull_quote>
      <p><blockquote><i>
    <tmpl_var pull_quote>
      </i></blockquote></p>
    </tmpl_if>
 </tmpl_loop>


 <!-- Further Pagination information removed to keep the example short -->








-------------------------------------------





=head1 Publishing with Customized Publish Methods

=head1 Overriding Krang::ElementClass Methods in Your Element Library

If you do decide to make changes to the publish process, the following methods exist in Krang::ElementClass as part of the publish process, and can be overridden as needed:

=over

=item * template_data()

This returns the data stored in the element.  In most cases, it's the actual data stored in the element, unformatted.  In the case of C<Krang::ElementClass::StoryLink> or C<Krang::ElementClass::MediaLink> objects, C<template_data()> will return the fully-qualified URL of the object.

If you want to change the form of the returned data for a single class of element in your element library, overriding template_data() for that element should be the first thing you try.


=item * fill_template()

fill_template() is responsible for filling the template object with data built from the element tree.  Generally, it traverses the element tree, creating scalars and loops on an as-needed basis, populating the template objects with the results.  The rules by which fill_template() operates can be found in C<Example 1>.

If you are familiar with Bricolage, fill_template() functions using the same rules as the autofill() functionality found in Bricolage.

This method is the most likely candidate for overriding, as this is the method that actually determines what goes into the template.

This method is responsible for calling publish() on all children of the current element.  If you decide to override fill_template, but don't want to deal with the manual work of walking the element tree, make sure to make a call to $self->SUPER::fill_template().


=item * find_template()

Returns an HTML::Template::Expr object with the template to be used by the element.  Follows a specific procedure for locating the template on the filesystem.

Unless you need to alter the process for loading templates (e.g. you don't want a template to get loaded under certain circumstances), this method should generally be left alone.

=item * publish()

Ties the above methods together and returns HTML for the current element (and therefore, any children beneath it).  Overriding publish() is a pretty drastic action, and should only be done if absolutely needed. 

publish() takes a hash as an argument, allowing for named parameters.  Anything passed in will subsuquently be passed into the above methods.

=back

Read the POD for C< Krang::ElementClass > if you want to learn more about how these methods work, and how to use them.


=head1 Example 3: Using One Large Template

In this case, we have a very simple system, a single story template made up of basic elements:

=head2 The Template - Story.tmpl

 #
 # NOTE - need notes on how to save template properly in the Krang::Template hierarchy..
 #

 <tmpl_loop page_loop>

   <html>

   <head>
     <title><tmpl_var title></title>
   </head>
   <body>

     <tmpl_if __first__>
        <h1><tmpl_var title></h1>
        <b><tmpl_var deck></b>
     </tmpl_if>

     <tmpl_loop element_loop>
        <tmpl_if paragraph>
          <p><tmpl_var paragraph></p>
        </tmpl_if>
        <tmpl_if name eq "pull quote">
          <p><blockquote><i>
            <tmpl_var name="pull quote">
          </i></blockquote></p>
        </tmpl_if>
     </tmpl_loop>

     <tmpl_unless __first__>
     <a href=<tmpl_var expr="prev_page_link(page_count)">>Previous Page</a>
     </tmpl_unless>

     <tmpl_unless __last__>
     <a href=<tmpl_var expr="next_page_link(page_count)">>Next Page</a>
     </tmpl_unless>

   </body>
   </html>

   <tmpl_var page_break>

 </tmpl_loop>



=head2 The Overridden Element Method

In the Package that describes the Story element, we'll override the fill_template() method.  For the time being, the find_template() and publish() methods will be left alone (see Krang::ElementClass POD for more info).

 sub fill_template {

  my $self = shift;
  my (%named_params) = @_;

  my $template = $named_params{template};
  my $story    = $named_params{story};

  # setup story title
  $template->param(title => $story->title());

  # setup story slug
  $template->param(slug => $story->slug());

  # setup the page break variable
  $template->param(page_break => Krang::Publisher::PAGE_BREAK);

  my $deck_element = $self->children('deck');
  $template->param(deck => $deck_element->publish());

  # Build up @page_loop
  my @page_list = $self->match('/page'); # returns all elements
  my @page_loop;
  my $page_count = 1;

  foreach my $page (@page_list) {

    # build per-page element loop
    my @element_loop;
    foreach my $e ($page->children()) {
        # push on a row for this element
        push(@element_loop, { $e->name() => $e->publish(@_) });
    }

    # push element_loop and a page_count on this loop
    push(@page_loop, { 
                      element_loop => \@element_loop,
                      page_count   => $page_count++
                     });
  }

  # finish the page_loop
  $template->param(page_loop => \@page_loop);

 }



=head2 RESULTS

Using the basic element set, we now have a single story template that can be used when generating content.

Advanteges:

* Single page, single element.  Everything's centrally located, and easy to manipulate.

Disadvanteges:

* With a single template, customization for individual stories is very difficult - there's no possibility of re-using this element in a different tree - it would need to be re-written.





=head1 Example 4: Multiple Templates, Multiple Publish Methods

The last example takes everything done so far, and rolls it all up - using templates for individual elements, and overloading the publish() method within elements, rather than relying on the default publish() method.

One of the advanteges of this rolling your own publish() methods in this case is the ability to pass variables to the sub-element template that would otherwise not exist.  In Example 3, there was no way to use __first__ and __last__ logic in Page.tmpl, because that information was not available.  This can be fixed here.


=head2 The Templates

B<Story.tmpl>

 <tmpl_loop page_loop>

   <html>

   <head>
     <title><tmpl_var title></title>
   </head>
   <body>

     <tmpl_var page>

   </body>
   </html>

   <tmpl_var page_break>

 </tmpl_loop>

MUCH smaller.  All the logic involving __first__ and __last__ has now been moved over to Page.tmpl, where it really belongs.  


B<Page.tmpl>

 <tmpl_if first>
    <h1><tmpl_var title></h1>
    <b><tmpl_var deck></b>
 </tmpl_if>

 <tmpl_loop element_loop>
    <tmpl_if is_paragraph>
      <p><tmpl_var paragraph></p>
    </tmpl_if>
    <tmpl_if is_pull_quote>
      <p><blockquote><i>
    <tmpl_var pull_quote>
      </i></blockquote></p>
    </tmpl_if>
 </tmpl_loop>

 <tmpl_unless first>
   <a href=<tmpl_var expr="prev_page_link(page_count)">>Previous Page</a>
 </tmpl_unless>

 <tmpl_unless last>
   <a href=<tmpl_var expr="next_page_link(page_count)">>Next Page</a>
 </tmpl_unless>


So Page.tmpl is larger than before, but it makes more sense - all the Page logic is now in one place.


=head2 The publish() Methods

As Page.tmpl now needs to know about what page is currently being processed, the publish() method for both the Story element and then Page element needs to be overloaded.

B<Story>

The fill_template() method for Story needs to be able to pass page_count information to the publish() method for Page.  In turn, publish() will pass it to the fill_template() for Page.


 sub fill_template {

  my ($self, $story, $publisher) = @_;

  my $template = $named_params{template};

  # Get the list of pages into @pages
  my @pages = $self->match('/page');
  my @page_loop = ();
  my $page_count = 1;

  foreach my $page (@pages) {
    # each $page is an element
    push @page_loop, { page => $page->publish(story => $story,
                                              page_count => $page_count++,
                                              pages      => scaler @pages
                                             )
                     };
  }

  # populate template.
  $template->param(page_loop => \@page_loop);

 }


B<Page>

So now that the fill_template() method for Story has passed the page count information along, the fill_template() method for Page needs to use that information.

 sub fill_template {

  my $self = shift;
  my %named_parms = @_;

  my $template = $named_params{template};

  my $story = $named_params{story};
  my $page_count = $named_params{page_count};
  my $page_total = $named_params{page_total};

  # setup params
  if ($page_count == 0) {
     $template->param(first => 1);
  }
  if ($page_count == $page_total) {
     $template->param(last => 1);
  }

  $template->param(title => $story->title());

  # setup story slug
  $template->param(slug => $story->slug());

  # setup the page break variable
  $template->param(page_break => Krang::Publisher::PAGE_BREAK);

 }




=head2 Conclusion

B<Advantages>

=over

=item * This style is very flexible - the programmer can add functionality to the autofilled content without having to re-invent the wheel.

=item * Elements that are broken out into discrete scripts and templates can be reused between element trees.

=item * In this particular case bending the rules a bit allows the page formatting to be more logically grouped and easier to edit.

=back

B<Disadvantages>

=over

=item * Requires coding.

=item * Requires communication between template programmer and template designer since the variables and loops are somewhat different from the normal autofill setup.

=back



=head2 Methods

Generally, the default fill_template() method should be sufficient - but for reference purposes, overriding it would go as follows:

 sub fill_template {
    my $self = shift;
    my %named_params = @_;
    my $template = $named_params{template};
    my $element  = $named_params{element};

    # get linked object from element
    my $media = $self->data();

    # fill in URL to link to media  -- creates a varable based on element name.
    $template->param($element->name . "_url" => $media->url);
    # fill in image caption
    $template->param(caption => $media->caption);

 }




=head2 Methods

B<fill_template();>

Generally, the default fill_template() will suffice.  For reference, here's a sample:

 sub fill_template {

  my $self = shift;
  my %named_params = @_;

  my $story = $named_params{story};
  my $template = $named_params{template};

  $template->param(title => $story->title());

 }




=head2 Code Example

If you decide to override B<fill_template()> and still need contributors data, use the following example as your guide (again, derived from Example 4).


 sub fill_template {

  my $self = shift;
  my %named_parms = @_;

  my $template = $named_params{tmpl};
  my $publisher = $named_params{publisher};
  my $element   = $named_params{element};

  my $story = $publisher->story();

  $template->param(title => $story->title())
    if $template->query(name => 'title');

  # setup story slug
  $template->param(slug => $story->slug())
    if $template->query(name => 'slug');

  # setup the page break variable
  $template->param(page_break => Krang::Publisher::PAGE_BREAK)
    if $template->query(name => 'page_break');

  $template->param(contrib_loop => $self->_build_contrib_loop(@_))
    if ($template->query(name => 'contrib_loop);


 }
