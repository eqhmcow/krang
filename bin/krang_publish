#!/usr/bin/perl 
use warnings;
use strict;

use File::Spec::Functions qw(catdir splitdir);
use FindBin qw($RealBin);
use Getopt::Long;
use Pod::Usage;
use Config;
use Carp;

=head1 NAME

krang_publish - command-line publishing utility for Krang.

=head1 SYNOPSIS

Publish everything (all stories & media for all sites) in a krang installation:

  $ krang_publish --everything

Publish all assets of a single site, specified by site_id

  $ krang_publish --site_id 10

Publish all assets for a given category, specified by category_id

  $ krang_publish --category_id 10

Publish a specific story and all related assets (linked stories and media)

  $ krang_publish --story_id 10

Publish a series of stories and their related assets

  $ krang_publish --story_id 10,11,12

The alternative form for multiple-story publish

  $ krang_publish --story_id 10 --story_id 11 --story_id 12


Publish all assets of a single site, but only those assets that have been previously published

  $ krang_publish --site_id 10 --republish_only

=head1 DESCRIPTION

This script provides a command-line tool for publishing content in
Krang.  Large-scale publish jobs (e.g. entire sites, or moreso, entire
installations) should use this tool rather than the web UI, as the web
UI is not well-suited to larger publish runs.

=head1 OPTIONS

=over

=item --everything

Publish all content (stories and media) in a Krang installation.

Using the --everything flag will cause krang_publish to ignore the
--site_id, --category_id, --story_id and --media_id options.

=item --site_id

Publish all content (stories and media) under the site specified by the site_id.

Using the --site_id flag will cause krang_publish to ignore the --category_id, --story_id and --media_id options.

=item --limited_to_site

An option addendum to --site_id, any related stories or media that are outside of the specified site will not be published.

B<WARNING>: The intended use case for this option would be an installation that is already in production and underwent template changes to a specific site, requiring a re-publish for that site *only*.  This option should not be used unless you are absolutely sure that stories and media outside of this site are in place in the publish path, or broken links in the publish path may result.

=item --category_id

Publish all content (stories and media) under the category specified by the category_id.

Using the --category_id flag will cause krang_publish to ignore the --story_id and --media_id options.

=item --limited_to_category

An option addendum to --category_id, any related stories or media that are outside of the specified category will not be published.

B<WARNING>: The intended use case for this option would be an installation that is already in production and underwent template changes to a specific category, requiring a re-publish for that category *only*.  This option should not be used unless you are absolutely sure that stories and media outside of this category are in place in the publish path, or broken links in the publish path may result.

=item --story_id

Publishes the story and related media objects associated with the story_id.  Supports multiple --story_id arguments, or a single --story_id argument with a comma-separated list of IDs to publish more than one story.

=item --media_id

Publish a single media object, specified by its media_id.  B<CURRENTLY BROKEN>

=item --republish_only

This modifier will limit the publish process to assets that have been published previously.

=item --to-preview

Publish files to preview rather than the publish location.

=item --verbose

Increases the level of output to STDOUT to give a more in-depth explanation of what is going on.

=back

=cut


BEGIN {
    # Find a KRANG_ROOT based on path to bin
    my @dir = splitdir($RealBin);
    $ENV{KRANG_ROOT} ||= catdir(@dir[0 .. $#dir - 1]);

    # use $KRANG_ROOT/lib for modules
    my $lib    = catdir($ENV{KRANG_ROOT}, "lib");
    $ENV{PERL5LIB} = $ENV{PERL5LIB} ? "$ENV{PERL5LIB}:${lib}" : 
      "${lib}";
    unshift @INC, $lib, "$lib/".$Config{archname};

    # load Krang::Conf (don't need to load Krang here because we won't
    # be slinging elements)
    eval { require Krang::Conf };
    die <<"END" if $@;
######################################################################

Cannot load Krang.

Error message:

$@

######################################################################
END
}


# Krang Libs
use Krang::Script;
use Krang::Conf qw(KrangRoot ElementLibrary);
use Krang::Story;
use Krang::Media;
use Krang::Category;
use Krang::Site;
use Krang::Publisher;
use Krang::Message qw(add_message);
use Krang::Cache;

use Time::HiRes qw(gettimeofday tv_interval);

# Setup - grabbing all the command-line options.

my %id  = map { ($_, [])} qw(story_id media_id category_id site_id);

my ($help, $man, $everything, $verbose) = (0, 0, 0, 0);
my $limited_to_site     = 0;
my $limited_to_category = 0;
my $republish_only      = 0;
my $increment           = 100;
my $media_only          = 0;
my $to_preview          = 0;

pod2usage(2) unless
  GetOptions(help                => \$help,
             man                 => \$man,

             verbose             => \$verbose,
             everything          => \$everything,
             limited_to_site     => \$limited_to_site,
             limited_to_category => \$limited_to_category,
             republish_only      => \$republish_only,
             'to-preview'        => \$to_preview,

             'increment=i'       => \$increment,

             (map { ("$_=s", $id{$_}) } keys %id)

            );

pod2usage(1)             if $help;
pod2usage(-verbose => 2) if $man;

pod2usage("Unrecognized options to krang_publish: '" . join(' ', @ARGV) . "'\n")
  if @ARGV;

# turn on the cache
Krang::Cache::start();

# figure out how these command-line options affect find criteria.
my %find_options = (limit => $increment, offset => 0);
my %publish_args = (callback => \&_progress_callback,
                    skip_callback => \&_skip_callback
                   );

if ($republish_only) {
    $find_options{publish_status} = 1;
}


my $arg_string = "Publishing content with the following options:\n$0";

my $has_options = 0;

if ($everything) {
    # removes checking for related stories/media.
    $publish_args{disable_related_assets} = 1;

    $arg_string .= " --everything\n";

    $has_options = 1;
} else {
    # NOTE: --site_id and --category_id options are mutually 
    #       exclusive from --story_id and --media_id.
    if (@{$id{site_id}} || @{$id{category_id}}) {
        if (@{$id{site_id}}) {
            $find_options{site_id} = $id{site_id}[0];
            $arg_string .= " --site_id $find_options{site_id}";
            $has_options = 1;
        } elsif (@{$id{category_id}}) {
            $find_options{category_id} = $id{category_id}[0];
            $arg_string .= " --category_id $find_options{category_id}";
            $has_options = 1;
        }
    } elsif (@{$id{story_id}} || @{$id{media_id}}) {
        # you can specify both --story_id and --media_id
        # arguments simultaneously.
        if (@{$id{story_id}}) {
            $arg_string .= " --story_id $id{story_id}[0]";
            if ((@{$id{story_id}} == 1 && $id{story_id}[0] =~ /,/)) {
                $id{story_id} = [ split /,/, $id{story_id}[0] ];
            }
            $find_options{story_id} = $id{story_id};
            $has_options = 1;
        }

        if (@{$id{media_id}}) {
            $arg_string .= " --media_id $id{media_id}[0]";
            if ((@{$id{media_id}} == 1 && $id{media_id}[0] =~ /,/)) {
                $id{media_id} = [ split /,/, $id{media_id}[0] ];
            }
            $find_options{media_id} = $id{media_id};
            $has_options = 1;
        }
    }
}

# If there are no command-line options, return the equivilant of --help.
pod2usage(1) unless $has_options;

# Start the publish process.
my $publisher = Krang::Publisher->new();

########################################
## Time/Count Variables
##
my $increment_count = 0;
my $increment_time  = 0;

my $total_storytime = 0;
my $total_storycount = 0;
my $total_mediatime = 0;
my $total_mediacount = 0;

my @assettime;
my $storycount = 0;
my $mediacount = 0;

# if the --everything option was specified, all media needs to be published first.
# Additionally, if the --media_id option was used, do it first.

if ($everything || $find_options{media_id}) {
    my $story_id;

    # remove story_id if it's also a param
    if (exists($find_options{story_id})) {
        $story_id = $find_options{story_id};
        delete $find_options{story_id};
    }

    publish_media(\%find_options, \%publish_args);

    # delete media_id from find_options.
    delete $find_options{media_id};

    # restore story_id if needed.
    $find_options{story_id} = $story_id if $story_id;
}

if ($everything || $find_options{story_id} || 
    $find_options{category_id} || $find_options{site_id}) {

    publish_stories(\%find_options, \%publish_args);

}

print "\n\nSTATUS: Publish completed.\n======================================================================\n";
print "$arg_string\n\nResults:\n";
print "\ntype\t\tnumber published\ttime(seconds)\tseconds/asset\n";
print "----------------------------------------------------------------------\n";
printf("stories\t\t%i\t\t\t%.02f\t\t%.02f\n", $total_storycount, $total_storytime, (($total_storytime > 0) ? ($total_storytime/$total_storycount) : 0));
printf("media\t\t%i\t\t\t%.02f\t\t%.02f\n", $total_mediacount, $total_mediatime, (($total_mediatime > 0) ? ($total_mediatime/$total_mediacount) : 0));

print "----------------------------------------------------------------------\n";
printf("TOTAL:\t\t%i assets\t\t%.02f seconds\n\n", ($total_storycount+$total_mediacount), $increment_time);

my ($hits, $loads, $fill) = Krang::Cache::stats();
printf("CACHE HITS:\t\t%d\n", $hits)
  if $verbose and Krang::Cache::active();
printf("CACHE FILL AT END:\t\t%d\n\n", $fill)
  if $verbose and Krang::Cache::active();




sub publish_media {

    my ($find_options, $publish_args) = @_;

    # make sure we're starting at the beginning.
    $find_options->{offset} = 0;

    while (my @media = Krang::Media->find(%{$find_options})) {
        my @starttime = gettimeofday();
        @assettime = @starttime;

        eval { 
            if ($to_preview) {
                foreach my $media (@media) {
                    $publisher->preview_media(media => $media, %$publish_args);
                }
            } else {
                $publisher->publish_media(media => \@media, %{$publish_args}); 
            }
        };
        if (my $err = $@) {
            if ($err->isa('Krang::Publisher::FileWriteError')) {
                print STDOUT sprintf("ERROR:\n%s\:\nsource='%s'\ndestination='%s'\nerror='%s'\n",
                                     $err->{message}, $err->{source}, $err->{destination},
                                     $err->{system_error});
                croak;
            } else {
                croak($err);
            }
        }

        my $endtime = tv_interval(\@starttime);

        print sprintf("STATUS: media %i - %i published in %.02f seconds.\n", ($find_options->{offset}+1), ($find_options->{offset} + @media), $endtime);

        $increment_time  += $endtime;
        $increment_count += @media;

        $total_mediacount += $mediacount;
        $mediacount = 0;

        last if (@media < $increment);
        $find_options->{offset} += $increment;
    }

    # cleanup.
    $find_options->{offset} = 0;

}


sub publish_stories {

    my ($find_options, $publish_args) = @_;

    # make sure offset is reset
    $find_options->{offset} = 0;

    while (my @stories = Krang::Story->find(%{$find_options})) {

        if (@stories == $increment) {
            $publish_args->{keep_asset_list} = 1;
        } else { 
            $publish_args->{keep_asset_list} = 0;
        }

        my @starttime = gettimeofday();
        @assettime = @starttime;

        eval {
            if ($to_preview) {
                foreach my $story (@stories) {
                    $publisher->preview_story(story => $story, %$publish_args);
                }

            } else {
                $publisher->publish_story(story => \@stories, %$publish_args);
            }
        };

        if ($@) {
            # if there is an error, figure out what it is, create the
            # appropriate message and return.
            if (ref $@ && $@->isa('Krang::ElementClass::TemplateNotFound')) {
                add_message('missing_template',
                            filenname      => $@->template_name,
                            category_url   => $@->category_url
                           );
            } elsif (ref $@ && $@->isa('Krang::ElementClass::TemplateParseError')) {
                add_message('template_parse_error',
                            element_name  => $@->element_name,
                            template_name => $@->template_name,
                            category_url  => $@->category_url,
                            error_msg     => $@->error_msg
                           );
            }
            die($@);
        }


        my $endtime = tv_interval(\@starttime);

        print sprintf("STATUS: Stories %i - %i (%i stories, %i media) published in %.02f seconds.\n", ($find_options->{offset}+1), ($find_options->{offset} + @stories), $storycount, $mediacount, $endtime);

        # add everything up.
        $increment_time  += $endtime;
        $increment_count += @stories;

        $total_storycount += $storycount;
        $total_mediacount += $mediacount;

        $storycount = 0;
        $mediacount = 0;

        last if (@stories < $increment);
        $find_options->{offset} += $increment;
    }

    # offset cleanup, to be sure.
    $find_options->{offset} = 0;

}


sub _skip_callback {
    my %args = @_;

    my $object = $args{object};

    if ($object->isa('Krang::Story')) {
        print sprintf("WARNING:  Story ID=%i was not published - it is currently checked out by User ID=%i\n", 
                      $object->story_id, $object->checked_out_by);
    } elsif ($object->isa('Krang::Media')) {
        print sprintf("WARNING:  Media ID=%i was not published - it is currently checked out by User ID=%i\n", 
                      $object->media_id, $object->checked_out_by);
    } else {
        print sprintf("WARNING: Unknown object of type=%s was not published.\n", $object->isa());
    }

}



# update the progress bar during preview or publish
sub _progress_callback {
    my %arg = @_;
    my ($object, $counter, $total) = @arg{qw(object counter total)};
    my $string;


    my $endtime = tv_interval(\@assettime);

    if ($object->isa('Krang::Story')) {
        $string .= sprintf("Published story_id=%i (time=%.02f url=%s)", $object->story_id, $endtime, $object->url);
        $storycount++;
        $total_storytime += $endtime;
    } elsif ($object->isa('Krang::Media')) {
        $string .= sprintf("Published media_id=%i (time=%.02f url=%s)", $object->media_id, $endtime, $object->url);
        $mediacount++;
        $total_mediatime += $endtime;
    } else {
        print "Unknown object type=" . $object->isa() . "\n";
    }

    if ($verbose) {
        print "$string\n";
    }
    @assettime = gettimeofday();
}
